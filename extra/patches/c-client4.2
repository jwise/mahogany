--- ../c-client-4.2.original/env_unix.c	Tue Jul 14 02:55:36 1998
+++ env_unix.c	Thu Aug  6 20:08:48 1998
@@ -964,7 +964,7 @@
  *	    path name buffer, preloaded with driver-dependent path
  * Returns: T on success, NIL on failure
  *
- * This routine is evil and a truly incredible kludge.  It is private for
+ * This routine is evil and a truly incredible kludge.  It is ccprivate for
  * tmail/dmail and is not supported for any other application.
  */
 
--- ../c-client-4.2.original/imap4r1.c	Fri Jul 17 20:10:53 1998
+++ imap4r1.c	Thu Aug  6 20:08:48 1998
@@ -996,7 +996,7 @@
   aatt.type = ATOM; aatt.text = NIL;
   if (flags & FT_UID)		/* see if can find msgno from UID */
     for (i = 1; i <= stream->nmsgs; i++)
-      if ((elt = mail_elt (stream,i))->private.uid == msgno) {
+      if ((elt = mail_elt (stream,i))->ccprivate.uid == msgno) {
 	msgno = i;		/* found msgno, use it from now on */
 	flags &= ~FT_UID;	/* no longer a UID fetch */
       }
@@ -1012,9 +1012,9 @@
     }
 				/* now hunt for this UID */
     for (i = 1; i <= stream->nmsgs; i++)
-      if ((elt = mail_elt (stream,i))->private.uid == msgno) {
-	if (body) *body = elt->private.msg.body;
-	return elt->private.msg.env;
+      if ((elt = mail_elt (stream,i))->ccprivate.uid == msgno) {
+	if (body) *body = elt->ccprivate.msg.body;
+	return elt->ccprivate.msg.env;
       }
     if (body) *body = NIL;	/* can't find the UID */
     return NIL;
@@ -1031,19 +1031,19 @@
     }
   }
   else {			/* normal cache */
-    env = &elt->private.msg.env;/* get envelope and body pointers */
-    b = &elt->private.msg.body;
+    env = &elt->ccprivate.msg.env;/* get envelope and body pointers */
+    b = &elt->ccprivate.msg.body;
 				/* prefetch if don't have envelope */
     if ((k = imap_lookahead) && !*env)
 				/* build message number list */
       for (i = msgno + 1, s = seq; k && (i <= stream->nmsgs); i++)
-	if (!mail_elt (stream,i)->private.msg.env) {
+	if (!mail_elt (stream,i)->ccprivate.msg.env) {
 	  s += strlen (s);	/* find string end, see if nearing end */
 	  if ((s - seq) > (MAILTMPLEN - 20)) break;
 	  sprintf (s,",%ld",i);	/* append message */
  	  for (j = i + 1, k--;	/* hunt for last message without an envelope */
 	       k && (j <= stream->nmsgs) &&
-	       !mail_elt (stream,j)->private.msg.env; j++, k--);
+	       !mail_elt (stream,j)->ccprivate.msg.env; j++, k--);
 				/* if different, make a range */
 	  if (i != --j) sprintf (s + strlen (s),":%ld",i = j);
 	}
@@ -1057,7 +1057,7 @@
     }
 				/* need anything else? */
     if (body && !*b) strcat (tmp," BODYSTRUCTURE");
-    if (!elt->private.uid) strcat (tmp," UID");
+    if (!elt->ccprivate.uid) strcat (tmp," UID");
     if (!(elt->rfc822_size && elt->day))
       strcat (tmp," INTERNALDATE RFC822.SIZE");
     if (tmp[0]) {		/* anything to do? */
@@ -1209,19 +1209,19 @@
 				/* IMAP2 didn't have UIDs */
   if (!LEVELIMAP4 (stream)) return msgno;
 				/* do we know its UID yet? */
-  if (!(elt = mail_elt (stream,msgno))->private.uid) {
+  if (!(elt = mail_elt (stream,msgno))->ccprivate.uid) {
     aseq.type = SEQUENCE; aseq.text = (void *) seq;
     aatt.type = ATOM; aatt.text = (void *) "UID";
     args[0] = &aseq; args[1] = &aatt; args[2] = NIL;
     sprintf (seq,"%ld",msgno);
     if (k = imap_uidlookahead) {/* build UID list */
       for (i = msgno + 1, s = seq; k && (i <= stream->nmsgs); i++)
-	if (!mail_elt (stream,i)->private.uid) {
+	if (!mail_elt (stream,i)->ccprivate.uid) {
 	  s += strlen (s);	/* find string end, see if nearing end */
 	  if ((s - seq) > (MAILTMPLEN - 20)) break;
 	  sprintf (s,",%ld",i);	/* append message */
 	  for (j = i + 1, k--;	/* hunt for last message without a UID */
-	       k && (j <= stream->nmsgs) && !mail_elt (stream,j)->private.uid;
+	       k && (j <= stream->nmsgs) && !mail_elt (stream,j)->ccprivate.uid;
 	       j++, k--);
 				/* if different, make a range */
 	  if (i != --j) sprintf (s + strlen (s),":%ld",i = j);
@@ -1231,7 +1231,7 @@
     if (!imap_OK (stream,reply = imap_send (stream,"FETCH",args)))
       mm_log (reply->text,ERROR);
   }
-  return elt->private.uid;	/* return our UID now */
+  return elt->ccprivate.uid;	/* return our UID now */
 }
 
 /* IMAP fetch message number from UID
@@ -1257,7 +1257,7 @@
   if (!imap_OK (stream,reply = imap_send (stream,"UID FETCH",args)))
     mm_log (reply->text,ERROR);
   for (msgno = 1; msgno <= stream->nmsgs; msgno++)
-    if (mail_elt (stream,msgno)->private.uid == uid) return msgno;
+    if (mail_elt (stream,msgno)->ccprivate.uid == uid) return msgno;
   return 0;			/* didn't find the UID anywhere */
 }
 
@@ -1326,7 +1326,7 @@
     for (i = 1; k && (i <= stream->nmsgs); ++i) 
 				/* for searched messages with no envelope */
       if ((elt = mail_elt (stream,i)) && elt->searched &&
-	  !mail_elt (stream,i)->private.msg.env) {
+	  !mail_elt (stream,i)->ccprivate.msg.env) {
 				/* prepend with comma if not first time */
 	if (LOCAL->tmp[0]) *s++ = ',';
 	sprintf (s,"%ld",j = i);/* output message number */
@@ -1335,7 +1335,7 @@
 				/* search for possible end of range */
 	while (k && (i < stream->nmsgs) &&
 	       (elt = mail_elt (stream,i+1))->searched &&
-	       !elt->private.msg.env) i++,k--;
+	       !elt->ccprivate.msg.env) i++,k--;
 	if (i != j) {		/* if a range */
 	  sprintf (s,":%ld",i);	/* output delimiter and end of range */
 	  s += strlen (s);	/* point at end of string */
@@ -1442,7 +1442,7 @@
     for (i = 1,start = last = 0,s = NIL; i <= stream->nmsgs; ++i)
       if ((elt = mail_elt (stream,i))->searched) {
 	pgm->nmsgs++;
-	if (needenvs ? !elt->private.msg.env : !elt->day) {
+	if (needenvs ? !elt->ccprivate.msg.env : !elt->day) {
 	  if (s) {		/* continuing a sequence */
 	    if (i == last + 1) last = i;
 	    else {		/* end of range */
@@ -1678,7 +1678,7 @@
   if (gcflags & GC_TEXTS) {	/* garbage collect texts? */
     if (!stream->scache) for (i = 1; i <= stream->nmsgs; ++i)
       if (elt = (MESSAGECACHE *) (*mc) (stream,i,CH_ELT))
-	imap_gc_body (elt->private.msg.body);
+	imap_gc_body (elt->ccprivate.msg.body);
     imap_gc_body (stream->body);
   }
 				/* gc cache if requested and unlocked */
@@ -2286,7 +2286,7 @@
     else if (!strcmp (s,"EXPUNGE") && msgno && (msgno <= stream->nmsgs)) {
       mailcache_t mc = (mailcache_t) mail_parameters (NIL,GET_CACHE,NIL);
       MESSAGECACHE *elt = (MESSAGECACHE *) (*mc) (stream,msgno,CH_ELT);
-      if (elt) imap_gc_body (elt->private.msg.body);
+      if (elt) imap_gc_body (elt->ccprivate.msg.body);
 				/* notify upper level */
       mail_expunged (stream,msgno);
     }
@@ -2317,14 +2317,14 @@
 	  fs_give ((void **) &s);
 	}
 	else if (!strcmp (prop,"UID")) /* unique identifier */
-	  elt->private.uid = strtoul (t,&t,10);
+	  elt->ccprivate.uid = strtoul (t,&t,10);
 	else if (!strcmp (prop,"ENVELOPE")) {
 	  if (stream->scache) {	/* short cache, flush old stuff */
 	    mail_free_body (&stream->body);
 	    stream->msgno = elt->msgno;
 	    e = &stream->env;	/* get pointer to envelope */
 	  }
-	  else e = &elt->private.msg.env;
+	  else e = &elt->ccprivate.msg.env;
 	  imap_parse_envelope (stream,e,&t,reply);
 	}
 	else if (!strncmp (prop,"BODY",4)) {
@@ -2340,7 +2340,7 @@
 				/* get pointer to body */
 	      body = &stream->body;
 	    }
-	    else body = &elt->private.msg.body;
+	    else body = &elt->ccprivate.msg.body;
 				/* flush any prior body */
 	    mail_free_body (body);
 				/* instantiate and parse a new body */
@@ -2353,7 +2353,7 @@
 				/* will want to return envelope data */
 	    if (!strcmp (md.what = cpystr (prop + 5),"HEADER]") ||
 		!strcmp (md.what,"0]"))
-	      e = stream->scache ? &stream->env : &elt->private.msg.env;
+	      e = stream->scache ? &stream->env : &elt->ccprivate.msg.env;
 	    LOCAL->tmp[0] ='\0';/* no errors yet */
 				/* found end of section? */
 	    if (!(s = strchr (md.what,']'))) {
@@ -2420,7 +2420,7 @@
 	    text.data = (unsigned char *)
 	      imap_parse_string (stream,&t,reply,NIL,&text.size);
 	    imap_cache (stream,msgno,"HEADER",NIL,&text);
-	    e = stream->scache ? &stream->env : &elt->private.msg.env;
+	    e = stream->scache ? &stream->env : &elt->ccprivate.msg.env;
 	  }
 	  else if (!strcmp (prop+7,"TEXT")) {
 	    md.what = "TEXT";
@@ -3217,11 +3217,11 @@
 				/* top-level header never does mailgets */
   if (!strcmp (seg,"HEADER") || !strcmp (seg,"0") ||
       !strcmp (seg,"HEADER.FIELDS") || !strcmp (seg,"HEADER.FIELDS.NOT")) {
-    ret = &elt->private.msg.header.text;
+    ret = &elt->ccprivate.msg.header.text;
     if (text) {			/* don't do this if no text */
       if (ret->data) fs_give ((void **) &ret->data);
-      mail_free_stringlist (&elt->private.msg.lines);
-      elt->private.msg.lines = stl;
+      mail_free_stringlist (&elt->ccprivate.msg.lines);
+      elt->ccprivate.msg.lines = stl;
 				/* prevent cache reuse of .NOT */
       if ((seg[0] == 'H') && (seg[6] == '.') && (seg[13] == '.'))
 	for (stc = stl; stc; stc = stc->next) stc->text.size = 0;
@@ -3235,16 +3235,16 @@
 	imap_parse_header (stream,&stream->env,text);
       }
 				/* regular caching */
-      else imap_parse_header (stream,&elt->private.msg.env,text);
+      else imap_parse_header (stream,&elt->ccprivate.msg.env,text);
     }
   }
 				/* top level text */
   else if (!strcmp (seg,"TEXT")) {
-    ret = &elt->private.msg.text.text;
+    ret = &elt->ccprivate.msg.text.text;
     if (text && ret->data) fs_give ((void **) &ret->data);
   }
   else if (!*seg) {		/* full message */
-    ret = &elt->private.msg.full.text;
+    ret = &elt->ccprivate.msg.full.text;
     if (text && ret->data) fs_give ((void **) &ret->data);
   }
 
--- ../c-client-4.2.original/mail.c	Thu Jul 16 11:32:39 1998
+++ mail.c	Thu Aug  6 20:08:48 1998
@@ -987,8 +987,8 @@
     b = &stream->body;
   }
   else {			/* get pointers to elt envelope and body */
-    env = &elt->private.msg.env;
-    b = &elt->private.msg.body;
+    env = &elt->ccprivate.msg.env;
+    b = &elt->ccprivate.msg.body;
   }
 
   if (stream->dtb && ((body && !*b) || !*env)) {
@@ -1048,7 +1048,7 @@
 				/* better safe than sorry, save seq bits */
       for (i = 1; i <= stream->nmsgs; i++) {
 	e = mail_elt (stream,i);
-	e->private.sequence = e->sequence;
+	e->ccprivate.sequence = e->sequence;
       }
 				/* call driver to set the message */
       sprintf (sequence,"%ld",elt->msgno);
@@ -1056,7 +1056,7 @@
 				/* restore sequence bits */
       for (i = 1; i <= stream->nmsgs; i++) {
 	e = mail_elt (stream,i);
-	e->sequence = e->private.sequence;
+	e->sequence = e->ccprivate.sequence;
       }
     }
     mm_flags(stream,elt->msgno);/* notify mail program of flag change */
@@ -1088,7 +1088,7 @@
 				/* initialize message data identifier */
   INIT_GETS (md,stream,msgno,"",0,0);
 				/* is data already cached? */
-  if ((t = &(elt = mail_elt (stream,msgno))->private.msg.full.text)->data) {
+  if ((t = &(elt = mail_elt (stream,msgno))->ccprivate.msg.full.text)->data) {
     markseen (stream,elt,flags);/* mark message seen */
     return mail_fetch_text_return (&md,t,len);
   }
@@ -1149,7 +1149,7 @@
     m = b->nested.msg;		/* point to nested message */
   }
 				/* else top-level message header wanted */
-  else m = &elt->private.msg;
+  else m = &elt->ccprivate.msg;
   if (m->header.text.data && mail_match_lines (lines,m->lines,flags)) {
     if (lines) textcpy (t = &stream->text,&m->header.text);
     else t = &m->header.text;	/* in cache, and cache is valid */
@@ -1169,8 +1169,8 @@
       }
     }
     else if (b) {		/* nested body wanted? */
-      if (stream->private.search.text) {
-	rt.data = (unsigned char *) stream->private.search.text +
+      if (stream->ccprivate.search.text) {
+	rt.data = (unsigned char *) stream->ccprivate.search.text +
 	  b->nested.msg->header.offset;
 	rt.size = b->nested.msg->header.text.size;
 	t = &rt;
@@ -1179,8 +1179,8 @@
 	if ((bs.dtb->next == mail_string_next) && !lines) {
 	  rt.data = (unsigned char *) bs.curpos + b->nested.msg->header.offset;
 	  rt.size = b->nested.msg->header.text.size;
-	  if (stream->private.search.string)
-	    stream->private.search.text = bs.curpos;
+	  if (stream->ccprivate.search.string)
+	    stream->ccprivate.search.text = bs.curpos;
 	  t = &rt;		/* special hack to avoid extra copy */
 	}
 	else textcpyoffstring (t = &stream->text,&bs,
@@ -1242,7 +1242,7 @@
     flags &= ~FT_INTERNAL;	/* can't win with this set */
   }
   else {			/* top-level message text wanted */
-    p = &elt->private.msg.text;
+    p = &elt->ccprivate.msg.text;
     strcpy (tmp,"TEXT");
   }
 				/* initialize message data identifier */
@@ -1313,14 +1313,14 @@
     return "";
   }
 				/* have to get it from offset */
-  if (stream->private.search.text)
-    return stream->private.search.text + b->mime.offset;
+  if (stream->ccprivate.search.text)
+    return stream->ccprivate.search.text + b->mime.offset;
   if (!(*stream->dtb->text) (stream,msgno,&bs,flags)) {
     if (len) *len = 0;
     return "";
   }
   if (bs.dtb->next == mail_string_next) {
-    if (stream->private.search.string) stream->private.search.text = bs.curpos;
+    if (stream->ccprivate.search.string) stream->ccprivate.search.text = bs.curpos;
     return bs.curpos + b->mime.offset;
   }
   return textcpyoffstring (&stream->text,&bs,b->mime.offset,b->mime.text.size);
@@ -1385,14 +1385,14 @@
     return "";
   }
 				/* copy body from stringstruct offset */
-  if (stream->private.search.text)
-    return stream->private.search.text + p->offset;
+  if (stream->ccprivate.search.text)
+    return stream->ccprivate.search.text + p->offset;
   if (!(*stream->dtb->text) (stream,msgno,&bs,flags)) {
     if (len) *len = 0;
     return "";
   }
   if (bs.dtb->next == mail_string_next) {
-    if (stream->private.search.string) stream->private.search.text = bs.curpos;
+    if (stream->ccprivate.search.string) stream->ccprivate.search.text = bs.curpos;
     return bs.curpos + p->offset;
   }
   SETPOS (&bs,p->offset);
@@ -1437,7 +1437,7 @@
     sprintf (tmp,"%s.TEXT",section);
   }
   else {			/* else top-level message text wanted */
-    p = &elt->private.msg.text;
+    p = &elt->ccprivate.msg.text;
     strcpy (tmp,"TEXT");
   }
 
@@ -1595,7 +1595,7 @@
 
 unsigned long mail_uid (MAILSTREAM *stream,unsigned long msgno)
 {
-  unsigned long uid = mail_elt (stream,msgno)->private.uid;
+  unsigned long uid = mail_elt (stream,msgno)->ccprivate.uid;
   return uid ? uid :
     (stream->dtb && stream->dtb->uid) ? (*stream->dtb->uid) (stream,msgno) : 0;
 }
@@ -1612,7 +1612,7 @@
   unsigned long msgno;
 				/* scan cache for UID */
   for (msgno = 1; msgno <= stream->nmsgs; msgno++)
-    if (mail_elt (stream,msgno)->private.uid == uid) return msgno;
+    if (mail_elt (stream,msgno)->ccprivate.uid == uid) return msgno;
   if (stream->dtb) {		/* else get it from driver if possible */
 				/* direct way */
     if (stream->dtb->msgno) return (*stream->dtb->msgno) (stream,uid);
@@ -1890,7 +1890,7 @@
 				/* garbage collect per-message stuff */
   for (i = 1; i <= stream->nmsgs; i++) 
     if (elt = (MESSAGECACHE *) (*mailcache) (stream,i,CH_ELT))
-      mail_gc_msg (&elt->private.msg,gcflags);
+      mail_gc_msg (&elt->ccprivate.msg,gcflags);
 }
 
 
@@ -2703,18 +2703,18 @@
   if (stream->dtb->flags & DR_LOWMEM)
     mail_parameters (NIL,SET_GETS,(void *) mail_search_gets);
 				/* strings to search */
-  for (stream->private.search.string = s; st;) {
+  for (stream->ccprivate.search.string = s; st;) {
     s->text.data = st->text.data;
     s->text.size = st->text.size;
     if (st = st->next) s = s->next = mail_newstringlist ();
   }
-  stream->private.search.text = NIL;
+  stream->ccprivate.search.text = NIL;
   if (flags) {			/* want header? */
     SIZEDTEXT s,t;
     s.data = (unsigned char *) mail_fetch_header (stream,msgno,NIL,NIL,&s.size,
 						  FT_INTERNAL | FT_PEEK);
     utf8_mime2text (&s,&t);
-    ret = mail_search_string (&t,NIL,&stream->private.search.string);
+    ret = mail_search_string (&t,NIL,&stream->ccprivate.search.string);
     if (t.data != s.data) fs_give ((void **) &t.data);
   }
   if (!ret && mail_fetchstructure (stream,msgno,&body) && body)
@@ -2722,9 +2722,9 @@
 				/* restore former gets routine */
   mail_parameters (NIL,SET_GETS,(void *) omg);
 				/* clear searching */
-  for (s = stream->private.search.string; s; s = s->next) s->text.data = NIL;
-  mail_free_stringlist (&stream->private.search.string);
-  stream->private.search.text = NIL;
+  for (s = stream->ccprivate.search.string; s; s = s->next) s->text.data = NIL;
+  mail_free_stringlist (&stream->ccprivate.search.string);
+  stream->ccprivate.search.text = NIL;
   return ret;
 }
 
@@ -2753,10 +2753,10 @@
   if (flags && prefix) {	/* want to search MIME header too? */
     st.data = (unsigned char *) mail_fetch_mime (stream,msgno,sect,&st.size,
 						 FT_INTERNAL | FT_PEEK);
-    if (stream->dtb->flags & DR_LOWMEM) ret = stream->private.search.result;
+    if (stream->dtb->flags & DR_LOWMEM) ret = stream->ccprivate.search.result;
     else {
       utf8_mime2text (&st,&h);	/* make UTF-8 version of header */
-      ret = mail_search_string (&h,NIL,&stream->private.search.string);
+      ret = mail_search_string (&h,NIL,&stream->ccprivate.search.string);
       if (h.data != st.data) fs_give ((void **) &h.data);
     }
   }
@@ -2772,10 +2772,10 @@
       st.data = (unsigned char *)
 	mail_fetch_header (stream,msgno,sect,NIL,&st.size,
 			   FT_INTERNAL | FT_PEEK);
-      if (stream->dtb->flags & DR_LOWMEM) ret = stream->private.search.result;
+      if (stream->dtb->flags & DR_LOWMEM) ret = stream->ccprivate.search.result;
       else {
 	utf8_mime2text (&st,&h);/* make UTF-8 version of header */
-	ret = mail_search_string (&h,NIL,&stream->private.search.string);
+	ret = mail_search_string (&h,NIL,&stream->ccprivate.search.string);
 	if (h.data != st.data) fs_give ((void **) &h.data);
       }
     }
@@ -2788,7 +2788,7 @@
 
   case TYPETEXT:
     s = mail_fetch_body (stream,msgno,sect,&i,FT_INTERNAL | FT_PEEK);
-    if (stream->dtb->flags & DR_LOWMEM) ret = stream->private.search.result;
+    if (stream->dtb->flags & DR_LOWMEM) ret = stream->ccprivate.search.result;
     else {
       for (t = NIL,param = body->parameter; param && !t; param = param->next)
 	if (!strcmp (param->attribute,"CHARSET")) t = param->value;
@@ -2796,18 +2796,18 @@
       case ENCBASE64:
 	st.data = (unsigned char *)
 	  rfc822_base64 ((unsigned char *) s,i,&st.size);
-	ret = mail_search_string (&st,t,&stream->private.search.string);
+	ret = mail_search_string (&st,t,&stream->ccprivate.search.string);
 	fs_give ((void **) &st.data);
 	break;
       case ENCQUOTEDPRINTABLE:
 	st.data = rfc822_qprint ((unsigned char *) s,i,&st.size);
-	ret = mail_search_string (&st,t,&stream->private.search.string);
+	ret = mail_search_string (&st,t,&stream->ccprivate.search.string);
 	fs_give ((void **) &st.data);
 	break;
       default:
 	st.data = (unsigned char *) s;
 	st.size = i;
-	ret = mail_search_string (&st,t,&stream->private.search.string);
+	ret = mail_search_string (&st,t,&stream->ccprivate.search.string);
 	break;
       }
     }
@@ -2936,31 +2936,31 @@
   char tmp[MAILTMPLEN+SEARCHSLOP+1];
   SIZEDTEXT st;
 				/* better not be called unless searching */
-  if (!ms->private.search.string) {
+  if (!ms->ccprivate.search.string) {
     sprintf (tmp,"Search botch, mbx = %.80s, %s = %ld[%.80s]",ms->mailbox,
 	     (flags & FT_UID) ? "UID" : "msg",msgno,what);
     fatal (tmp);
   }
 				/* initially no match for search */
-  ms->private.search.result = NIL;
+  ms->ccprivate.search.result = NIL;
 				/* make sure buffer clear */
   memset (st.data = (unsigned char *) tmp,'\0',
 	  (size_t) MAILTMPLEN+SEARCHSLOP+1);
 				/* read first buffer */
   (*f) (stream,st.size = i = min (size,(long) MAILTMPLEN),tmp);
 				/* search for text */
-  if (mail_search_string (&st,NIL,&ms->private.search.string))
-    ms->private.search.result = T;
+  if (mail_search_string (&st,NIL,&ms->ccprivate.search.string))
+    ms->ccprivate.search.result = T;
   else if (size -= i) {		/* more to do, blat slop down */
     memmove (tmp,tmp+MAILTMPLEN-SEARCHSLOP,(size_t) SEARCHSLOP);
     do {			/* read subsequent buffers one at a time */
       (*f) (stream,i = min (size,(long) MAILTMPLEN),tmp+SEARCHSLOP);
       st.size = i + SEARCHSLOP;
-      if (mail_search_string (&st,NIL,&ms->private.search.string))
-	ms->private.search.result = T;
+      if (mail_search_string (&st,NIL,&ms->ccprivate.search.string))
+	ms->ccprivate.search.result = T;
       else memmove (tmp,tmp+MAILTMPLEN,(size_t) SEARCHSLOP);
     }
-    while ((size -= i) && !ms->private.search.result);
+    while ((size -= i) && !ms->ccprivate.search.result);
   }
   if (size) {			/* toss out everything after that */
     do (*f) (stream,i = min (size,(long) MAILTMPLEN),tmp);
@@ -3231,7 +3231,7 @@
       s->num = i;
 				/* get envelope if cached */
       if (stream->scache) env = (i == stream->msgno) ? stream->env : NIL;
-      else env = elt->private.msg.env;
+      else env = elt->ccprivate.msg.env;
       for (pg = pgm; pg; pg = pg->next) switch (pg->function) {
       case SORTARRIVAL:		/* sort by arrival date */
 	if (!s->arrival) {
@@ -4037,7 +4037,7 @@
 {
 				/* only free if exists and no sharers */
   if (*elt && !--(*elt)->lockcount) {
-    mail_gc_msg (&(*elt)->private.msg,GC_ENV | GC_TEXTS);
+    mail_gc_msg (&(*elt)->ccprivate.msg,GC_ENV | GC_TEXTS);
     fs_give ((void **) elt);
   }
   else *elt = NIL;		/* else simply drop pointer */
--- ../c-client-4.2.original/mbx.c	Wed Jul  1 19:24:13 1998
+++ mbx.c	Thu Aug  6 20:08:48 1998
@@ -758,13 +758,13 @@
 	 i <= stream->nmsgs; ) {
       elt = mbx_elt (stream,i,NIL);
 				/* note if message not at predicted location */
-      if (m = elt->private.special.offset - ppos) {
-	ppos = elt->private.special.offset;
+      if (m = elt->ccprivate.special.offset - ppos) {
+	ppos = elt->ccprivate.special.offset;
 	reclaimed += m;		/* note reclaimed message space */
 	delta += m;		/* and as expunge delta  */
       }
 				/* number of bytes to smash or preserve */
-      ppos += (k = elt->private.special.text.size + elt->rfc822_size);
+      ppos += (k = elt->ccprivate.special.text.size + elt->rfc822_size);
       if (elt->deleted) {	/* if deleted */
 	delta += k;		/* number of bytes to delete */
 	mail_expunged(stream,i);/* notify upper levels */
@@ -773,7 +773,7 @@
       else if (i++ && delta) {	/* preserved message */
 	if (elt->recent) ++recent;
 				/* first byte to preserve */
-	j = elt->private.special.offset;
+	j = elt->ccprivate.special.offset;
 	do {			/* read from source position */
 	  m = min (k,LOCAL->buflen);
 	  lseek (LOCAL->fd,j,L_SET);
@@ -789,10 +789,10 @@
 	  j += m;		/* next chunk, perhaps */
 	} while (k -= m);	/* until done */
 				/* note the new address of this text */
-	elt->private.special.offset -= delta;
+	elt->ccprivate.special.offset -= delta;
       }
 				/* preserved but no deleted messages yet */
-      else pos = elt->private.special.offset + k;
+      else pos = elt->ccprivate.special.offset + k;
     }
 				/* deltaed file size match position? */
     if (m = (LOCAL->filesize -= delta) - pos) {
@@ -878,8 +878,8 @@
 				/* for each requested message */
   for (i = 1; ret && (i <= stream->nmsgs); i++) 
     if ((elt = mail_elt (stream,i))->sequence) {
-      lseek (LOCAL->fd,elt->private.special.offset +
-	     elt->private.special.text.size,L_SET);
+      lseek (LOCAL->fd,elt->ccprivate.special.offset +
+	     elt->ccprivate.special.text.size,L_SET);
       mail_date(LOCAL->buf,elt);/* build target header */
       sprintf (LOCAL->buf+strlen(LOCAL->buf),",%lu;%08lx%04x-00000000\015\012",
 	       elt->rfc822_size,elt->user_flags,(fSEEN * elt->seen) +
@@ -1148,7 +1148,7 @@
     if ((m = strtoul (t+13,NIL,16)) &&
 	((m <= lastuid) || (m > stream->uid_last))) {
       sprintf (tmp,"Invalid UID %08x in message %lu, rebuilding UIDs",
-		 elt->private.uid,elt->msgno);
+		 elt->ccprivate.uid,elt->msgno);
       mm_log (tmp,WARN);
       m = 0;			/* lose this UID */
 				/* restart UID validity and last UID */
@@ -1173,11 +1173,11 @@
 	return NIL;
       }
 				/* note file offset of header */
-      elt->private.special.offset = curpos;
+      elt->ccprivate.special.offset = curpos;
 				/* and internal header size */
-      elt->private.special.text.size = i;
+      elt->ccprivate.special.text.size = i;
 				/* header size not known yet */
-      elt->private.msg.header.text.size = 0;
+      elt->ccprivate.msg.header.text.size = 0;
       elt->rfc822_size = j;	/* note message size */
 				/* calculate system flags */
       if (k & fSEEN) elt->seen = T;
@@ -1188,15 +1188,15 @@
       t[8] = '\0';		/* get user flags value */
       elt->user_flags = strtoul (t,NIL,16);
 				/* UID already assigned? */
-      if (!(elt->private.uid = m)) {
+      if (!(elt->ccprivate.uid = m)) {
 	elt->recent = T;	/* no, mark as recent */
 	++recent;		/* count up a new recent message */
 				/* assign new UID */
-	elt->private.uid = ++stream->uid_last;
+	elt->ccprivate.uid = ++stream->uid_last;
 	mbx_update_status (stream,elt->msgno,NIL);
       }
 				/* update last parsed UID */
-      lastuid = elt->private.uid;
+      lastuid = elt->ccprivate.uid;
     }
     curpos += i + j;		/* update position */
   }
@@ -1259,8 +1259,8 @@
 				/* noop if readonly and have valid flags */
   if (stream->rdonly && elt->valid) return NIL;
 				/* set the seek pointer */
-  lseek (LOCAL->fd,(off_t) elt->private.special.offset +
-	 elt->private.special.text.size - 23,L_SET);
+  lseek (LOCAL->fd,(off_t) elt->ccprivate.special.offset +
+	 elt->ccprivate.special.text.size - 23,L_SET);
 				/* read the new flags */
   if (read (LOCAL->fd,LOCAL->buf,12) < 0) {
     sprintf (LOCAL->buf,"Unable to read new status: %s",strerror (errno));
@@ -1326,8 +1326,8 @@
 				/* want to expunge message? */
     if (elt->deleted && (flags & mus_EXPUNGE)) expflag = fEXPUNGED;
     else {			/* seek to system flags */
-      lseek (LOCAL->fd,(off_t) elt->private.special.offset +
-	     elt->private.special.text.size - 15,L_SET);
+      lseek (LOCAL->fd,(off_t) elt->ccprivate.special.offset +
+	     elt->ccprivate.special.text.size - 15,L_SET);
 				/* read the current system flags */
       if (read (LOCAL->fd,LOCAL->buf,4) < 0) {
 	sprintf (LOCAL->buf,"Unable to read system flags: %s",
@@ -1342,10 +1342,10 @@
     sprintf (LOCAL->buf,"%08lx%04x-%08lx",elt->user_flags,
 	     expflag + (fSEEN * elt->seen) + (fDELETED * elt->deleted) +
 	     (fFLAGGED * elt->flagged) + (fANSWERED * elt->answered) +
-	     (fDRAFT * elt->draft),elt->private.uid);
+	     (fDRAFT * elt->draft),elt->ccprivate.uid);
     while (T) {			/* get to that place in the file */
-      lseek (LOCAL->fd,(off_t) elt->private.special.offset +
-	     elt->private.special.text.size - 23,L_SET);
+      lseek (LOCAL->fd,(off_t) elt->ccprivate.special.offset +
+	     elt->ccprivate.special.text.size - 23,L_SET);
 				/* write new flags and UID */
       if (write (LOCAL->fd,LOCAL->buf,21) > 0) break;
       mm_notify (stream,strerror (errno),WARN);
@@ -1374,10 +1374,10 @@
   int q = 0;
   char *s,tmp[MAILTMPLEN];
   MESSAGECACHE *elt = mbx_elt (stream,msgno,NIL);
-  unsigned long ret = elt->private.special.offset +
-    elt->private.special.text.size;
+  unsigned long ret = elt->ccprivate.special.offset +
+    elt->ccprivate.special.text.size;
 				/* is header size known? */
-  if (!(*size = elt->private.msg.header.text.size)) {
+  if (!(*size = elt->ccprivate.msg.header.text.size)) {
     lseek (LOCAL->fd,ret,L_SET);/* get to header position */
 				/* search message for CRLF CRLF */
     for (siz = 1; siz <= elt->rfc822_size; siz++) {
@@ -1399,7 +1399,7 @@
       case 3:			/* fourth character */
 	if (*s++ == '\012') {	/* have the sequence? */
 				/* yes, note for later */
-	  elt->private.msg.header.text.size = *size = siz;
+	  elt->ccprivate.msg.header.text.size = *size = siz;
 	  return ret;
 	}
 	q = 0;			/* lost... */
@@ -1407,7 +1407,7 @@
       }
     }
 				/* header consumes entire message */
-    elt->private.msg.header.text.size = *size = elt->rfc822_size;
+    elt->ccprivate.msg.header.text.size = *size = elt->rfc822_size;
   }
   return ret;
 }
--- ../c-client-4.2.original/mh.c	Tue Jul 14 01:53:48 1998
+++ mh.c	Thu Aug  6 20:08:48 1998
@@ -542,9 +542,9 @@
   *length = 0;			/* default to empty */
   if (flags & FT_UID) return "";/* UID call "impossible" */
   elt = mail_elt (stream,msgno);/* get elt */
-  if (!elt->private.msg.header.text.data) {
+  if (!elt->ccprivate.msg.header.text.data) {
 				/* build message file name */
-    sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->private.uid);
+    sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->ccprivate.uid);
     if ((fd = open (LOCAL->buf,O_RDONLY,NIL)) < 0) return "";
     fstat (fd,&sbuf);		/* get size of message */
 				/* make plausible IMAPish date string */
@@ -569,15 +569,15 @@
 				/* number of header bytes */
     hdrsize = (*t ? ++t : t) - LOCAL->buf;
     elt->rfc822_size =		/* size of entire message in CRLF form */
-      (elt->private.msg.header.text.size =
-       strcrlfcpy ((char **) &elt->private.msg.header.text.data,&i,LOCAL->buf,
+      (elt->ccprivate.msg.header.text.size =
+       strcrlfcpy ((char **) &elt->ccprivate.msg.header.text.data,&i,LOCAL->buf,
 		   hdrsize)) +
-	 (elt->private.msg.text.text.size =
-	  strcrlfcpy ((char **) &elt->private.msg.text.text.data,&i,t,
+	 (elt->ccprivate.msg.text.text.size =
+	  strcrlfcpy ((char **) &elt->ccprivate.msg.text.text.data,&i,t,
 		      sbuf.st_size - hdrsize));
   }
-  *length = elt->private.msg.header.text.size;
-  return (char *) elt->private.msg.header.text.data;
+  *length = elt->ccprivate.msg.header.text.size;
+  return (char *) elt->ccprivate.msg.header.text.data;
 }
 
 /* MH mail fetch message text (body only)
@@ -596,17 +596,17 @@
   if (flags & FT_UID) return NIL;
   elt = mail_elt (stream,msgno);/* get elt */
 				/* snarf message if don't have it yet */
-  if (!elt->private.msg.text.text.data) {
+  if (!elt->ccprivate.msg.text.text.data) {
     mh_header (stream,msgno,&i,flags);
-    if (!elt->private.msg.text.text.data) return NIL;
+    if (!elt->ccprivate.msg.text.text.data) return NIL;
   }
   if (!(flags & FT_PEEK)) {	/* mark as seen */
     mail_elt (stream,msgno)->seen = T;
     mm_flags (stream,msgno);
   }
-  if (!elt->private.msg.text.text.data) return NIL;
-  INIT (bs,mail_string,elt->private.msg.text.text.data,
-	elt->private.msg.text.text.size);
+  if (!elt->ccprivate.msg.text.text.data) return NIL;
+  INIT (bs,mail_string,elt->ccprivate.msg.text.text.data,
+	elt->ccprivate.msg.text.text.size);
   return T;
 }
 
@@ -644,7 +644,7 @@
 				/* if newly seen, add to list */
       if ((j = atoi (names[i]->d_name)) > old) {
 	mail_exists (stream,++nmsgs);
-	stream->uid_last = (elt = mail_elt (stream,nmsgs))->private.uid = j;
+	stream->uid_last = (elt = mail_elt (stream,nmsgs))->ccprivate.uid = j;
 	elt->valid = T;		/* note valid flags */
 	if (old) {		/* other than the first pass? */
 	  elt->recent = T;	/* yup, mark as recent */
@@ -684,7 +684,7 @@
 				/* swell the cache */
 	  mail_exists (stream,++nmsgs);
 	  stream->uid_last =	/* create new elt, note its file number */
-	    (elt = mail_elt (stream,nmsgs))->private.uid = old;
+	    (elt = mail_elt (stream,nmsgs))->ccprivate.uid = old;
 	  recent++;		/* bump recent count */
 				/* set up initial flags and date */
 	  elt->valid = elt->recent = T;
@@ -755,14 +755,14 @@
   while (i <= stream->nmsgs) {	/* for each message */
 				/* if deleted, need to trash it */
     if ((elt = mail_elt (stream,i))->deleted) {
-      sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->private.uid);
+      sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->ccprivate.uid);
       if (unlink (LOCAL->buf)) {/* try to delete the message */
 	sprintf (LOCAL->buf,"Expunge of message %ld failed, aborted: %s",i,
 		 strerror (errno));
 	mm_log (LOCAL->buf,(long) NIL);
 	break;
       }
-      mail_gc_msg (&elt->private.msg,GC_ENV | GC_TEXTS);
+      mail_gc_msg (&elt->ccprivate.msg,GC_ENV | GC_TEXTS);
       if (elt->recent) --recent;/* if recent, note one less recent message */
       mail_expunged (stream,i);	/* notify upper levels */
       n++;			/* count up one more expunged message */
@@ -801,7 +801,7 @@
       mail_sequence (stream,sequence))
     for (i = 1; i <= stream->nmsgs; i++) 
       if ((elt = mail_elt (stream,i))->sequence) {
-	sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->private.uid);
+	sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->ccprivate.uid);
 	if ((fd = open (LOCAL->buf,O_RDONLY,NIL)) < 0) return NIL;
 	fstat (fd,&sbuf);	/* get size of message */
 	if (!elt->day) {	/* make plausible IMAPish date string */
--- ../c-client-4.2.original/mmdf.c	Thu Jul 16 02:50:59 1998
+++ mmdf.c	Thu Aug  6 20:08:48 1998
@@ -486,26 +486,26 @@
 					 (unsigned char *) "X-UID"));
   }
 				/* go to header position */
-  lseek (LOCAL->fd,elt->private.special.offset +
-	 elt->private.msg.header.offset,L_SET);
+  lseek (LOCAL->fd,elt->ccprivate.special.offset +
+	 elt->ccprivate.msg.header.offset,L_SET);
   if (flags & FT_INTERNAL) {	/* initial data OK? */
-    if (elt->private.msg.header.text.size > LOCAL->buflen) {
+    if (elt->ccprivate.msg.header.text.size > LOCAL->buflen) {
       fs_give ((void **) &LOCAL->buf);
       LOCAL->buf = (char *) fs_get ((LOCAL->buflen =
-				     elt->private.msg.header.text.size) + 1);
+				     elt->ccprivate.msg.header.text.size) + 1);
     }
 				/* read message */
-    read (LOCAL->fd,LOCAL->buf,elt->private.msg.header.text.size);
+    read (LOCAL->fd,LOCAL->buf,elt->ccprivate.msg.header.text.size);
 				/* got text, tie off string */
-    LOCAL->buf[*length = elt->private.msg.header.text.size] = '\0';
+    LOCAL->buf[*length = elt->ccprivate.msg.header.text.size] = '\0';
   }
   else {			/* need to make a CRLF version */
-    read (LOCAL->fd,s = (char *) fs_get (elt->private.msg.header.text.size+1),
-	  elt->private.msg.header.text.size);
+    read (LOCAL->fd,s = (char *) fs_get (elt->ccprivate.msg.header.text.size+1),
+	  elt->ccprivate.msg.header.text.size);
 				/* tie off string, and convert to CRLF */
-    s[elt->private.msg.header.text.size] = '\0';
+    s[elt->ccprivate.msg.header.text.size] = '\0';
     *length = strcrlfcpy (&LOCAL->buf,&LOCAL->buflen,s,
-			  elt->private.msg.header.text.size);
+			  elt->ccprivate.msg.header.text.size);
     fs_give ((void **) &s);	/* free readin buffer */
   }
   *length = mail_filter (LOCAL->buf,*length,mmdf_hlines,FT_NOT);
@@ -553,18 +553,18 @@
   STRING bs;
   char *s,tmp[CHUNK];
 				/* go to text position */
-  lseek (LOCAL->fd,elt->private.special.offset +
-	 elt->private.msg.text.offset,L_SET);
+  lseek (LOCAL->fd,elt->ccprivate.special.offset +
+	 elt->ccprivate.msg.text.offset,L_SET);
   if (flags & FT_INTERNAL) {	/* initial data OK? */
-    if (elt->private.msg.text.text.size > LOCAL->buflen) {
+    if (elt->ccprivate.msg.text.text.size > LOCAL->buflen) {
       fs_give ((void **) &LOCAL->buf);
       LOCAL->buf = (char *) fs_get ((LOCAL->buflen =
-				     elt->private.msg.text.text.size) + 1);
+				     elt->ccprivate.msg.text.text.size) + 1);
     }
 				/* read message */
-    read (LOCAL->fd,LOCAL->buf,elt->private.msg.text.text.size);
+    read (LOCAL->fd,LOCAL->buf,elt->ccprivate.msg.text.text.size);
 				/* got text, tie off string */
-    LOCAL->buf[*length = elt->private.msg.text.text.size] = '\0';
+    LOCAL->buf[*length = elt->ccprivate.msg.text.text.size] = '\0';
   }
   else {			/* need to make a CRLF version */
     if (elt->rfc822_size > LOCAL->buflen) {
@@ -573,10 +573,10 @@
       LOCAL->buf = (char *) fs_get ((LOCAL->buflen = elt->rfc822_size) + 1);
     }
     d.fd = LOCAL->fd;		/* yes, set up file descriptor */
-    d.pos = elt->private.special.offset + elt->private.msg.text.offset;
+    d.pos = elt->ccprivate.special.offset + elt->ccprivate.msg.text.offset;
     d.chunk = tmp;		/* initial buffer chunk */
     d.chunksize = CHUNK;	/* file chunk size */
-    INIT (&bs,fd_string,&d,elt->private.msg.text.text.size);
+    INIT (&bs,fd_string,&d,elt->ccprivate.msg.text.text.size);
     for (s = LOCAL->buf; SIZE (&bs);) switch (CHR (&bs)) {
     case '\015':		/* carriage return seen */
       *s++ = SNX (&bs);		/* copy it and any succeeding LF */
@@ -749,9 +749,9 @@
 				/* write all requested messages to mailbox */
   for (i = 1; ret && (i <= stream->nmsgs); i++)
     if ((elt = mail_elt (stream,i))->sequence) {
-      lseek (LOCAL->fd,elt->private.special.offset,L_SET);
-      read (LOCAL->fd,LOCAL->buf,elt->private.special.text.size);
-      if (write (fd,LOCAL->buf,elt->private.special.text.size) < 0) ret = NIL;
+      lseek (LOCAL->fd,elt->ccprivate.special.offset,L_SET);
+      read (LOCAL->fd,LOCAL->buf,elt->ccprivate.special.text.size);
+      if (write (fd,LOCAL->buf,elt->ccprivate.special.text.size) < 0) ret = NIL;
       else {			/* internal header succeeded */
 	s = mmdf_header (stream,i,&j,FT_INTERNAL);
 				/* header size, sans trailing newline */
@@ -1143,15 +1143,15 @@
 	recent++;		/* assume recent by default */
 	elt->recent = T;
 				/* note position/size of internal header */
-	elt->private.special.offset = j;
-	elt->private.special.text.size = i;
+	elt->ccprivate.special.offset = j;
+	elt->ccprivate.special.text.size = i;
 
 	s = mmdf_mbxline (stream,&bs,&i);
 	ti = 0;			/* assume not a valid date */
 	if (i) VALID (s,t,ti,zn);
 	if (ti) {		/* generate plausible IMAPish date string */
 				/* this is also part of header */
-	  elt->private.special.text.size += i;
+	  elt->ccprivate.special.text.size += i;
 	  date[2] = date[6] = date[20] = '-'; date[11] = ' ';
 	  date[14] = date[17] = ':';
 				/* dd */
@@ -1195,14 +1195,14 @@
 	  t = NIL;		/* suppress line read */
 	}
 				/* header starts here */
-	elt->private.msg.header.offset = elt->private.special.text.size;
+	elt->ccprivate.msg.header.offset = elt->ccprivate.special.text.size;
 
 	do {			/* look for message body */
 	  if (t) s = t = mmdf_mbxline (stream,&bs,&i);
 	  else t = s;		/* this line read was suppressed */
 	  if (ISMMDF (s)) break;
 				/* this line is part of header */
-	  elt->private.msg.header.text.size += i;
+	  elt->ccprivate.msg.header.text.size += i;
 	  if (i) switch (*s) {	/* check header lines */
 	  case 'X':		/* possible X-???: line */
 	    if (s[1] == '-') {	/* must be immediately followed by hyphen */
@@ -1312,9 +1312,9 @@
 				/* flush remainder of line */
 		  while (*s != '\n') s++;
 				/* make sure not duplicated */
-		  if (elt->private.uid)
+		  if (elt->ccprivate.uid)
 		    sprintf (tmp,"Message %lu UID %lu already has UID %lu",
-			     elt->msgno - 1,j,elt->private.uid);
+			     elt->msgno - 1,j,elt->ccprivate.uid);
 				/* make sure UID doesn't go backwards */
 		  else if (j <= prevuid)
 		    sprintf (tmp,"Message %lu UID %lu less than %lu",
@@ -1324,13 +1324,13 @@
 		    sprintf (tmp,"Message %lu UID %lu greater than last %lu",
 			     elt->msgno - 1,j,stream->uid_last);
 		  else {	/* normal UID case */
-		    prevuid = elt->private.uid = j;
+		    prevuid = elt->ccprivate.uid = j;
 		    break;		/* exit this cruft */
 		  }
 		  mm_log (tmp,WARN);
 				/* invalidate UID validity */
 		  stream->uid_validity = 0;
-		  elt->private.uid = 0;
+		  elt->ccprivate.uid = 0;
 		}
 		break;
 	      }
@@ -1375,12 +1375,12 @@
 	  }
 	} while (i && (*t != '\n'));
 				/* assign a UID if none found */
-	if (((nmsgs > 1) || !pseudoseen) && !elt->private.uid)
-	  prevuid = elt->private.uid = ++stream->uid_last;
+	if (((nmsgs > 1) || !pseudoseen) && !elt->ccprivate.uid)
+	  prevuid = elt->ccprivate.uid = ++stream->uid_last;
 
 				/* note location of text */
-	elt->private.msg.text.offset =
-	  (LOCAL->filesize + GETPOS (&bs)) - elt->private.special.offset;
+	elt->ccprivate.msg.text.offset =
+	  (LOCAL->filesize + GETPOS (&bs)) - elt->ccprivate.special.offset;
 	k = 0;			/* no previous line size yet */
 				/* note current position */
 	j = LOCAL->filesize + GETPOS (&bs);
@@ -1395,8 +1395,8 @@
 	    }
 	  }
 	} while (i);		/* until found a header */
-	elt->private.msg.text.text.size = j -
-	  (elt->private.special.offset + elt->private.msg.text.offset);
+	elt->ccprivate.msg.text.text.size = j -
+	  (elt->ccprivate.special.offset + elt->ccprivate.msg.text.offset);
 	if (i) {		/* get next header line */
 				/* remember first internal header position */
 	  j = LOCAL->filesize + GETPOS (&bs);
@@ -1561,7 +1561,7 @@
       char stack[64];
       char *p = stack;
 				/* push UID digits on the stack */
-      unsigned long n = elt->private.uid;
+      unsigned long n = elt->ccprivate.uid;
       do *p++ = (char) (n % 10) + '0';
       while (n /= 10);
       *s++ = 'X'; *s++ = '-'; *s++ = 'U'; *s++ = 'I'; *s++ = 'D'; *s++ = ':';
@@ -1641,13 +1641,13 @@
       ++*nexp;			/* count up one more expunged message */
     }
     else {			/* update file pointers from kludgey places */
-      elt->private.special.offset = elt->private.msg.full.offset;
-      elt->private.msg.text.offset = elt->private.msg.full.text.size;
+      elt->ccprivate.special.offset = elt->ccprivate.msg.full.offset;
+      elt->ccprivate.msg.text.offset = elt->ccprivate.msg.full.text.size;
 				/* in case header grew */
-      elt->private.msg.header.text.size = elt->private.msg.text.offset -
-	elt->private.msg.header.offset;
+      elt->ccprivate.msg.header.text.size = elt->ccprivate.msg.text.offset -
+	elt->ccprivate.msg.header.offset;
 				/* stomp on these two kludges */
-      elt->private.msg.full.offset = elt->private.msg.full.text.size = 0;
+      elt->ccprivate.msg.full.offset = elt->ccprivate.msg.full.text.size = 0;
       i++;			/* preserved message */
     }
   }
@@ -1701,11 +1701,11 @@
   char *s;
   unsigned long i;
 				/* (kludge alert) note new message offset */
-  elt->private.msg.full.offset = *size;
+  elt->ccprivate.msg.full.offset = *size;
 				/* internal header */
-  lseek (LOCAL->fd,elt->private.special.offset,L_SET);
-  read (LOCAL->fd,LOCAL->buf,elt->private.special.text.size);
-  if (mmdf_fwrite (f,LOCAL->buf,elt->private.special.text.size,size)) {
+  lseek (LOCAL->fd,elt->ccprivate.special.offset,L_SET);
+  read (LOCAL->fd,LOCAL->buf,elt->ccprivate.special.text.size);
+  if (mmdf_fwrite (f,LOCAL->buf,elt->ccprivate.special.text.size,size)) {
 				/* get header */
     s = mmdf_header (stream,elt->msgno,&i,FT_INTERNAL);
 				/* header size, sans trailing newline */
@@ -1714,7 +1714,7 @@
     if (mmdf_fwrite (f,s,i,size) &&
 	mmdf_fwrite (f,LOCAL->buf,mmdf_xstatus(stream,LOCAL->buf,elt,T),size)){
 				/* (kludge alert) note new text offset */
-      elt->private.msg.full.text.size = *size - elt->private.msg.full.offset;
+      elt->ccprivate.msg.full.text.size = *size - elt->ccprivate.msg.full.offset;
 				/* get text */
       s = mmdf_text_work (stream,elt,&i,FT_INTERNAL);
 				/* write text and trailing newline */
--- ../c-client-4.2.original/mtx.c	Tue Jul 14 01:53:29 1998
+++ mtx.c	Thu Aug  6 20:08:48 1998
@@ -706,7 +706,7 @@
   while (i <= stream->nmsgs) {	/* for each message */
     elt = mtx_elt (stream,i);	/* get cache element */
 				/* number of bytes to smash or preserve */
-    k = elt->private.special.text.size + elt->rfc822_size;
+    k = elt->ccprivate.special.text.size + elt->rfc822_size;
     if (elt->deleted) {		/* if deleted */
       if (elt->recent) --recent;/* if recent, note one less recent message */
       delta += k;		/* number of bytes to delete */
@@ -715,7 +715,7 @@
     }
     else if (i++ && delta) {	/* preserved message */
 				/* first byte to preserve */
-      j = elt->private.special.offset;
+      j = elt->ccprivate.special.offset;
       do {			/* read from source position */
 	m = min (k,LOCAL->buflen);
 	lseek (LOCAL->fd,j,L_SET);
@@ -732,10 +732,10 @@
 	j += m;			/* next chunk, perhaps */
       } while (k -= m);		/* until done */
 				/* note the new address of this text */
-      elt->private.special.offset -= delta;
+      elt->ccprivate.special.offset -= delta;
     }
 				/* preserved but no deleted messages */
-    else pos = elt->private.special.offset + k;
+    else pos = elt->ccprivate.special.offset + k;
   }
   if (n) {			/* truncate file after last message */
     if (pos != (LOCAL->filesize -= delta)) {
@@ -818,9 +818,9 @@
 				/* for each requested message */
   for (i = 1; ret && (i <= stream->nmsgs); i++) 
     if ((elt = mail_elt (stream,i))->sequence) {
-      lseek (LOCAL->fd,elt->private.special.offset,L_SET);
+      lseek (LOCAL->fd,elt->ccprivate.special.offset,L_SET);
 				/* number of bytes to copy */
-      k = elt->private.special.text.size + elt->rfc822_size;
+      k = elt->ccprivate.special.text.size + elt->rfc822_size;
       do {			/* read from source position */
 	j = min (k,LOCAL->buflen);
 	read (LOCAL->fd,LOCAL->buf,j);
@@ -1028,13 +1028,13 @@
     mail_exists (stream,++nmsgs);
 				/* instantiate an elt for this message */
     (elt = mail_elt (stream,nmsgs))->valid = T;
-    elt->private.uid = ++stream->uid_last;
+    elt->ccprivate.uid = ++stream->uid_last;
 				/* note file offset of header */
-    elt->private.special.offset = curpos;
+    elt->ccprivate.special.offset = curpos;
 				/* in case error */
-    elt->private.special.text.size = 0;
+    elt->ccprivate.special.text.size = 0;
 				/* header size not known yet */
-    elt->private.msg.header.text.size = 0;
+    elt->ccprivate.msg.header.text.size = 0;
 				/* parse the header components */
     if (mail_parse_date (elt,LOCAL->buf) &&
 	(elt->rfc822_size = strtoul (x = s,&s,10)) && (!(s && *s)) &&
@@ -1042,10 +1042,10 @@
 	isdigit (t[3]) && isdigit (t[4]) && isdigit (t[5]) &&
 	isdigit (t[6]) && isdigit (t[7]) && isdigit (t[8]) &&
 	isdigit (t[9]) && isdigit (t[10]) && isdigit (t[11]) && !t[12])
-      elt->private.special.text.size = i;
-    if (elt->private.special.text.size) elt->private.msg.header.offset =
-      elt->private.msg.text.offset = 
-	elt->private.special.offset + elt->private.special.text.size;
+      elt->ccprivate.special.text.size = i;
+    if (elt->ccprivate.special.text.size) elt->ccprivate.msg.header.offset =
+      elt->ccprivate.msg.text.offset = 
+	elt->ccprivate.special.offset + elt->ccprivate.special.text.size;
     else {			/* oops */
       sprintf (tmp,"Unable to parse internal header elements at %ld: %s,%s;%s",
 	       curpos,LOCAL->buf,x,t);
@@ -1056,7 +1056,7 @@
 				/* make sure didn't run off end of file */
     if ((curpos += (elt->rfc822_size + i)) > sbuf.st_size) {
       sprintf (tmp,"Last message (at %lu) runs past end of file (%lu > %lu)",
-	       elt->private.special.offset,curpos,sbuf.st_size);
+	       elt->ccprivate.special.offset,curpos,sbuf.st_size);
       mm_log (tmp,ERROR);
       mtx_close (stream,NIL);
       return NIL;
@@ -1131,8 +1131,8 @@
 				/* noop if readonly and have valid flags */
   if (stream->rdonly && elt->valid) return;
 				/* set the seek pointer */
-  lseek (LOCAL->fd,(off_t) elt->private.special.offset +
-	 elt->private.special.text.size - 14,L_SET);
+  lseek (LOCAL->fd,(off_t) elt->ccprivate.special.offset +
+	 elt->ccprivate.special.text.size - 14,L_SET);
 				/* read the new flags */
   if (read (LOCAL->fd,LOCAL->buf,12) < 0) {
     sprintf (LOCAL->buf,"Unable to read new status: %s",strerror (errno));
@@ -1174,8 +1174,8 @@
 	     (fFLAGGED * elt->flagged) + (fANSWERED * elt->answered) +
 	     (fDRAFT * elt->draft));
 				/* get to that place in the file */
-    lseek (LOCAL->fd,(off_t) elt->private.special.offset +
-	   elt->private.special.text.size - 14,L_SET);
+    lseek (LOCAL->fd,(off_t) elt->ccprivate.special.offset +
+	   elt->ccprivate.special.text.size - 14,L_SET);
 				/* write new flags */
     write (LOCAL->fd,LOCAL->buf,12);
     if (syncflag) {		/* sync if requested */
@@ -1202,9 +1202,9 @@
   char *s,tmp[MAILTMPLEN];
   MESSAGECACHE *elt = mtx_elt (stream,msgno);
 				/* is header size known? */
-  if (!(*size = elt->private.msg.header.text.size)) {
+  if (!(*size = elt->ccprivate.msg.header.text.size)) {
 				/* get to header position */
-    lseek (LOCAL->fd,elt->private.msg.header.offset,L_SET);
+    lseek (LOCAL->fd,elt->ccprivate.msg.header.offset,L_SET);
 				/* search message for CRLF CRLF */
     for (siz = 1; siz <= elt->rfc822_size; siz++) {
 				/* read another buffer as necessary */
@@ -1212,7 +1212,7 @@
 	if (read (LOCAL->fd,s = tmp,
 		  i = min (elt->rfc822_size - siz,(long) MAILTMPLEN)) < 0)
 				/* I/O error? */
-	  return elt->private.msg.header.offset;
+	  return elt->ccprivate.msg.header.offset;
       switch (q) {		/* sniff at buffer */
       case 0:			/* first character */
 	q = (*s++ == '\015') ? 1 : 0;
@@ -1226,15 +1226,15 @@
       case 3:			/* fourth character */
 	if (*s++ == '\012') {	/* have the sequence? */
 				/* yes, note for later */
-	  elt->private.msg.header.text.size = *size = siz;
-	  return elt->private.msg.header.offset;
+	  elt->ccprivate.msg.header.text.size = *size = siz;
+	  return elt->ccprivate.msg.header.offset;
 	}
 	q = 0;			/* lost... */
 	break;
       }
     }
 				/* header consumes entire message */
-    elt->private.msg.header.text.size = *size = elt->rfc822_size;
+    elt->ccprivate.msg.header.text.size = *size = elt->rfc822_size;
   }
-  return elt->private.msg.header.offset;
+  return elt->ccprivate.msg.header.offset;
 }
--- ../c-client-4.2.original/mx.c	Tue Dec 30 04:45:49 1997
+++ mx.c	Thu Aug  6 20:08:48 1998
@@ -424,7 +424,7 @@
   struct stat sbuf;
   struct tm *tm;
 				/* build message file name */
-  sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->private.uid);
+  sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->ccprivate.uid);
   if (!elt->rfc822_size) {	/* have size yet? */
     stat (LOCAL->buf,&sbuf);	/* get size of message */
 				/* make plausible IMAPish date string */
@@ -456,7 +456,7 @@
   *length = 0;			/* default to empty */
   if (flags & FT_UID) return "";/* UID call "impossible" */
   elt = mail_elt (stream,msgno);/* get elt */
-  if (!elt->private.msg.header.text.data) {
+  if (!elt->ccprivate.msg.header.text.data) {
     if ((fd = open (mx_fast_work (stream,elt),O_RDONLY,NIL)) < 0) return "";
 				/* is buffer big enough? */
     if (elt->rfc822_size > LOCAL->buflen) {
@@ -476,11 +476,11 @@
 		(LOCAL->buf[i - 2] == '\015') &&
 		(LOCAL->buf[i - 1] == '\012')); i++);
 				/* copy header */
-    cpytxt (&elt->private.msg.header.text,LOCAL->buf,i);
-    cpytxt (&elt->private.msg.text.text,LOCAL->buf+i,elt->rfc822_size - i);
+    cpytxt (&elt->ccprivate.msg.header.text,LOCAL->buf,i);
+    cpytxt (&elt->ccprivate.msg.text.text,LOCAL->buf+i,elt->rfc822_size - i);
   }
-  *length = elt->private.msg.header.text.size;
-  return (char *) elt->private.msg.header.text.data;
+  *length = elt->ccprivate.msg.header.text.size;
+  return (char *) elt->ccprivate.msg.header.text.data;
 }
 
 /* MX mail fetch message text (body only)
@@ -499,9 +499,9 @@
   if (flags & FT_UID) return NIL;
   elt = mail_elt (stream,msgno);
 				/* snarf message if don't have it yet */
-  if (!elt->private.msg.text.text.data) {
+  if (!elt->ccprivate.msg.text.text.data) {
     mx_header (stream,msgno,&i,flags);
-    if (!elt->private.msg.text.text.data) return NIL;
+    if (!elt->ccprivate.msg.text.text.data) return NIL;
   }
 				/* mark as seen */
   if (!(flags & FT_PEEK) && mx_lockindex (stream)) {
@@ -509,8 +509,8 @@
     mx_unlockindex (stream);
     mm_flags (stream,msgno);
   }
-  INIT (bs,mail_string,elt->private.msg.text.text.data,
-	elt->private.msg.text.text.size);
+  INIT (bs,mail_string,elt->ccprivate.msg.text.text.data,
+	elt->ccprivate.msg.text.text.size);
   return T;
 }
 
@@ -568,7 +568,7 @@
       if ((j = atoi (names[i]->d_name)) > old) {
 				/* swell the cache */
 	mail_exists (stream,++nmsgs);
-	stream->uid_last = (elt = mail_elt (stream,nmsgs))->private.uid = j;
+	stream->uid_last = (elt = mail_elt (stream,nmsgs))->ccprivate.uid = j;
 	elt->valid = T;		/* note valid flags */
 	if (old) {		/* other than the first pass? */
 	  elt->recent = T;	/* yup, mark as recent */
@@ -609,7 +609,7 @@
 				/* swell the cache */
 	  mail_exists (stream,++nmsgs);
 	  stream->uid_last =	/* create new elt, note its file number */
-	    (elt = mail_elt (stream,nmsgs))->private.uid = old;
+	    (elt = mail_elt (stream,nmsgs))->ccprivate.uid = old;
 	  recent++;		/* bump recent count */
 				/* set up initial flags and date */
 	  elt->valid = elt->recent = T;
@@ -676,14 +676,14 @@
     while (i <= stream->nmsgs) {/* for each message */
 				/* if deleted, need to trash it */
       if ((elt = mail_elt (stream,i))->deleted) {
-	sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->private.uid);
+	sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->ccprivate.uid);
 	if (unlink (LOCAL->buf)) {/* try to delete the message */
 	  sprintf (LOCAL->buf,"Expunge of message %ld failed, aborted: %s",i,
 		   strerror (errno));
 	  mm_log (LOCAL->buf,(long) NIL);
 	  break;
 	}
-	mail_gc_msg (&elt->private.msg,GC_ENV | GC_TEXTS);
+	mail_gc_msg (&elt->ccprivate.msg,GC_ENV | GC_TEXTS);
 	if(elt->recent)--recent;/* if recent, note one less recent message */
 	mail_expunged(stream,i);/* notify upper levels */
 	n++;			/* count up one more expunged message */
@@ -840,7 +840,7 @@
 				/* set the date for this message */
     if (date) mx_setdate (tmp,&selt);
 				/* copy flags */
-    (elt = mail_elt (astream,++astream->nmsgs))->private.uid =
+    (elt = mail_elt (astream,++astream->nmsgs))->ccprivate.uid =
       astream->uid_last;
     if (f&fSEEN) elt->seen = T;
     if (f&fDELETED) elt->deleted = T;
@@ -1000,7 +1000,7 @@
 	*(s = tmp) = '\0';	/* dump out and restart buffer */
       }
       elt = mail_elt (stream,i);
-      sprintf (s,"M%08lx;%08lx.%04x",elt->private.uid,elt->user_flags,
+      sprintf (s,"M%08lx;%08lx.%04x",elt->ccprivate.uid,elt->user_flags,
 	       (fSEEN * elt->seen) + (fDELETED * elt->deleted) +
 	       (fFLAGGED * elt->flagged) + (fANSWERED * elt->answered) +
 	       (fDRAFT * elt->draft));
--- ../c-client-4.2.original/news.c	Tue Dec 30 04:43:46 1997
+++ news.c	Thu Aug  6 20:08:48 1998
@@ -318,7 +318,7 @@
     LOCAL->buf = (char *) fs_get ((LOCAL->buflen = MAXMESSAGESIZE) + 1);
     LOCAL->name = cpystr (stream->mailbox + 6);
     for (i = 0; i < nmsgs; ++i) {
-      stream->uid_last = mail_elt (stream,i+1)->private.uid =
+      stream->uid_last = mail_elt (stream,i+1)->ccprivate.uid =
 	atoi (names[i]->d_name);
       fs_give ((void **) &names[i]);
     }
@@ -422,9 +422,9 @@
   *length = 0;			/* default to empty */
   if (flags & FT_UID) return "";/* UID call "impossible" */
   elt = mail_elt (stream,msgno);/* get elt */
-  if (!elt->private.msg.header.text.data) {
+  if (!elt->ccprivate.msg.header.text.data) {
 				/* build message file name */
-    sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->private.uid);
+    sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->ccprivate.uid);
     if ((fd = open (LOCAL->buf,O_RDONLY,NIL)) < 0) return "";
     fstat (fd,&sbuf);		/* get size of message */
 				/* make plausible IMAPish date string */
@@ -449,15 +449,15 @@
 				/* number of header bytes */
     hdrsize = (*t ? ++t : t) - LOCAL->buf;
     elt->rfc822_size =		/* size of entire message in CRLF form */
-      (elt->private.msg.header.text.size =
-       strcrlfcpy ((char **) &elt->private.msg.header.text.data,&i,LOCAL->buf,
+      (elt->ccprivate.msg.header.text.size =
+       strcrlfcpy ((char **) &elt->ccprivate.msg.header.text.data,&i,LOCAL->buf,
 		   hdrsize)) +
-	 (elt->private.msg.text.text.size =
-	  strcrlfcpy ((char **) &elt->private.msg.text.text.data,&i,t,
+	 (elt->ccprivate.msg.text.text.size =
+	  strcrlfcpy ((char **) &elt->ccprivate.msg.text.text.data,&i,t,
 		      sbuf.st_size - hdrsize));
   }
-  *length = elt->private.msg.header.text.size;
-  return (char *) elt->private.msg.header.text.data;
+  *length = elt->ccprivate.msg.header.text.size;
+  return (char *) elt->ccprivate.msg.header.text.data;
 }
 
 /* News fetch message text (body only)
@@ -476,17 +476,17 @@
   if (flags & FT_UID) return NIL;
   elt = mail_elt (stream,msgno);/* get elt */
 				/* snarf message if don't have it yet */
-  if (!elt->private.msg.text.text.data) {
+  if (!elt->ccprivate.msg.text.text.data) {
     news_header (stream,msgno,NIL,flags);
-    if (!elt->private.msg.text.text.data) return NIL;
+    if (!elt->ccprivate.msg.text.text.data) return NIL;
   }
   if (!(flags & FT_PEEK)) {	/* mark as seen */
     mail_elt (stream,msgno)->seen = T;
     mm_flags (stream,msgno);
   }
-  if (!elt->private.msg.text.text.data) return NIL;
-  INIT (bs,mail_string,elt->private.msg.text.text.data,
-	elt->private.msg.text.text.size);
+  if (!elt->ccprivate.msg.text.text.data) return NIL;
+  INIT (bs,mail_string,elt->ccprivate.msg.text.text.data,
+	elt->ccprivate.msg.text.text.size);
   return T;
 }
 
--- ../c-client-4.2.original/newsrc.c	Thu Sep 11 22:32:48 1997
+++ newsrc.c	Thu Aug  6 20:08:48 1998
@@ -124,12 +124,12 @@
   for (i = 1,j = 1,k = 0; i <= stream->nmsgs; ++i) {
 				/* deleted message? */
     if ((elt = mail_elt (stream,i))->deleted) {
-      k = elt->private.uid;	/* this is the top of the current range */
+      k = elt->ccprivate.uid;	/* this is the top of the current range */
       if (!j) j = k;		/* if no range in progress, start one */
     }
     else if (j) {		/* unread message, ending a range */
 				/* calculate end of range */
-      if (k = elt->private.uid - 1) {
+      if (k = elt->ccprivate.uid - 1) {
 				/* dump range */
 	sprintf (tmp,(j == k) ? "%c%ld" : "%c%ld-%ld",c,j,k);
 	if (fputs (tmp,f) == EOF) return NIL;
@@ -276,14 +276,14 @@
 	    for (i = 0,j = 0; isdigit (c); c = getc (f)) i = i*10 + (c-'0');
 	    if (c == '-') for (c = getc (f); isdigit (c); c = getc (f))
 	      j = j*10 +(c-'0');/* collect second value if range */
-	    if (!unseen && (mail_elt (stream,m)->private.uid < i)) unseen = m;
+	    if (!unseen && (mail_elt (stream,m)->ccprivate.uid < i)) unseen = m;
 				/* skip messages before first value */
 	    while ((m <= stream->nmsgs) &&
-		   (mail_elt (stream,m)->private.uid < i)) m++;
+		   (mail_elt (stream,m)->ccprivate.uid < i)) m++;
 				/* do all messages in range */
 	    while ((m <= stream->nmsgs) && (elt = mail_elt (stream,m)) &&
-		   (j ? ((elt->private.uid >= i) && (elt->private.uid <= j)) :
-		    (elt->private.uid == i)) && m++)
+		   (j ? ((elt->ccprivate.uid >= i) && (elt->ccprivate.uid <= j)) :
+		    (elt->ccprivate.uid == i)) && m++)
 	      elt->valid = elt->deleted = T;
 	  }
 
--- ../c-client-4.2.original/nntp.c	Thu Jul 16 23:48:59 1998
+++ nntp.c	Thu Aug  6 20:08:48 1998
@@ -523,14 +523,14 @@
 	 (nntp_send (nstream,"XHDR Date",tmp) == NNTPHEAD))) {
       nmsgs = 0;		/* have holes, calculate true count */
       while ((s = net_getline (nstream->netstream)) && strcmp (s,".")) {
-	mail_elt (stream,++nmsgs)->private.uid = atol (s);
+	mail_elt (stream,++nmsgs)->ccprivate.uid = atol (s);
 	fs_give ((void **) &s);
       }
       if (s) fs_give ((void **) &s);
     }
 				/* assume c-client/NNTP map is entire range */
     else for (k = 1; k <= nmsgs; k++)
-      mail_elt (stream,k)->private.uid = i++;
+      mail_elt (stream,k)->ccprivate.uid = i++;
     stream->nmsgs = 0;		/* whack it back down */
     stream->silent = silent;	/* restore old silent setting */
     mail_exists (stream,nmsgs);	/* notify upper level that messages exist */
@@ -589,7 +589,7 @@
 	  !(elt->day && !elt->rfc822_size)) {
 	ENVELOPE **env = NIL;
 	ENVELOPE *e = NIL;
-	if (!stream->scache) env = &elt->private.msg.env;
+	if (!stream->scache) env = &elt->ccprivate.msg.env;
 	else if (stream->msgno == i) env = &stream->env;
 	else env = &e;
 	if (!*env || !elt->rfc822_size) {
@@ -693,22 +693,22 @@
   *size = 0;
   if ((flags & FT_UID) && !(msgno = mail_msgno (stream,msgno))) return "";
 				/* have header text? */
-  if (!(elt = mail_elt (stream,msgno))->private.msg.header.text.data) {
+  if (!(elt = mail_elt (stream,msgno))->ccprivate.msg.header.text.data) {
     sprintf (tmp,"%ld",mail_uid (stream,msgno));
 				/* get header text */
     if (nntp_send (LOCAL->nntpstream,"HEAD",tmp) == NNTPHEAD)
-      elt->private.msg.header.text.data = (unsigned char *)
+      elt->ccprivate.msg.header.text.data = (unsigned char *)
 	netmsg_slurp_text (LOCAL->nntpstream->netstream,
-			   &elt->private.msg.header.text.size);
+			   &elt->ccprivate.msg.header.text.size);
     else {			/* failed */
       elt->deleted = T;		/* mark as deleted */
-      elt->private.msg.header.text.size = 0;
+      elt->ccprivate.msg.header.text.size = 0;
     }
   }
 				/* return size of text */
-  *size = elt->private.msg.header.text.size;
-  return elt->private.msg.header.text.data ?
-    (char *) elt->private.msg.header.text.data : "";
+  *size = elt->ccprivate.msg.header.text.size;
+  return elt->ccprivate.msg.header.text.data ?
+    (char *) elt->ccprivate.msg.header.text.data : "";
 }
 
 /* NNTP fetch body
@@ -733,7 +733,7 @@
   }
   LOCAL->msgno = msgno;		/* note cached message */
   if (!LOCAL->txt) {		/* have file for this message? */
-    sprintf (tmp,"%ld",elt->private.uid);
+    sprintf (tmp,"%ld",elt->ccprivate.uid);
     if (nntp_send (LOCAL->nntpstream,"BODY",tmp) != NNTPBODY)
       elt->deleted = T;		/* failed mark as deleted */
     else LOCAL->txt = netmsg_slurp (LOCAL->nntpstream->netstream,
--- ../c-client-4.2.original/phile.c	Tue Jul 14 01:55:23 1998
+++ phile.c	Thu Aug  6 20:08:48 1998
@@ -284,7 +284,7 @@
 				/* set subject to be mailbox name */
   LOCAL->env->subject = cpystr (stream->mailbox);
 				/* slurp the data */
-  (buf = &elt->private.special.text)->size = sbuf.st_size;
+  (buf = &elt->ccprivate.special.text)->size = sbuf.st_size;
   read (fd,buf->data = (unsigned char *) fs_get (buf->size + 1),buf->size);
   buf->data[buf->size] = '\0';
   close (fd);			/* close the file */
@@ -324,7 +324,7 @@
   elt->rfc822_size = j + buf->size;
 				/* only one message ever... */
   stream->uid_validity = sbuf.st_mtime;
-  stream->uid_last = elt->private.uid = 1;
+  stream->uid_last = elt->ccprivate.uid = 1;
   return stream;		/* return stream alive to caller */
 }
 
@@ -388,7 +388,7 @@
 void phile_close (MAILSTREAM *stream,long options)
 {
   if (LOCAL) {			/* only if a file is open */
-    fs_give ((void **) &mail_elt (stream,1)->private.special.text.data);
+    fs_give ((void **) &mail_elt (stream,1)->ccprivate.special.text.data);
 				/* nuke the local data */
     fs_give ((void **) &stream->local);
     stream->dtb = NIL;		/* log out the DTB */
@@ -440,7 +440,7 @@
 
 long phile_text (MAILSTREAM *stream,unsigned long msgno,STRING *bs,long flags)
 {
-  SIZEDTEXT *buf = &mail_elt (stream,msgno)->private.special.text;
+  SIZEDTEXT *buf = &mail_elt (stream,msgno)->ccprivate.special.text;
   if (!(flags &FT_PEEK)) {	/* mark message as seen */
     mail_elt (stream,msgno)->seen = T;
     mm_flags (stream,msgno);
--- ../c-client-4.2.original/pop3.c	Tue Jul 14 01:57:00 1998
+++ pop3.c	Thu Aug  6 20:08:48 1998
@@ -382,7 +382,7 @@
       for (i = 0; i < stream->nmsgs;) {
 	elt = mail_elt (stream,++i);
 	elt->valid = elt->recent = T;
-	elt->private.uid = i;
+	elt->ccprivate.uid = i;
       }
       stream->silent = silent;	/* notify main program */
       mail_exists (stream,stream->nmsgs);
@@ -445,7 +445,7 @@
 	  !(elt->day && !elt->rfc822_size)) {
 	ENVELOPE **env = NIL;
 	ENVELOPE *e = NIL;
-	if (!stream->scache) env = &elt->private.msg.env;
+	if (!stream->scache) env = &elt->ccprivate.msg.env;
 	else if (stream->msgno == i) env = &stream->env;
 	else env = &e;
 	if (!*env || !elt->rfc822_size) {
@@ -484,17 +484,17 @@
   MESSAGECACHE *elt;
   if ((flags & FT_UID) && !(msgno = mail_msgno (stream,msgno))) return NIL;
 				/* have header text? */
-  if (!(elt = mail_elt (stream,msgno))->private.msg.header.text.data) {
-    elt->private.msg.header.text.size = pop3_cache (stream,elt);
+  if (!(elt = mail_elt (stream,msgno))->ccprivate.msg.header.text.data) {
+    elt->ccprivate.msg.header.text.size = pop3_cache (stream,elt);
 				/* read the header */
-    fread (elt->private.msg.header.text.data = (unsigned char *)
-	   fs_get ((size_t) elt->private.msg.header.text.size + 1),
-	   (size_t) 1,(size_t) elt->private.msg.header.text.size,LOCAL->txt);
-    elt->private.msg.header.text.data[elt->private.msg.header.text.size] ='\0';
+    fread (elt->ccprivate.msg.header.text.data = (unsigned char *)
+	   fs_get ((size_t) elt->ccprivate.msg.header.text.size + 1),
+	   (size_t) 1,(size_t) elt->ccprivate.msg.header.text.size,LOCAL->txt);
+    elt->ccprivate.msg.header.text.data[elt->ccprivate.msg.header.text.size] ='\0';
   }
 				/* return size of text */
-  if (size) *size = elt->private.msg.header.text.size;
-  return (char *) elt->private.msg.header.text.data;
+  if (size) *size = elt->ccprivate.msg.header.text.size;
+  return (char *) elt->ccprivate.msg.header.text.data;
 }
 
 /* POP3 fetch body
--- ../c-client-4.2.original/rfc822.c	Thu Jun 25 21:18:13 1998
+++ rfc822.c	Thu Aug  6 20:08:48 1998
@@ -109,6 +109,27 @@
  *	    message body
  */
 
+static char **rfc822_extraheaders_names = NULL;
+static char **rfc822_extraheaders_values = NULL;
+
+void rfc822_setextraheaders(char **names, char **values)
+{
+   rfc822_extraheaders_names = names;
+   rfc822_extraheaders_values = values;
+}
+
+void rfc822_extraheader_lines (char **header,ENVELOPE *env)
+{
+   while(rfc822_extraheaders_names && *rfc822_extraheaders_names)
+   {
+      if (rfc822_extraheaders_values) sprintf ((*header += strlen (*header)),"%s%s: %s\015\012",
+			 env->remail ? "ReSent-" : "",
+			 *(rfc822_extraheaders_names++),
+			 *(rfc822_extraheaders_values++)
+			 );
+   }
+}
+
 void rfc822_header (char *header,ENVELOPE *env,BODY *body)
 {
   if (env->remail) {		/* if remailing */
@@ -135,6 +156,9 @@
   rfc822_header_line (&header,"Message-ID",env,env->message_id);
   rfc822_header_line (&header,"Followup-to",env,env->followup_to);
   rfc822_header_line (&header,"References",env,env->references);
+
+  rfc822_extraheader_lines (&header,env);
+  
   if (body && !env->remail) {	/* not if remail or no body structure */
     strcat (header,"MIME-Version: 1.0\015\012");
     rfc822_write_body_header (&header,body);
--- ../c-client-4.2.original/tenex.c	Tue Jul 14 01:54:51 1998
+++ tenex.c	Thu Aug  6 20:08:48 1998
@@ -419,20 +419,20 @@
     for (i = 1; i <= stream->nmsgs; i++)
       if ((elt = mail_elt (stream,i))->sequence) {
 	if (!elt->rfc822_size) { /* have header size yet? */
-	  lseek (LOCAL->fd,elt->private.special.offset +
-		 elt->private.special.text.size,L_SET);
+	  lseek (LOCAL->fd,elt->ccprivate.special.offset +
+		 elt->ccprivate.special.text.size,L_SET);
 				/* resize bigbuf if necessary */
-	  if (LOCAL->buflen < elt->private.msg.full.text.size) {
+	  if (LOCAL->buflen < elt->ccprivate.msg.full.text.size) {
 	    fs_give ((void **) &LOCAL->buf);
-	    LOCAL->buflen = elt->private.msg.full.text.size;
+	    LOCAL->buflen = elt->ccprivate.msg.full.text.size;
 	    LOCAL->buf = (char *) fs_get (LOCAL->buflen + 1);
 	  }
 				/* tie off string */
-	  LOCAL->buf[elt->private.msg.full.text.size] = '\0';
+	  LOCAL->buf[elt->ccprivate.msg.full.text.size] = '\0';
 				/* read in the message */
-	  read (LOCAL->fd,LOCAL->buf,elt->private.msg.full.text.size);
+	  read (LOCAL->fd,LOCAL->buf,elt->ccprivate.msg.full.text.size);
 	  INIT (&bs,mail_string,(void *) LOCAL->buf,
-		elt->private.msg.full.text.size);
+		elt->ccprivate.msg.full.text.size);
 				/* calculate its CRLF size */
 	  elt->rfc822_size = strcrlflen (&bs);
 	}
@@ -764,7 +764,7 @@
   while (i <= stream->nmsgs) {	/* for each message */
     elt = tenex_elt (stream,i);	/* get cache element */
 				/* number of bytes to smash or preserve */
-    k = elt->private.special.text.size + tenex_size (stream,i);
+    k = elt->ccprivate.special.text.size + tenex_size (stream,i);
     if (elt->deleted) {		/* if deleted */
       if (elt->recent) --recent;/* if recent, note one less recent message */
       delta += k;		/* number of bytes to delete */
@@ -773,7 +773,7 @@
     }
     else if (i++ && delta) {	/* preserved message */
 				/* first byte to preserve */
-      j = elt->private.special.offset;
+      j = elt->ccprivate.special.offset;
       do {			/* read from source position */
 	m = min (k,LOCAL->buflen);
 	lseek (LOCAL->fd,j,L_SET);
@@ -790,10 +790,10 @@
 	j += m;			/* next chunk, perhaps */
       } while (k -= m);		/* until done */
 				/* note the new address of this text */
-      elt->private.special.offset -= delta;
+      elt->ccprivate.special.offset -= delta;
     }
 				/* preserved but no deleted messages */
-    else pos = elt->private.special.offset + k;
+    else pos = elt->ccprivate.special.offset + k;
   }
   if (n) {			/* truncate file after last message */
     if (pos != (LOCAL->filesize -= delta)) {
@@ -876,9 +876,9 @@
 				/* for each requested message */
   for (i = 1; ret && (i <= stream->nmsgs); i++) 
     if ((elt = mail_elt (stream,i))->sequence) {
-      lseek (LOCAL->fd,elt->private.special.offset,L_SET);
+      lseek (LOCAL->fd,elt->ccprivate.special.offset,L_SET);
 				/* number of bytes to copy */
-      k = elt->private.special.text.size + tenex_size (stream,i);
+      k = elt->ccprivate.special.text.size + tenex_size (stream,i);
       do {			/* read from source position */
 	j = min (k,LOCAL->buflen);
 	read (LOCAL->fd,LOCAL->buf,j);
@@ -1024,9 +1024,9 @@
 unsigned long tenex_size (MAILSTREAM *stream,unsigned long m)
 {
   MESSAGECACHE *elt = mail_elt (stream,m);
-  return ((m < stream->nmsgs) ? mail_elt (stream,m+1)->private.special.offset :
+  return ((m < stream->nmsgs) ? mail_elt (stream,m+1)->ccprivate.special.offset :
 	  LOCAL->filesize) -
-	    (elt->private.special.offset + elt->private.special.text.size);
+	    (elt->ccprivate.special.offset + elt->ccprivate.special.text.size);
 }
 
 
@@ -1103,22 +1103,22 @@
     mail_exists (stream,++nmsgs);
 				/* instantiate an elt for this message */
     (elt = mail_elt (stream,nmsgs))->valid = T;
-    elt->private.uid = ++stream->uid_last;
+    elt->ccprivate.uid = ++stream->uid_last;
 				/* note file offset of header */
-    elt->private.special.offset = curpos;
+    elt->ccprivate.special.offset = curpos;
 				/* in case error */
-    elt->private.special.text.size = 0;
+    elt->ccprivate.special.text.size = 0;
 				/* header size not known yet */
-    elt->private.msg.header.text.size = 0;
+    elt->ccprivate.msg.header.text.size = 0;
 				/* parse the header components */
     if (mail_parse_date (elt,LOCAL->buf) &&
-	(elt->private.msg.full.text.size = strtoul (x = s,&s,10)) &&
+	(elt->ccprivate.msg.full.text.size = strtoul (x = s,&s,10)) &&
 	(!(s && *s)) &&
 	isdigit (t[0]) && isdigit (t[1]) && isdigit (t[2]) &&
 	isdigit (t[3]) && isdigit (t[4]) && isdigit (t[5]) &&
 	isdigit (t[6]) && isdigit (t[7]) && isdigit (t[8]) &&
 	isdigit (t[9]) && isdigit (t[10]) && isdigit (t[11]) && !t[12])
-      elt->private.special.text.size = i;
+      elt->ccprivate.special.text.size = i;
     else {			/* oops */
       sprintf (tmp,"Unable to parse internal header elements at %ld: %s,%s;%s",
 	       curpos,LOCAL->buf,x,t);
@@ -1127,9 +1127,9 @@
       return NIL;
     }
 				/* make sure didn't run off end of file */
-    if ((curpos += (elt->private.msg.full.text.size + i)) > sbuf.st_size) {
+    if ((curpos += (elt->ccprivate.msg.full.text.size + i)) > sbuf.st_size) {
       sprintf (tmp,"Last message (at %lu) runs past end of file (%lu > %lu)",
-	       elt->private.special.offset,curpos,sbuf.st_size);
+	       elt->ccprivate.special.offset,curpos,sbuf.st_size);
       mm_log (tmp,ERROR);
       tenex_close (stream,NIL);
       return NIL;
@@ -1204,8 +1204,8 @@
 				/* noop if readonly and have valid flags */
   if (stream->rdonly && elt->valid) return;
 				/* set the seek pointer */
-  lseek (LOCAL->fd,(off_t) elt->private.special.offset +
-	 elt->private.special.text.size - 13,L_SET);
+  lseek (LOCAL->fd,(off_t) elt->ccprivate.special.offset +
+	 elt->ccprivate.special.text.size - 13,L_SET);
 				/* read the new flags */
   if (read (LOCAL->fd,LOCAL->buf,12) < 0) {
     sprintf (LOCAL->buf,"Unable to read new status: %s",strerror (errno));
@@ -1247,8 +1247,8 @@
 	     (fFLAGGED * elt->flagged) + (fANSWERED * elt->answered) +
 	     (fDRAFT * elt->draft));
 				/* get to that place in the file */
-    lseek (LOCAL->fd,(off_t) elt->private.special.offset +
-	   elt->private.special.text.size - 13,L_SET);
+    lseek (LOCAL->fd,(off_t) elt->ccprivate.special.offset +
+	   elt->ccprivate.special.text.size - 13,L_SET);
 				/* write new flags */
     write (LOCAL->fd,LOCAL->buf,12);
     if (syncflag) {		/* sync if requested */
@@ -1274,11 +1274,11 @@
   char c = '\0';
   char *s = NIL;
   MESSAGECACHE *elt = tenex_elt (stream,msgno);
-  unsigned long ret = elt->private.special.offset +
-    elt->private.special.text.size;
+  unsigned long ret = elt->ccprivate.special.offset +
+    elt->ccprivate.special.text.size;
   unsigned long msiz = tenex_size (stream,msgno);
 				/* is header size known? */
-  if (!(*size = elt->private.msg.header.text.size)) {
+  if (!(*size = elt->ccprivate.msg.header.text.size)) {
     lseek (LOCAL->fd,ret,L_SET);/* get to header position */
 				/* search message for LF LF */
     for (siz = 0; siz < msiz; siz++) {
@@ -1287,14 +1287,14 @@
 				/* two newline sequence? */
       if ((c == '\012') && (*s == '\012')) {
 				/* yes, note for later */
-	elt->private.msg.header.text.size = (*size = siz + 1);
+	elt->ccprivate.msg.header.text.size = (*size = siz + 1);
 		
 	return ret;		/* return to caller */
       }
       else c = *s++;		/* next character */
     }
 				/* header consumes entire message */
-    elt->private.msg.header.text.size = *size = msiz;
+    elt->ccprivate.msg.header.text.size = *size = msiz;
   }
   return ret;
 }
--- ../c-client-4.2.original/unix.c	Thu Jul 16 02:50:38 1998
+++ unix.c	Thu Aug  6 20:08:48 1998
@@ -515,26 +515,26 @@
 					 (unsigned char *) "X-UID"));
   }
 				/* go to header position */
-  lseek (LOCAL->fd,elt->private.special.offset +
-	 elt->private.msg.header.offset,L_SET);
+  lseek (LOCAL->fd,elt->ccprivate.special.offset +
+	 elt->ccprivate.msg.header.offset,L_SET);
   if (flags & FT_INTERNAL) {	/* initial data OK? */
-    if (elt->private.msg.header.text.size > LOCAL->buflen) {
+    if (elt->ccprivate.msg.header.text.size > LOCAL->buflen) {
       fs_give ((void **) &LOCAL->buf);
       LOCAL->buf = (char *) fs_get ((LOCAL->buflen =
-				     elt->private.msg.header.text.size) + 1);
+				     elt->ccprivate.msg.header.text.size) + 1);
     }
 				/* read message */
-    read (LOCAL->fd,LOCAL->buf,elt->private.msg.header.text.size);
+    read (LOCAL->fd,LOCAL->buf,elt->ccprivate.msg.header.text.size);
 				/* got text, tie off string */
-    LOCAL->buf[*length = elt->private.msg.header.text.size] = '\0';
+    LOCAL->buf[*length = elt->ccprivate.msg.header.text.size] = '\0';
   }
   else {			/* need to make a CRLF version */
-    read (LOCAL->fd,s = (char *) fs_get (elt->private.msg.header.text.size+1),
-	  elt->private.msg.header.text.size);
+    read (LOCAL->fd,s = (char *) fs_get (elt->ccprivate.msg.header.text.size+1),
+	  elt->ccprivate.msg.header.text.size);
 				/* tie off string, and convert to CRLF */
-    s[elt->private.msg.header.text.size] = '\0';
+    s[elt->ccprivate.msg.header.text.size] = '\0';
     *length = strcrlfcpy (&LOCAL->buf,&LOCAL->buflen,s,
-			  elt->private.msg.header.text.size);
+			  elt->ccprivate.msg.header.text.size);
     fs_give ((void **) &s);	/* free readin buffer */
   }
   *length = mail_filter (LOCAL->buf,*length,unix_hlines,FT_NOT);
@@ -582,18 +582,18 @@
   STRING bs;
   char *s,tmp[CHUNK];
 				/* go to text position */
-  lseek (LOCAL->fd,elt->private.special.offset +
-	 elt->private.msg.text.offset,L_SET);
+  lseek (LOCAL->fd,elt->ccprivate.special.offset +
+	 elt->ccprivate.msg.text.offset,L_SET);
   if (flags & FT_INTERNAL) {	/* initial data OK? */
-    if (elt->private.msg.text.text.size > LOCAL->buflen) {
+    if (elt->ccprivate.msg.text.text.size > LOCAL->buflen) {
       fs_give ((void **) &LOCAL->buf);
       LOCAL->buf = (char *) fs_get ((LOCAL->buflen =
-				     elt->private.msg.text.text.size) + 1);
+				     elt->ccprivate.msg.text.text.size) + 1);
     }
 				/* read message */
-    read (LOCAL->fd,LOCAL->buf,elt->private.msg.text.text.size);
+    read (LOCAL->fd,LOCAL->buf,elt->ccprivate.msg.text.text.size);
 				/* got text, tie off string */
-    LOCAL->buf[*length = elt->private.msg.text.text.size] = '\0';
+    LOCAL->buf[*length = elt->ccprivate.msg.text.text.size] = '\0';
   }
   else {			/* need to make a CRLF version */
     if (elt->rfc822_size > LOCAL->buflen) {
@@ -602,10 +602,10 @@
       LOCAL->buf = (char *) fs_get ((LOCAL->buflen = elt->rfc822_size) + 1);
     }
     d.fd = LOCAL->fd;		/* yes, set up file descriptor */
-    d.pos = elt->private.special.offset + elt->private.msg.text.offset;
+    d.pos = elt->ccprivate.special.offset + elt->ccprivate.msg.text.offset;
     d.chunk = tmp;		/* initial buffer chunk */
     d.chunksize = CHUNK;	/* file chunk size */
-    INIT (&bs,fd_string,&d,elt->private.msg.text.text.size);
+    INIT (&bs,fd_string,&d,elt->ccprivate.msg.text.text.size);
     for (s = LOCAL->buf; SIZE (&bs);) switch (CHR (&bs)) {
     case '\015':		/* carriage return seen */
       *s++ = SNX (&bs);		/* copy it and any succeeding LF */
@@ -778,9 +778,9 @@
 				/* write all requested messages to mailbox */
   for (i = 1; ret && (i <= stream->nmsgs); i++)
     if ((elt = mail_elt (stream,i))->sequence) {
-      lseek (LOCAL->fd,elt->private.special.offset,L_SET);
-      read (LOCAL->fd,LOCAL->buf,elt->private.special.text.size);
-      if (write (fd,LOCAL->buf,elt->private.special.text.size) < 0) ret = NIL;
+      lseek (LOCAL->fd,elt->ccprivate.special.offset,L_SET);
+      read (LOCAL->fd,LOCAL->buf,elt->ccprivate.special.text.size);
+      if (write (fd,LOCAL->buf,elt->ccprivate.special.text.size) < 0) ret = NIL;
       else {			/* internal header succeeded */
 	s = unix_header (stream,i,&j,FT_INTERNAL);
 				/* header size, sans trailing newline */
@@ -1186,8 +1186,8 @@
 	recent++;		/* assume recent by default */
 	elt->recent = T;
 				/* note position/size of internal header */
-	elt->private.special.offset = j;
-	elt->private.msg.header.offset = elt->private.special.text.size = i;
+	elt->ccprivate.special.offset = j;
+	elt->ccprivate.msg.header.offset = elt->ccprivate.special.text.size = i;
 
 				/* generate plausible IMAPish date string */
 	date[2] = date[6] = date[20] = '-'; date[11] = ' ';
@@ -1334,9 +1334,9 @@
 				/* flush remainder of line */
 		  while (*s != '\n') s++;
 				/* make sure not duplicated */
-		  if (elt->private.uid)
+		  if (elt->ccprivate.uid)
 		    sprintf (tmp,"Message %lu UID %lu already has UID %lu",
-			     elt->msgno - 1,j,elt->private.uid);
+			     elt->msgno - 1,j,elt->ccprivate.uid);
 				/* make sure UID doesn't go backwards */
 		  else if (j <= prevuid)
 		    sprintf (tmp,"Message %lu UID %lu less than %lu",
@@ -1346,13 +1346,13 @@
 		    sprintf (tmp,"Message %lu UID %lu greater than last %lu",
 			     elt->msgno - 1,j,stream->uid_last);
 		  else {	/* normal UID case */
-		    prevuid = elt->private.uid = j;
+		    prevuid = elt->ccprivate.uid = j;
 		    break;		/* exit this cruft */
 		  }
 		  mm_log (tmp,WARN);
 				/* invalidate UID validity */
 		  stream->uid_validity = 0;
-		  elt->private.uid = 0;
+		  elt->ccprivate.uid = 0;
 		}
 		break;
 	      }
@@ -1397,14 +1397,14 @@
 	  }
 	} while (i && (*t != '\n'));
 				/* assign a UID if none found */
-	if (((nmsgs > 1) || !pseudoseen) && !elt->private.uid)
-	  prevuid = elt->private.uid = ++stream->uid_last;
+	if (((nmsgs > 1) || !pseudoseen) && !elt->ccprivate.uid)
+	  prevuid = elt->ccprivate.uid = ++stream->uid_last;
 
 				/* note size of header, location of text */
-	elt->private.msg.header.text.size = 
-	  (elt->private.msg.text.offset =
-	   (LOCAL->filesize + GETPOS (&bs)) - elt->private.special.offset) -
-	     elt->private.special.text.size;
+	elt->ccprivate.msg.header.text.size = 
+	  (elt->ccprivate.msg.text.offset =
+	   (LOCAL->filesize + GETPOS (&bs)) - elt->ccprivate.special.offset) -
+	     elt->ccprivate.special.text.size;
 	k = 0;			/* no previous line size yet */
 				/* note current position */
 	j = LOCAL->filesize + GETPOS (&bs);
@@ -1420,10 +1420,10 @@
 	    }
 	  }
 	} while (i && !ti);	/* until found a header */
-	elt->private.msg.text.text.size = j -
-	  (elt->private.special.offset + elt->private.msg.text.offset);
+	elt->ccprivate.msg.text.text.size = j -
+	  (elt->ccprivate.special.offset + elt->ccprivate.msg.text.offset);
 	if (k == 2) {		/* last line was blank? */
-	  elt->private.msg.text.text.size--;
+	  elt->ccprivate.msg.text.text.size--;
 	  elt->rfc822_size -= 2;
 	}
       } while (i);		/* until end of buffer */
@@ -1577,7 +1577,7 @@
       char stack[64];
       char *p = stack;
 				/* push UID digits on the stack */
-      unsigned long n = elt->private.uid;
+      unsigned long n = elt->ccprivate.uid;
       do *p++ = (char) (n % 10) + '0';
       while (n /= 10);
       *s++ = 'X'; *s++ = '-'; *s++ = 'U'; *s++ = 'I'; *s++ = 'D'; *s++ = ':';
@@ -1657,13 +1657,13 @@
       ++*nexp;			/* count up one more expunged message */
     }
     else {			/* update file pointers from kludgey places */
-      elt->private.special.offset = elt->private.msg.full.offset;
-      elt->private.msg.text.offset = elt->private.msg.full.text.size;
+      elt->ccprivate.special.offset = elt->ccprivate.msg.full.offset;
+      elt->ccprivate.msg.text.offset = elt->ccprivate.msg.full.text.size;
 				/* in case header grew */
-      elt->private.msg.header.text.size = elt->private.msg.text.offset -
-	elt->private.msg.header.offset;
+      elt->ccprivate.msg.header.text.size = elt->ccprivate.msg.text.offset -
+	elt->ccprivate.msg.header.offset;
 				/* stomp on these two kludges */
-      elt->private.msg.full.offset = elt->private.msg.full.text.size = 0;
+      elt->ccprivate.msg.full.offset = elt->ccprivate.msg.full.text.size = 0;
       i++;			/* preserved message */
     }
   }
@@ -1717,11 +1717,11 @@
   char *s;
   unsigned long i;
 				/* (kludge alert) note new message offset */
-  elt->private.msg.full.offset = *size;
+  elt->ccprivate.msg.full.offset = *size;
 				/* internal header */
-  lseek (LOCAL->fd,elt->private.special.offset,L_SET);
-  read (LOCAL->fd,LOCAL->buf,elt->private.special.text.size);
-  if (unix_fwrite (f,LOCAL->buf,elt->private.special.text.size,size)) {
+  lseek (LOCAL->fd,elt->ccprivate.special.offset,L_SET);
+  read (LOCAL->fd,LOCAL->buf,elt->ccprivate.special.text.size);
+  if (unix_fwrite (f,LOCAL->buf,elt->ccprivate.special.text.size,size)) {
 				/* get header */
     s = unix_header (stream,elt->msgno,&i,FT_INTERNAL);
 				/* header size, sans trailing newline */
@@ -1730,7 +1730,7 @@
     if (unix_fwrite (f,s,i,size) &&
 	unix_fwrite (f,LOCAL->buf,unix_xstatus(stream,LOCAL->buf,elt,T),size)){
 				/* (kludge alert) note new text offset */
-      elt->private.msg.full.text.size = *size - elt->private.msg.full.offset;
+      elt->ccprivate.msg.full.text.size = *size - elt->ccprivate.msg.full.offset;
 				/* get text */
       s = unix_text_work (stream,elt,&i,FT_INTERNAL);
 				/* write text and trailing newline */
--- ../c-client-4.2.original/mail.h	Tue Jul 14 02:24:49 1998
+++ mail.h	Sat Aug  8 12:56:53 1998
@@ -35,6 +35,9 @@
 
 /* Build parameters */
 
+#ifndef CC_MAIL_H
+#   define CC_MAIL_H
+
 #define CACHEINCREMENT 250	/* cache growth increments */
 #define MAILTMPLEN 1024		/* size of a temporary buffer */
 #define MAXMESSAGESIZE 65000	/* MS-DOS: maximum text buffer size
@@ -515,7 +518,7 @@
     PARTTEXT special;		/* special text pointers */
     MESSAGE msg;		/* internal message pointers */
     unsigned int sequence : 1;	/* saved sequence bit; */
-  } private;
+  } ccprivate;
 			/* internal date */
   unsigned int day : 5;		/* day of month (1-31) */
   unsigned int month : 4;	/* month of year (1-12) */
@@ -757,7 +760,7 @@
       long result;		/* search result */
       char *text;		/* cache of fetched text */
     } search;
-  } private;
+  } ccprivate;
 } MAILSTREAM;
 
 
@@ -1291,3 +1294,6 @@
 long sm_subscribe (char *mailbox);
 long sm_unsubscribe (char *mailbox);
 char *sm_read (void **sdb);
+
+#endif // CC_MAIL_H
+
--- ../c-client-4.2.original/Makefile	Thu Jul 16 20:12:22 1998
+++ Makefile	Thu Aug  6 20:16:55 1998
@@ -1,683 +1,24 @@
-# Program:	C client makefile
-#
-# Author:	Mark Crispin
-#		Networks and Distributed Computing
-#		Computing & Communications
-#		University of Washington
-#		Administration Building, AG-44
-#		Seattle, WA  98195
-#		Internet: MRC@CAC.Washington.EDU
-#
-# Date:		11 May 1989
-# Last Edited:	16 July 1998
-#
-# Copyright 1998 by the University of Washington
-#
-#  Permission to use, copy, modify, and distribute this software and its
-# documentation for any purpose and without fee is hereby granted, provided
-# that the above copyright notice appears in all copies and that both the
-# above copyright notice and this permission notice appear in supporting
-# documentation, and that the name of the University of Washington not be
-# used in advertising or publicity pertaining to distribution of the software
-# without specific, written prior permission.  This software is made
-# available "as is", and
-# THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
-# WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
-# NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
-# INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
-# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
-# (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
-# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+# Makefile for extra/src/c-client directory
+# $Id$
 
+CWD = extra/src/c-client
+CSRC = mail.c misc.c
 
-# Command line build parameters
+TARGETS = $(CSRC:.c=.o)
 
-EXTRAAUTHENTICATORS=
-EXTRADRIVERS=mbox
-PASSWDTYPE=std
-
-
-# Extended flags needed for non-standard passwd types.  You may need to modify.
-
-AFSDIR=/usr/afsws
-AFSCFLAGS=-Dexit=afs_exit -D_exit=_afs_exit -I$(AFSDIR)/include
-AFSLIB=$(AFSDIR)/lib
-AFSLDFLAGS=-L$(AFSLIB)/afs -L$(AFSLIB)\
- -lkauth -lprot -lubik -lauth -lrxkad -lrx -llwp -ldes -lcom_err\
- $(AFSLIB)/afs/util.a -laudit -lsys
-DCECFLAGS= -DDCE_MINIMAL -DPASSWD_OVERRIDE=\"/opt/pop3/passwd/passwd\"
-DCELDFLAGS= -ldce
-
-
-# Extended flags needed for additional authenticators.  You may need to modify.
-
-KRBCFLAGS= -I/usr/include/kerberosIV
-KRBLDFLAGS= -lkrb -ldes
-GSSDIR=/usr/local
-GSSCFLAGS= -I$(GSSDIR)/include
-GSSLDFLAGS= -L$(GSSDIR)/lib -lgssapi_krb5 -lkrb5 -lcrypto -lcom_err
-
-
-# Build parameters normally set by the individual port
-
-CHECKPW=std
-LOGINPW=std
-SIGTYPE=bsd
-ACTIVEFILE=/usr/lib/news/active
-SPOOLDIR=/usr/spool
-MAILSPOOL=$(SPOOLDIR)/mail
-NEWSSPOOL=$(SPOOLDIR)/news
-STDPROTO=unixproto
-RSHPATH=/usr/ucb/rsh
-
-
-# Commands possibly overriden by the individual port
-
-ARRC=ar rc
-CC=cc
-LN=ln -s
-RANLIB=ranlib
-
-
-# Standard distribution build parameters
-
-DEFAULTAUTHENTICATORS=log
-DEFAULTDRIVERS=imap nntp pop3 mh mx mbx tenex mtx mmdf unix news phile
-
-
-# Normally no need to change any of these
-
-ARCHIVE=c-client.a
-BINARIES=mail.o misc.o newsrc.o smanager.o osdep.o utf8.o siglocal.o \
- dummy.o pseudo.o netmsg.o flstring.o fdstring.o \
- rfc822.o nntp.o smtp.o imap4r1.o pop3.o \
- unix.o mbox.o mbx.o mmdf.o tenex.o mtx.o news.o phile.o mh.o mx.o
-CFLAGS=$(BASECFLAGS) $(EXTRACFLAGS)
-MAKE=make
-MV=mv
-RM=rm -rf
-SH=sh
-
-
-# Primary build command
-
-BUILDOPTIONS= EXTRACFLAGS="$(EXTRACFLAGS)"\
- EXTRALDFLAGS="$(EXTRALDFLAGS)"\
- EXTRADRIVERS="$(EXTRADRIVERS)" EXTRAAUTHENTICATORS="$(EXTRAAUTHENTICATORS)"\
- PASSWDTYPE=$(PASSWDTYPE) AFSDIR=$(AFSDIR) GSSDIR=$(GSSDIR)
-BUILD=$(MAKE) build $(BUILDOPTIONS) $(EXTRASPECIALS)
-
-# Here if no make argument established
-
-missing: osdep.h
-	$(MAKE) all CC=`cat CCTYPE` CFLAGS="`cat CFLAGS`"
-
-osdep.h:
-	@echo You must specify what type of system
-	@false
-
-
-# Current ports
-
-a32:	# AIX 3.2 for RS/6000
-	$(BUILD) OS=$@ SIGTYPE=psx \
-	 SPOOLDIR=/var/spool \
-	 RSHPATH=/usr/bin/rsh \
-	 BASECFLAGS="-g -Dunix=1 -D_BSD -DNFSKLUDGE" \
-	 BASELDFLAGS="-lbsd"
-
-a41:	# AIX 4.1 for RS/6000
-	$(BUILD) OS=$@ SIGTYPE=psx CHECKPW=a41 \
-	 SPOOLDIR=/var/spool \
-	 RSHPATH=/usr/bin/rsh \
-	 BASECFLAGS="-g -Dunix=1 -D_BSD -DNFSKLUDGE" \
-	 BASELDFLAGS="-lbsd -ls"
-
-aix:	# AIX/370
-	@echo You are building for AIX on an S/370 class machine
-	@echo If you want AIX on an RS/6000 you need to use a32 or a41 instead!
-	$(BUILD) OS=$@ \
-	 BASECFLAGS="-g -DNFSKLUDGE" \
-	 BASELDFLAGS="-lbsd"
-
-aos:	# AOS for RT
-	$(BUILD) OS=$@ \
-	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE"
-
-art:	# AIX 2.2.1 for RT
-	$(BUILD) OS=$@ SIGTYPE=sv4 \
-	 SPOOLDIR=/var \
-	 ACTIVEFILE=/usr/local/news/control/active \
-	 RSHPATH=/bin/rsh \
-	 BASECFLAGS="-g -Dconst= -Dvoid=char" \
-	 RANLIB=true 
-
-asv:	# Altos SVR4
-	$(BUILD) OS=$@ SIGTYPE=sv4 LOGINPW=old \
-	 ACTIVEFILE=/usr/spool/news/active \
-	 RSHPATH=/usr/bin/rcmd \
-	 BASECFLAGS="-Dconst= -DSIGSTOP=SIGKILL" \
-	 BASELDFLAGS="-lsocket -lrpc -lgen -lcrypt -lxenix" \
-	 RANLIB=true
-
-aux:	# A/UX
-	$(BUILD) OS=$@ \
-	 MAILSPOOL=/usr/mail \
-	 BASECFLAGS="-g -B/usr/lib/big/ -Dvoid=char -Dconst= -DNFSKLUDGE" \
-	 RANLIB=true ARRC="ar -rc"
-
-bs3:	# BSD/i386 3.0 or higher
-	$(BUILD) OS=bsi CHECKPW=bsi LOGINPW=bsi \
-	 MAILSPOOL=/var/mail NEWSSPOOL=/var/news/spool \
-	 ACTIVEFILE=/var/news/etc/active \
-	 RSHPATH=/usr/bin/rsh \
-	 BASECFLAGS="-g -O2 -pipe -DNFSKLUDGE"
-
-bsd:	# BSD UNIX
-	$(BUILD) OS=$@ \
-	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE"
-
-bsf:	# FreeBSD
-	$(BUILD) OS=bsi SIGTYPE=psx \
-	 SPOOLDIR=/var \
-	 ACTIVEFILE=/usr/local/news/lib/active \
-	 RSHPATH=/usr/bin/rsh \
-	 BASECFLAGS="-g -O -pipe -DNFSKLUDGE" \
-	 BASELDFLAGS="-lcrypt"
-
-bsi:	# BSD/i386
-	$(BUILD) OS=$@ \
-	 MAILSPOOL=/var/mail NEWSSPOOL=/var/news/spool \
-	 ACTIVEFILE=/var/news/etc/active \
-	 RSHPATH=/usr/bin/rsh \
-	 BASECFLAGS="-g -O2 -pipe -DNFSKLUDGE"
-
-cvx:	# Convex
-	$(BUILD) OS=$@ \
-	 BASECFLAGS="-O -ext -Dconst= -DNFDKLUDGE"
-
-d-g:	# Data General DG/UX
-	$(BUILD) OS=$@ SIGTYPE=sv4 \
-	 MAILSPOOL=/var/mail NEWSSPOOL=/var/spool/news \
-	 ACTIVEFILE=/local/news/active \
-	 RSHPATH=/usr/bin/remsh \
-	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE" \
-	 BASELDFLAGS="-lnsl -lsocket" \
-	 RANLIB=true
-
-d54:	# Data General DG/UX 5.4
-	$(BUILD) OS=d-g SIGTYPE=sv4 \
-	 MAILSPOOL=/var/mail NEWSSPOOL=/var/spool/news \
-	 ACTIVEFILE=/local/news/active \
-	 RSHPATH=/usr/bin/remsh \
-	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE" \
-	 RANLIB=true
-
-dpx:	# Bull DPX/2
-	$(BUILD) OS=sv4 SIGTYPE=sv4 CHECKPW=sv4 LOGINPW=sv4 \
-	 RSHPATH=/usr/bin/remsh \
-	 BASECFLAGS="-Dconst= -DSYSTEM5 -DSHORT_IDENT" \
-	 BASELDFLAGS="-linet" \
-	 RANLIB=true LN=ln
-
-drs:	# ICL DRS/NX
-	$(BUILD) OS=$@ SIGTYPE=sv4 CHECKPW=sv4 LOGINPW=sv4 \
-	 MAILSPOOL=/var/mail NEWSSPOOL=/var/spool/news \
-	 ACTIVEFILE=/var/lib/news/active \
-	 RSHPATH=/usr/bin/rsh \
-	 BASECFLAGS="-O -DNFSKLUDGE" \
-	 BASELDFLAGS="-lsocket -lgen" \
-	 RANLIB=true
-
-dyn:	# Dynix
-	$(BUILD) OS=$@ \
-	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE"
-
-epx:	# EP/IX
-	$(BUILD) OS=sv4 SIGTYPE=sv4 CHECKPW=sv4 LOGINPW=sv4 \
-	 MAILSPOOL=/var/mail NEWSSPOOL=/var/spool/news \
-	 ACTIVEFILE=/usr/share/news/active \
-	 RSHPATH=/usr/net/rsh \
-	 BASECFLAGS="-g -systype svr4" \
-	 BASELDFLAGS="-lsocket -lnsl -lgen" \
-	 RANLIB=true
-
-gas:	# GCC Altos SVR4
-	$(BUILD) OS=asv SIGTYPE=sv4 LOGINPW=old \
-	 ACTIVEFILE=/usr/spool/news/active \
-	 RSHPATH=/usr/bin/rcmd \
-	 BASECFLAGS="-g -O -DALTOS_SYSTEM_V -DSIGSTOP=SIGKILL" \
-	 BASELDFLAGS="-lsocket -lrpc -lgen -lcrypt -lxenix" \
-	 RANLIB=true CC=gcc
-
-gh9:	# GCC HP-UX9.x
-	$(BUILD) OS=hpp SIGTYPE=psx \
-	 MAILSPOOL=/usr/mail \
-	 RSHPATH=/usr/bin/remsh \
-	 BASECFLAGS="-O2 -DNFSKLUDGE" \
-	 RANLIB=true CC=gcc
-
-ghp:	# GCC HP-UX
-	$(BUILD) OS=hpp SIGTYPE=psx \
-	 SPOOLDIR=/var \
-	 ACTIVEFILE=/var/news/active \
-	 RSHPATH=/usr/bin/remsh \
-	 BASECFLAGS="-O2 -DNFSKLUDGE" \
-	 RANLIB=true CC=gcc
-
-gso:	# GCC Solaris
-	$(BUILD) OS=sol SIGTYPE=psx CHECKPW=psx \
-	 MAILSPOOL=/var/mail NEWSSPOOL=/var/spool/news \
-	 ACTIVEFILE=/usr/share/news/active \
-	 RSHPATH=/usr/bin/rsh \
-	 BASECFLAGS="-g -O2 -DNFSKLUDGE" \
-	 BASELDFLAGS="-lsocket -lnsl -lgen" \
-	 RANLIB=true CC=gcc
-
-gsu:	# GCC SUN-OS
-	$(BUILD) OS=sun \
-	 BASECFLAGS="-O2 -DNFSKLUDGE" \
-	 BASELDFLAGS="-ldl" \
-	 CC=gcc
-
-gul:	# GCC Ultrix
-	$(BUILD) OS=ult SIGTYPE=psx CHECKPW=ult \
-	 BASECFLAGS="-g -O -DNFSKLUDGE" \
-	 BASELDFLAGS="-lauth" \
-	 CC=gcc
-
-hpp:	# HP-UX 9.x
-	$(BUILD) OS=$@ SIGTYPE=psx \
-	 MAILSPOOL=/usr/mail \
-	 RSHPATH=/usr/bin/remsh \
-	 BASECFLAGS="-g -Aa -D_HPUX_SOURCE -DNFSKLUDGE" \
-	 BASELDFLAGS="-lnet -lV3" \
-	 RANLIB=true
-
-hpx:	# HP-UX 10.x
-	$(BUILD) OS=hpp SIGTYPE=psx \
-	 SPOOLDIR=/var \
-	 ACTIVEFILE=/var/news/active \
-	 RSHPATH=/usr/bin/remsh \
-	 BASECFLAGS="-g -Ae -DNFSKLUDGE" \
-	 BASELDFLAGS="-lnet -lV3" \
-	 RANLIB=true
-
-isc:	# Interactive
-	$(BUILD) OS=$@ SIGTYPE=sv4 CHECKPW=sv4 LOGINPW=sv4 \
-	 MAILSPOOL=/var/mail NEWSSPOOL=/var/spool/news \
-	 ACTIVEFILE=/var/spool/news/active \
-	 BASECFLAGS="-Xp -D_SYSV3" \
-	 BASELDFLAGS="-linet -lnsl_s -lgen -lx -lsec -liberty" \
-	 RANLIB=true
-
-lnx:	# Linux non-shadow passwords
-	@echo You are building for traditional Linux *without* shadow
-	@echo passwords and with the crypt function in the C library.
-	@echo If your system has shadow passwords, or if crypt is not
-	@echo in the C library, you must use slx or sl5 instead!
-	$(BUILD) OS=$@ SIGTYPE=psx \
-	 SPOOLDIR=/var/spool \
-	 RSHPATH=/usr/bin/rsh \
-	 BASECFLAGS="-g -O -DNFSKLUDGE"
-
-lyn:	# LynxOS
-	$(BUILD) OS=$@ \
-	 RSHPATH=/bin/rsh \
-	 BASECFLAGS="-g -O -pipe -DNFSKLUDGE"
-	 BASELDFLAGS=-lbsd \
-	 CC=gcc
-
-mct:	# MachTen - NFSKLUDGE doesn't work (at least not on 2.2)
-	$(BUILD) OS=$@ \
-	 SPOOLDIR=/var/spool \
-	 BASECFLAGS="-g -O -pipe"
-
-mnt:	# Mint
-	$(BUILD) OS=$@ \
-	 BASECFLAGS="-g -O -Dunix=1 -D__atarist__ -D_POSIX_SOURCE -pipe" \
-	 RSHPATH=/usr/bin/rsh \
-	 RANLIB=true CC=gcc ARRC="gcc-ar rc"
-
-neb:	# NetBSD
-	$(BUILD) OS=bsi \
-	 SPOOLDIR=/var \
-	 ACTIVEFILE=/var/db/news/active \
-	 RSHPATH=/usr/bin/rsh \
-	 BASECFLAGS="-g -O -pipe -DNFSKLUDGE" \
-	 BASELDFLAGS="-lcrypt"
-
-nxt:	# NEXTSTEP
-	$(BUILD) OS=$@ \
-	 BASECFLAGS="-g -O -pipe -DNFSKLUDGE"
-
-osf:	# OSF/1
-	$(BUILD) OS=$@ SIGTYPE=psx \
-	 BASECFLAGS="-g3 -O2 -Olimit 1500 -DNFSKLUDGE"
-
-# Note: sia_become_user() used by LOGINPW=os4 doesn't seem to work right.  The
-# user doesn't get proper file access, and the process can't be killed.
-
-os4:	# OSF/1 (Digital UNIX) 4
-	$(BUILD) OS=$@ SIGTYPE=psx CHECKPW=os4 LOGINPW=sec \
-	 BASECFLAGS="-g3 -O2 -Olimit 1500 -DNFSKLUDGE" \
-	 BASELDFLAGS="-lsecurity -ldb -laud -lm"
-
-ptx:	# PTX
-	$(BUILD) OS=$@ SIGTYPE=psx CHECKPW=svo LOGINPW=sv4 \
-	 MAILSPOOL=/usr/mail \
-	 RSHPATH=/usr/bin/resh \
-	 BASECFLAGS="-Wc,-O3 -Wc,-seq -Dprivate=PRIVATE -DNFSKLUDGE" \
-	 BASELDFLAGS="-lseq -lsec -lsocket -linet -lnsl -lgen" \
-	 RANLIB=true
-
-pyr:	# Pyramid
-	$(BUILD) OS=$@ \
-	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE"
-
-qnx:	# QNX
-	$(BUILD) OS=$@ CHECKPW=psx LOGINPW=old \
-	 RSHPATH=/usr/ucb/rsh \
-	 BASECFLAGS="-Otax -g -Dunix=1 -D_POSIX_SOURCE" \
-	 BASELDFLAGS="-g -N128k -llogin -lsocket -lunix"
-
-s40:	# SUN-OS 4.0
-	$(BUILD) OS=$@ \
-	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE"
-
-sc5:	# SCO Open Server 5.0
-	$(BUILD) OS=$@ SIGTYPE=psx CHECKPW=sec LOGINPW=sec \
-	 STDPROTO=mmdfproto \
-	 SPOOLDIR=/var/spool \
-	 ACTIVEFILE=/var/lib/news/active \
-	 RSHPATH=/usr/bin/rcmd \
-	 BASECFLAGS="-O3 -dy -s" \
-	 BASELDFLAGS="-lsocket -lcrypt -lprot -lx -ltinfo -lm" \
-	 RANLIB=true
-
-sco:	# Santa Cruz Operation
-	$(BUILD) OS=$@ SIGTYPE=sv4 CHECKPW=sec LOGINPW=sec \
-	 STDPROTO=mmdfproto \
-	 RSHPATH=/usr/bin/rcmd \
-	 BASECFLAGS="-O3" \
-	 BASELDFLAGS="-lsocket -lprot -lcrypt_i -lx -los" \
-	 RANLIB=true LN=ln
-
-# Note: setting _POSIX_SOURCE doesn't seem to build it as of SGI IRIX 5.3
-
-sgi:	# Silicon Graphics
-	$(BUILD) OS=$@ SIGTYPE=sv4 \
-	 MAILSPOOL=/usr/mail \
-	 RSHPATH=/usr/bsd/rsh \
-	 BASECFLAGS="-g -ansi -DNFSKLUDGE" \
-	 RANLIB=true
-
-# Note: Mark Kaesling says that setluid() isn't in HP-UX with SecureWare.
-
-shp:	# HP-UX with Trusted Computer Base
-	$(BUILD) OS=$@ SIGTYPE=psx CHECKPW=sec LOGINPW=std \
-	 SPOOLDIR=/var \
-	 ACTIVEFILE=/var/news/active \
-	 RSHPATH=/usr/bin/remsh \
-	 BASECFLAGS="-g -Ae -DNFSKLUDGE" \
-	 BASELDFLAGS="-lnet -lV3 -lsec" \
-	 RANLIB=true
-
-# Note: KC Smith at Microsoft says that -lcrypt is for glibc
-
-slx:	# Secure Linux
-	@echo You are building for glibc versions of Secure Linux
-	@echo If you want libc5 versions you must use sl5 instead!
-	$(BUILD) OS=$@ SIGTYPE=psx CHECKPW=psx \
-	 SPOOLDIR=/var/spool \
-	 RSHPATH=/usr/bin/rsh \
-	 BASECFLAGS="-g -fno-omit-frame-pointer -O6 -DNFSKLUDGE" \
-	 BASELDFLAGS="-s -lcrypt"
-
-# Note: KC Smith at Microsoft says that -lshadow is for libc5
-
-sl5:	# Secure Linux using libc5
-	$(BUILD) OS=slx SIGTYPE=psx CHECKPW=psx \
-	 SPOOLDIR=/var/spool \
-	 RSHPATH=/usr/bin/rsh \
-	 BASECFLAGS="-g -fno-omit-frame-pointer -O6 -DNFSKLUDGE" \
-	 BASELDFLAGS="-s -lshadow"
-
-snx:	# Siemens Nixdorf SINIX and Reliant UNIX
-	$(BUILD) OS=sv4 SIGTYPE=psx CHECKPW=sv4 \
-	 MAILSPOOL=/var/mail NEWSSPOOL=/var/spool/news \
-	 ACTIVEFILE=/usr/share/news/active \
-	 RSHPATH=/usr/bin/rsh \
-	 BASECFLAGS="-g -D_SYS_CLOCK_H -Dconst=" \
-	 BASELDFLAGS="-lsocket -lnsl -lgen" \
-	 RANLIB=true
-
-# Note: It is a long and disgusting story about why cc is set to ucbcc.  You
-# need to invoke the C compiler so that it links with the SVR4 libraries and
-# not the BSD libraries, otherwise readdir() will return the wrong information.
-# Of all the names in the most common path, ucbcc is the only name to be found
-# (on /usr/ccs/bin) that points to a suitable compiler.  cc is likely to be
-# /usr/ucb/cc which is absolutely not the compiler that you want.  The real
-# SVR4 cc is probably something like /opt/SUNWspro/bin/cc which is rarely in
-# anyone's path.
-#
-# ucbcc is probably a link to acc, e.g. /opt/SUNWspro/SC4.0/bin/acc, and is
-# the UCB C compiler using the SVR4 libraries.
-#
-# If ucbcc isn't on your system, then punt on the SUN C compiler and use gcc
-# instead (the gso port instead of the sol port).
-# 
-# If, in spite of all the above warnings, you choose to change "ucbcc" to "cc",
-# you will probably find that the -O2 needs to be changed to -O.  If you don't
-# get any error messages with -O2, that's a pretty good indicator that you
-# goofed and are running the compiler that will link with the BSD libraries.
-#
-# To recap:
-# 1) The sol port is designed to be built using the UCB compiler using the
-#    SVR4 libraries.  This compiler is "ucbcc", which is lunk to acc.  You
-#    use -O2 as one of the CFLAGS.
-# 2) If you build the sol port with the UCB compiler using the BSD libraries,
-#    you will get no error messages but you will get bad binaries (the most
-#    obvious symptom is dropping the first two characters return filenames
-#    from the imapd LIST command.  This compiler also uses -O2, and is very
-#    often what the user gets from "cc".  BEWARE!!!
-# 3) If you build the sol port with the real SVR4 compiler, which is often
-#    hidden away or unavailable on many systems, then you will get errors
-#    from -O2 and you need to change that to -O.  But you will get a good
-#    binary.  However, you should try it with -O2 first, to make sure that
-#    you got this compiler and not the UCB compiler using BSD libraries.
-
-sol:	# Solaris
-	$(BUILD) OS=$@ SIGTYPE=psx CHECKPW=psx \
-	 MAILSPOOL=/var/mail NEWSSPOOL=/var/spool/news \
-	 ACTIVEFILE=/usr/share/news/active \
-	 RSHPATH=/usr/bin/rsh \
-	 BASECFLAGS="-g -O2 -DNFSKLUDGE" \
-	 BASELDFLAGS="-lsocket -lnsl -lgen" \
-	 RANLIB=true CC=ucbcc
-
-sos:	# Secure OSF/1
-	$(BUILD) OS=$@ SIGTYPE=psx CHECKPW=sec LOGINPW=sec \
-	 BASECFLAGS="-g3 -O2 -Olimit 1500 -DNFSKLUDGE" \
-	 BASELDFLAGS="-lsecurity -laud"
-
-ssn:	# Secure SUN-OS
-	$(BUILD) OS=sun CHECKPW=ssn \
-	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE" \
-	 BASELDFLAGS="-ldl"
-
-sun:	# SUN-OS
-	$(BUILD) OS=$@ \
-	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE" \
-	 BASELDFLAGS="-ldl"
-
-sv2:	# SVR2
-	@echo You are being *very* optimistic!
-	$(BUILD) OS=$@ SIGTYPE=sv4 LOGINPW=old \
-	 MAILSPOOL=/usr/mail \
-	 RSHPATH=/usr/bin/remsh \
-	 BASECFLAGS="-Dconst= -DSYSTEM5 -DSHORT_IDENT -I/usr/ethernet/include" \
-	 BASELDFLAGS="-lnet" \
-	 RANLIB=true LN=ln
-
-sv4:	# SVR4
-	$(BUILD) OS=$@ SIGTYPE=sv4 CHECKPW=sv4 LOGINPW=sv4 \
-	 MAILSPOOL=/var/mail NEWSSPOOL=/var/spool/news \
-	 ACTIVEFILE=/usr/share/news/active \
-	 RSHPATH=/usr/bin/resh \
-	 BASECFLAGS="-g -Dconst=" \
-	 BASELDFLAGS="-lsocket -lnsl -lgen" \
-	 RANLIB=true
-
-ult:	# Ultrix
-	$(BUILD) OS=$@ SIGTYPE=psx CHECKPW=ult \
-	 BASECFLAGS="-g3 -O2 -Olimit 1500 -Dconst= -DNFSKLUDGE" \
-	 BASELDFLAGS="-lauth"
-
-uw2:	# UnixWare SVR4.2
-	$(BUILD) OS=sv4 SIGTYPE=sv4 CHECKPW=sv4 \
-	 MAILSPOOL=/var/mail NEWSSPOOL=/var/spool/news \
-	 ACTIVEFILE=/var/news/lib/active \
-	 RSHPATH=/usr/bin/rsh \
-	 BASECFLAGS="-g" \
-	 BASELDFLAGS="-lsocket -lnsl -lgen" \
-	 RANLIB=true
-
-vul:	# VAX Ultrix
-	$(BUILD) OS=ult SIGTYPE=psx CHECKPW=ult \
-	 BASECFLAGS="-O2 -Dconst= -DNFSKLUDGE" \
-	 BASELDFLAGS="-lauth"
-
-vu2:	# VAX Ultrix 2.3, etc.
-	$(BUILD) OS=$@ \
-	 BASECFLAGS="-O2 -Dconst= -Dvoid=char -DNFSKLUDGE"
-
-
-# Build it!
-
-build:	clean once $(ARCHIVE)
-
-all:	$(ARCHIVE)
-
-$(ARCHIVE): $(BINARIES)
-	sh -c '$(RM) $(ARCHIVE) || true'
-	@cat ARCHIVE
-	@$(SH) ARCHIVE
-
-# Cleanup
-
-clean:
-	sh -c '$(RM) auths.c flockbsd.c linkage.[ch] siglocal.c osdep*.[ch] *.o ARCHIVE *FLAGS *TYPE $(ARCHIVE) || true'
-
-
-# Dependencies
-
-dummy.o: mail.h misc.h osdep.h dummy.h
-fdstring.o: mail.h misc.h osdep.h fdstring.h
-flstring.o: mail.h misc.h osdep.h flstring.h
-imap4r1.o: mail.h misc.h osdep.h imap4r1.h rfc822.h
-mail.o: mail.h misc.h osdep.h rfc822.h linkage.h
-mbox.o: mail.h misc.h osdep.h mbox.h unix.h
-mbx.o: mail.h misc.h osdep.h mbx.h dummy.h
-mh.o: mail.h misc.h osdep.h mh.h dummy.h
-mx.o: mail.h misc.h osdep.h mx.h dummy.h
-misc.o: mail.h misc.h osdep.h
-mmdf.o: mail.h misc.h osdep.h mmdf.h pseudo.h dummy.h
-mtx.o: mail.h misc.h osdep.h mtx.h dummy.h
-netmsg.o: mail.h misc.h osdep.h netmsg.h
-news.o: mail.h misc.h osdep.h news.h
-newsrc.o: mail.h misc.h osdep.h newsrc.h
-nntp.o: mail.h misc.h osdep.h netmsg.h smtp.h nntp.h rfc822.h
-phile.o: mail.h misc.h osdep.h phile.h rfc822.h dummy.h
-pseudo.o: pseudo.h
-pop3.o: mail.h misc.h osdep.h pop3.h
-smanager.o: mail.h misc.h osdep.h
-smtp.o: mail.h misc.h osdep.h smtp.h rfc822.h
-rfc822.o: mail.h misc.h osdep.h rfc822.h
-tenex.o: mail.h misc.h osdep.h tenex.h dummy.h
-unix.o: mail.h misc.h osdep.h unix.h pseudo.h dummy.h
-utf8.o: mail.h misc.h osdep.h utf8.h
-
-
-# OS-dependent
-
-osdep.o:mail.h misc.h env.h fs.h ftl.h nl.h tcp.h \
-	osdep.h env_unix.h tcp_unix.h \
-	osdep.c env_unix.c fs_unix.c ftl_unix.c nl_unix.c tcp_unix.c \
-	auths.c flock.c flockbsd.c flcksafe.c fsync.c gethstid.c \
-	gr_wait.c gr_wait4.c gr_waitp.c \
-	auth_gss.c auth_krb.c auth_log.c \
-	scandir.c setpgrp.c strerror.c truncate.c write.c \
-	memmove.c memmove2.c memset.c \
-	tz_bsd.c tz_nul.c tz_sv4.c \
-	write.c \
-	strerror.c strpbrk.c strstr.c strtok.c strtoul.c \
-	OSCFLAGS
-	$(CC) $(CFLAGS) `cat OSCFLAGS` -c osdep.c
-
-osdep.c: osdepbas.c osdepckp.c osdeplog.c
-	sh -c '$(RM) osdep.c || true'
-	cat osdepbas.c osdepckp.c osdeplog.c > osdep.c
-
-flockbsd.c:	# cretin Linux
-
-siglocal.c:	# cretin Linux
-
-
-# Once-only environment setup
-
-once:	onceenv ckp$(PASSWDTYPE) osdep.c $(EXTRAAUTHENTICATORS) 
-
-onceenv:
-	@echo Once-only environment setup...
-	./drivers $(EXTRADRIVERS) $(DEFAULTDRIVERS) dummy
-	./mkauths $(EXTRAAUTHENTICATORS) $(DEFAULTAUTHENTICATORS)
+all:
+	echo $(CCLIENTOSTYPE) >../OSTYPE
 	echo $(CC) > CCTYPE
-	echo $(CFLAGS) > CFLAGS
-	echo -DSTDPROTO=$(STDPROTO) -DMAILSPOOL=\"$(MAILSPOOL)\" \
-	 -DANONYMOUSHOME=\"$(MAILSPOOL)/anonymous\" \
-	 -DACTIVEFILE=\"$(ACTIVEFILE)\" -DNEWSSPOOL=\"$(NEWSSPOOL)\" \
-	 -DRSHPATH=\"$(RSHPATH)\" > OSCFLAGS
-	echo $(BASELDFLAGS) $(EXTRALDFLAGS) > LDFLAGS
-	echo "$(ARRC) $(ARCHIVE) $(BINARIES);$(RANLIB) $(ARCHIVE)" >> ARCHIVE
-	$(LN) os_$(OS).h osdep.h
-	$(LN) os_$(OS).c osdepbas.c
-	$(LN) log_$(LOGINPW).c osdeplog.c
-	$(LN) sig_$(SIGTYPE).c siglocal.c
-	sh -c '(test -f /usr/include/sys/statvfs.h -a $(OS) != sc5 -a $(OS) != sco) && $(LN) flocksun.c flockbsd.c || $(LN) flocksv4.c flockbsd.c'
-
-# Password checkers
-
-ckpafs:	# AFS
-	echo $(AFSCFLAGS) >> OSCFLAGS
-	echo $(AFSLDFLAGS) >> LDFLAGS
-	$(LN) ckp_afs.c osdepckp.c
+	$(MAKE) -f Makefile.ccl $(CCLIENTOSTYPE)
 
-ckpdce:	# DCE
-	echo $(DCECFLAGS) >> OSCFLAGS
-	echo $(DCELDFLAGS) >> LDFLAGS
-	$(LN) ckp_dce.c osdepckp.c
-
-ckpkrb:	# Kerberos IV (must have krb EXTRAAUTHENTICATOR as well)
-	$(LN) ckp_krb.c osdepckp.c
-
-ckpstd:	# Port standard
-	$(LN) ckp_$(CHECKPW).c osdepckp.c
-
-
-# Authenticators
-
-krb:	# Kerberos IV flags
-	echo $(KRBCFLAGS) >> OSCFLAGS
-	echo $(KRBLDFLAGS) >> LDFLAGS
-
-gss:	# GSSAPI Kerberos V flags
-	echo $(GSSCFLAGS) >> OSCFLAGS
-	echo $(GSSLDFLAGS) >> LDFLAGS
+include ../../../makerules
 
+clean:
+	$(MAKE) -f Makefile.ccl clean
 
-# A monument to a hack of long ago and far away...
+doc:
+	@echo
+dep depend:
+	@echo
 
-love:
-	@echo not war?
+include ../../../makeopts
