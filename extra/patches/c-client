*** imap/c-client/Makefile	Wed Nov 17 02:05:48 1999
--- bak/c-client.old/Makefile	Thu Mar  2 17:48:42 2000
***************
*** 102,113 ****
  ARCHIVE=c-client.a
  BINARIES=mail.o misc.o newsrc.o smanager.o osdep.o utf8.o siglocal.o \
   dummy.o pseudo.o netmsg.o flstring.o fdstring.o \
   rfc822.o nntp.o smtp.o imap4r1.o pop3.o \
   unix.o mbox.o mbx.o mmdf.o tenex.o mtx.o news.o phile.o mh.o mx.o
! CFLAGS=$(BASECFLAGS) $(EXTRACFLAGS)
! MAKE=make
  MV=mv
  RM=rm -rf
  SH=sh
  
  
--- 102,112 ----
  ARCHIVE=c-client.a
  BINARIES=mail.o misc.o newsrc.o smanager.o osdep.o utf8.o siglocal.o \
   dummy.o pseudo.o netmsg.o flstring.o fdstring.o \
   rfc822.o nntp.o smtp.o imap4r1.o pop3.o \
   unix.o mbox.o mbx.o mmdf.o tenex.o mtx.o news.o phile.o mh.o mx.o
! CFLAGS=$(BASECFLAGS) $(EXTRACFLAGS) $(CPPFLAGS)
  MV=mv
  RM=rm -rf
  SH=sh
  
  
diff -c5 imap/c-client/env_unix.c bak/c-client.old/env_unix.c
*** imap/c-client/env_unix.c	Thu Jan 20 20:12:55 2000
--- bak/c-client.old/env_unix.c	Fri Mar 24 16:00:43 2000
***************
*** 848,869 ****
  	      mm_log (tmp,WARN);
  	    }
  	  }
  	  base->lock[0] = '\0';	/* give up on lock file */
  	}
! 
        case EEXIST:		/* file already exists */
  	break;			/* try again */
        default:			/* some other failure */
  	sprintf (tmp,"Mailbox vulnerable - error creating %.80s: %s",
  		 hitch,strerror (errno));
  	mm_log (tmp,WARN);	/* this is probably not good */
  	base->lock[0] = '\0';	/* don't use lock files */
  	break;
        }
  				/* if failed to make lock file and retry OK */
!     if ((ld < 0) && base->lock) {
        if (!(i%15)) {		/* time to notify? */
  	sprintf (tmp,"Mailbox %.80s is locked, will override in %d seconds...",
  		 file,i);
  	mm_log (tmp,WARN);
        }
--- 848,872 ----
  	      mm_log (tmp,WARN);
  	    }
  	  }
  	  base->lock[0] = '\0';	/* give up on lock file */
  	}
! /* MAHOGANY: added next line: */
!         base->lock[0] = '\0';	/* give up on lock file */
!         
        case EEXIST:		/* file already exists */
  	break;			/* try again */
        default:			/* some other failure */
  	sprintf (tmp,"Mailbox vulnerable - error creating %.80s: %s",
  		 hitch,strerror (errno));
  	mm_log (tmp,WARN);	/* this is probably not good */
  	base->lock[0] = '\0';	/* don't use lock files */
  	break;
        }
  				/* if failed to make lock file and retry OK */
!     /* MAHOGANY: fixed following line: */
!     if ((ld < 0) && base->lock[0]) {
        if (!(i%15)) {		/* time to notify? */
  	sprintf (tmp,"Mailbox %.80s is locked, will override in %d seconds...",
  		 file,i);
  	mm_log (tmp,WARN);
        }
diff -c5 imap/c-client/ftl_unix.c bak/c-client.old/ftl_unix.c
*** imap/c-client/ftl_unix.c	Tue Aug 29 22:56:43 1995
--- bak/c-client.old/ftl_unix.c	Sat Mar  4 12:56:06 2000
***************
*** 35,46 ****
  
  
  /* Report a fatal error
   * Accepts: string to output
   */
- 
  void fatal (char *string)
  {
    mm_fatal (string);		/* pass up the string */
    syslog (LOG_ALERT,"IMAP toolkit crash: %.100s",string);
    abort ();			/* die horribly */
  }
--- 35,46 ----
  
  
  /* Report a fatal error
   * Accepts: string to output
   */
  void fatal (char *string)
  {
    mm_fatal (string);		/* pass up the string */
    syslog (LOG_ALERT,"IMAP toolkit crash: %.100s",string);
    abort ();			/* die horribly */
  }
+ 
diff -c5 imap/c-client/mh.c bak/c-client.old/mh.c
*** imap/c-client/mh.c	Tue Oct 19 11:39:51 1999
--- bak/c-client.old/mh.c	Sat Feb  5 19:06:57 2000
***************
*** 1034,1038 ****
--- 1034,1046 ----
    time_t tp[2];
    tp[0] = time (0);		/* atime is now */
    tp[1] = mail_longdate (elt);	/* modification time */
    utime (file,tp);		/* set the times */
  }
+ 
+ /*MAHOGANY: added */
+ /* Retrieve the MH path
+  *  */
+ extern char *mh_getpath(void)
+ {
+ 	  return mh_path;
+ }
*** imap/c-client/news.c	Thu Sep 30 22:02:43 1999
--- bak/c-client.old/news.c	Sat Apr 15 13:35:18 2000
***************
*** 101,117 ****
  DRIVER *news_valid (char *name)
  {
    int fd;
    char *s,*t,*u;
    struct stat sbuf;
    if ((name[0] == '#') && (name[1] == 'n') && (name[2] == 'e') &&
        (name[3] == 'w') && (name[4] == 's') && (name[5] == '.') &&
        !strchr (name,'/') &&
        !stat ((char *) mail_parameters (NIL,GET_NEWSSPOOL,NIL),&sbuf) &&
        ((fd = open ((char *) mail_parameters (NIL,GET_NEWSACTIVE,NIL),O_RDONLY,
  		   NIL)) >= 0)) {
!     fstat (fd,&sbuf);		/* get size of active file */
  				/* slurp in active file */
      read (fd,t = s = (char *) fs_get (sbuf.st_size+1),sbuf.st_size);
      s[sbuf.st_size] = '\0';	/* tie off file */
      close (fd);			/* flush file */
      while (*t && (u = strchr (t,' '))) {
--- 101,136 ----
  DRIVER *news_valid (char *name)
  {
    int fd;
    char *s,*t,*u;
    struct stat sbuf;
+   /*MAHOGANY: changed this to return &newsdriver if active file does
+     not exist*/
+   if ((name[0] == '#') && (name[1] == 'n') && (name[2] == 'e') &&
+       (name[3] == 'w') && (name[4] == 's') && (name[5] == '.') &&
+       !strchr (name,'/'))
+   {
+      if(stat ((char *) mail_parameters (NIL,GET_NEWSSPOOL,NIL),&sbuf)
+         != 0
+         || ((fd = open ((char *) mail_parameters
+                         (NIL,GET_NEWSACTIVE,NIL),O_RDONLY, 
+                      NIL)) == -1)) 
+      {
+         /* no active list file, so we cannot check properly */
+         return &newsdriver;
+      }
+      
+      /* original code: */
+ #if 0
    if ((name[0] == '#') && (name[1] == 'n') && (name[2] == 'e') &&
        (name[3] == 'w') && (name[4] == 's') && (name[5] == '.') &&
        !strchr (name,'/') &&
        !stat ((char *) mail_parameters (NIL,GET_NEWSSPOOL,NIL),&sbuf) &&
        ((fd = open ((char *) mail_parameters (NIL,GET_NEWSACTIVE,NIL),O_RDONLY,
  		   NIL)) >= 0)) {
! #endif
!      fstat (fd,&sbuf);		/* get size of active file */
  				/* slurp in active file */
      read (fd,t = s = (char *) fs_get (sbuf.st_size+1),sbuf.st_size);
      s[sbuf.st_size] = '\0';	/* tie off file */
      close (fd);			/* flush file */
      while (*t && (u = strchr (t,' '))) {
***************
*** 353,363 ****
      for (i = 0; i < nmsgs; ++i) {
        stream->uid_last = mail_elt (stream,i+1)->private.uid =
  	atoi (names[i]->d_name);
        fs_give ((void **) &names[i]);
      }
!     s = (void *) &names;	/* stupid language */
      fs_give ((void **) &s);	/* free directory */
      LOCAL->cachedtexts = 0;	/* no cached texts */
      stream->sequence++;		/* bump sequence number */
      stream->rdonly = stream->perm_deleted = T;
  				/* UIDs are always valid */
--- 372,385 ----
      for (i = 0; i < nmsgs; ++i) {
        stream->uid_last = mail_elt (stream,i+1)->private.uid =
  	atoi (names[i]->d_name);
        fs_give ((void **) &names[i]);
      }
!     /* MAHOGANY: removed "&" in front of names which IMHO was wrong!
!        (KB) */
!     s = (void *) names;	/* stupid language */
!     /* MAHOGANY end of change */
      fs_give ((void **) &s);	/* free directory */
      LOCAL->cachedtexts = 0;	/* no cached texts */
      stream->sequence++;		/* bump sequence number */
      stream->rdonly = stream->perm_deleted = T;
  				/* UIDs are always valid */
diff -c5 imap/c-client/pop3.c bak/c-client.old/pop3.c
*** imap/c-client/pop3.c	Fri Oct 29 05:34:50 1999
--- bak/c-client.old/pop3.c	Mon Mar 20 11:03:28 2000
***************
*** 592,602 ****
  {
    MESSAGECACHE *elt;
    if ((flags & FT_UID) && !(msgno = mail_msgno (stream,msgno))) return NIL;
  				/* have header text? */
    if (!(elt = mail_elt (stream,msgno))->private.msg.header.text.data) {
!     elt->private.msg.header.text.size = pop3_cache (stream,elt);
  				/* read the header */
      fread (elt->private.msg.header.text.data = (unsigned char *)
  	   fs_get ((size_t) elt->private.msg.header.text.size + 1),
  	   (size_t) 1,(size_t) elt->private.msg.header.text.size,LOCAL->txt);
      elt->private.msg.header.text.data[elt->private.msg.header.text.size] ='\0';
--- 592,602 ----
  {
    MESSAGECACHE *elt;
    if ((flags & FT_UID) && !(msgno = mail_msgno (stream,msgno))) return NIL;
  				/* have header text? */
    if (!(elt = mail_elt (stream,msgno))->private.msg.header.text.data) {
!     elt->private.msg.header.text.size = pop3_cache_header (stream,elt);
  				/* read the header */
      fread (elt->private.msg.header.text.data = (unsigned char *)
  	   fs_get ((size_t) elt->private.msg.header.text.size + 1),
  	   (size_t) 1,(size_t) elt->private.msg.header.text.size,LOCAL->txt);
      elt->private.msg.header.text.data[elt->private.msg.header.text.size] ='\0';
***************
*** 638,657 ****
   */
  
  unsigned long pop3_cache (MAILSTREAM *stream,MESSAGECACHE *elt)
  {
  				/* already cached? */
!   if (LOCAL->msgno != elt->msgno) {
  				/* no, close current file */
      if (LOCAL->txt) fclose (LOCAL->txt);
      LOCAL->txt = NIL;
      LOCAL->msgno = LOCAL->hdrsize = 0;
      if (pop3_send_num (stream,"RETR",elt->msgno)) {
        LOCAL->msgno = elt->msgno;/* set as current message number */
  				/* load the cache */
        LOCAL->txt = netmsg_slurp (LOCAL->netstream,&elt->rfc822_size,
  				 &LOCAL->hdrsize);
      }
      else elt->deleted = T;
    }
    return LOCAL->hdrsize;
  }
--- 638,688 ----
   */
  
  unsigned long pop3_cache (MAILSTREAM *stream,MESSAGECACHE *elt)
  {
  				/* already cached? */
!   if (LOCAL->msgno != elt->msgno || elt->rfc822_size == 1) {
  				/* no, close current file */
      if (LOCAL->txt) fclose (LOCAL->txt);
      LOCAL->txt = NIL;
      LOCAL->msgno = LOCAL->hdrsize = 0;
      if (pop3_send_num (stream,"RETR",elt->msgno)) {
        LOCAL->msgno = elt->msgno;/* set as current message number */
  				/* load the cache */
        LOCAL->txt = netmsg_slurp (LOCAL->netstream,&elt->rfc822_size,
  				 &LOCAL->hdrsize);
+     }
+     else elt->deleted = T;
+   }
+   return LOCAL->hdrsize;
+ }
+ 
+ /* POP3 cache message header only
+  * Accepts: mail stream
+  *	    message number
+  * Returns: header size
+  */
+ 
+ unsigned long pop3_cache_header (MAILSTREAM *stream,MESSAGECACHE *elt)
+ {
+ 				/* already cached? */
+   if (LOCAL->msgno != elt->msgno) {
+     char tmp[MAILTMPLEN];
+ 				/* no, close current file */
+     if (LOCAL->txt) fclose (LOCAL->txt);
+     LOCAL->txt = NIL;
+     LOCAL->msgno = LOCAL->hdrsize = 0;
+     sprintf (tmp,"%lu 0",mail_uid (stream,elt->msgno));
+     if (pop3_send (stream,"TOP",tmp)) {
+       LOCAL->msgno = elt->msgno;/* set as current message number */
+ 				/* load the cache */
+       LOCAL->txt = netmsg_slurp (LOCAL->netstream,&elt->rfc822_size,
+ 				 &LOCAL->hdrsize);
+       elt->rfc822_size = 1;
+       /* because we don't really know, but we want mail_fetch_structure
+ 	 to think that it has enough info without calling dtb->text */
+       /*printf("rfc822_size = %d\n", elt->rfc822_size);*/
      }
      else elt->deleted = T;
    }
    return LOCAL->hdrsize;
  }
diff -c5 imap/c-client/pop3.h bak/c-client.old/pop3.h
*** imap/c-client/pop3.h	Tue Oct 13 22:19:09 1998
--- bak/c-client.old/pop3.h	Sat Feb  5 19:07:01 2000
***************
*** 78,87 ****
--- 78,88 ----
  void pop3_fetchfast (MAILSTREAM *stream,char *sequence,long flags);
  char *pop3_header (MAILSTREAM *stream,unsigned long msgno,unsigned long *size,
  		   long flags);
  long pop3_text (MAILSTREAM *stream,unsigned long msgno,STRING *bs,long flags);
  unsigned long pop3_cache (MAILSTREAM *stream,MESSAGECACHE *elt);
+ unsigned long pop3_cache_header (MAILSTREAM *stream,MESSAGECACHE *elt);
  long pop3_ping (MAILSTREAM *stream);
  void pop3_check (MAILSTREAM *stream);
  void pop3_expunge (MAILSTREAM *stream);
  long pop3_copy (MAILSTREAM *stream,char *sequence,char *mailbox,long options);
  long pop3_append (MAILSTREAM *stream,char *mailbox,char *flags,char *date,
Only in imap/c-client: pop3.o
Only in imap/c-client: pseudo.o
diff -c5 imap/c-client/rfc822.c bak/c-client.old/rfc822.c
*** imap/c-client/rfc822.c	Tue Jul 13 16:14:32 1999
--- bak/c-client.old/rfc822.c	Thu Mar  9 18:12:47 2000
***************
*** 107,116 ****
--- 107,143 ----
   * Accepts: scratch buffer to write into
   *	    message envelope
   *	    message body
   */
  
+ /*MAHOGANY: BEGIN OF PATCH: added the next block */
+ static char **rfc822_extraheaders_names = NULL;
+ static char **rfc822_extraheaders_values = NULL;
+ 
+ void rfc822_setextraheaders(char **names, char **values)
+ {
+    if(names != NULL && rfc822_extraheaders_names != NULL)
+      fatal("rfc822_extraheaders_names attempted to set twice");
+    rfc822_extraheaders_names = names;
+    rfc822_extraheaders_values = values;
+ }
+ 
+ void rfc822_extraheaders_lines (char **header,ENVELOPE *env)
+ {
+    char **names = rfc822_extraheaders_names;
+    char **values = rfc822_extraheaders_values;
+    if(rfc822_extraheaders_names == NULL)
+       return;
+    while(names && *names && values && *values)
+       sprintf ((*header += strlen (*header)),"%s%s: %s\015\012",
+                env->remail ? "ReSent-" : "",
+                *(names++),
+                *(values++)
+          );
+ }
+ /*MAHOGANY: END OF PATCH */
+ 
  void rfc822_header (char *header,ENVELOPE *env,BODY *body)
  {
    if (env->remail) {		/* if remailing */
      long i = strlen (env->remail);
      strcpy (header,env->remail);/* start with remail header */
***************
*** 133,142 ****
--- 160,173 ----
   */
    rfc822_header_line (&header,"In-Reply-To",env,env->in_reply_to);
    rfc822_header_line (&header,"Message-ID",env,env->message_id);
    rfc822_header_line (&header,"Followup-to",env,env->followup_to);
    rfc822_header_line (&header,"References",env,env->references);
+ 
+ /*MAHOGANY: added this call:*/
+   rfc822_extraheaders_lines (&header,env);
+   
    if (body && !env->remail) {	/* not if remail or no body structure */
      strcat (header,"MIME-Version: 1.0\015\012");
      rfc822_write_body_header (&header,body);
    }
    strcat (header,"\015\012");	/* write terminating blank line */
***************
*** 202,217 ****
--- 233,259 ----
  	  strcat (dest,">");	/* closing delimiter */
  	}
  	if (adr->next && adr->next->mailbox) strcat (dest,", ");
        }
      }
+ 
+ /*MAHOGANY: commented out the following bit as it caused problems:*/
+ #if 0
+     /* commented out: */
      else if (adr->mailbox) {	/* start of group? */
  				/* yes, write group name */
        rfc822_cat (dest,adr->mailbox,rspecials);
        strcat (dest,": ");	/* write group identifier */
        n++;			/* in a group */
      }
+ #else
+     /* my replacement (KB): */
+     else if (adr->mailbox) {	/* start of group? */
+ 				/* yes, write group name */
+       rfc822_cat (dest,adr->mailbox,rspecials);
+     }
+ #endif
      else if (n) {		/* must be end of group (but be paranoid) */
        strcat (dest,";");
  				/* no longer in that group */
        if (!--n && adr->next && adr->next->mailbox) strcat (dest,", ");
      }
***************
*** 244,253 ****
--- 286,298 ----
      rfc822_cat (dest,adr->mailbox,wspecials);
      if (*adr->host != '@') {	/* unless null host (HIGHLY discouraged!) */
        strcat (dest,"@");	/* host delimiter */
        strcat (dest,adr->host);	/* write host name */
      }
+   }
+   else if(adr && adr->mailbox) {
+     rfc822_cat (dest,adr->mailbox,wspecials);
    }
  }
  
  
  /* Concatenate RFC822 string
diff -c5 imap/c-client/smtp.c bak/c-client.old/smtp.c
*** imap/c-client/smtp.c	Fri Oct 29 05:37:16 1999
--- bak/c-client.old/smtp.c	Fri Jun  2 16:17:19 2000
***************
*** 323,333 ****
    if (!(env->to || env->cc || env->bcc)) {
    				/* no recipients in request */
      smtp_fake (stream,SMTPHARDERROR,"No recipients specified");
      return NIL;
    }
!   smtp_send (stream,"RSET",NIL);/* make sure stream is in good shape */
    strcpy (tmp,"FROM:<");	/* compose "MAIL FROM:<return-path>" */
    if (env->return_path && env->return_path->host &&
        !((env->return_path->adl &&
  	 (strlen (env->return_path->adl) > SMTPMAXPATH)) ||
  	(strlen (env->return_path->mailbox) > SMTPMAXLOCALPART) ||
--- 323,338 ----
    if (!(env->to || env->cc || env->bcc)) {
    				/* no recipients in request */
      smtp_fake (stream,SMTPHARDERROR,"No recipients specified");
      return NIL;
    }
! /* MAHOGANY
!    BREAKS AUTHENTICATION FOR SOME SERVERS, WRONG BUT HELPFUL
!    smtp_send (stream,"RSET",NIL);
! */
!   /* make sure stream is in good shape */
!   
    strcpy (tmp,"FROM:<");	/* compose "MAIL FROM:<return-path>" */
    if (env->return_path && env->return_path->host &&
        !((env->return_path->adl &&
  	 (strlen (env->return_path->adl) > SMTPMAXPATH)) ||
  	(strlen (env->return_path->mailbox) > SMTPMAXLOCALPART) ||
***************
*** 345,355 ****
    if (env->to) smtp_rcpt (stream,env->to,&error);
    if (env->cc) smtp_rcpt (stream,env->cc,&error);
    if (env->bcc) smtp_rcpt (stream,env->bcc,&error);
    if (error) {			/* any recipients failed? */
        				/* reset the stream */
!     smtp_send (stream,"RSET",NIL);
      smtp_fake (stream,SMTPHARDERROR,"One or more recipients failed");
      return NIL;
    }
  				/* negotiate data command */
    if (!(smtp_send (stream,"DATA",NIL) == SMTPREADY)) return NIL;
--- 350,362 ----
    if (env->to) smtp_rcpt (stream,env->to,&error);
    if (env->cc) smtp_rcpt (stream,env->cc,&error);
    if (env->bcc) smtp_rcpt (stream,env->bcc,&error);
    if (error) {			/* any recipients failed? */
        				/* reset the stream */
!      /* MAHOGANY
!         breaks authentication
!         smtp_send (stream,"RSET",NIL); */
      smtp_fake (stream,SMTPHARDERROR,"One or more recipients failed");
      return NIL;
    }
  				/* negotiate data command */
    if (!(smtp_send (stream,"DATA",NIL) == SMTPREADY)) return NIL;
