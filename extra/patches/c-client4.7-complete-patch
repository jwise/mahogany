diff -c -N c-client.pure/.cvsignore c-client/.cvsignore
*** c-client.pure/.cvsignore	Thu Jan  1 01:00:00 1970
--- c-client/.cvsignore	Sat Feb  5 14:44:02 2000
***************
*** 0 ****
--- 1,9 ----
+ ARCHIVE
+ CCTYPE
+ CFLAGS
+ LDFLAGS
+ OSCFLAGS
+ auths.c
+ linkage.c
+ linkage.h
+ osdep.c
diff -c -N c-client.pure/ARCHIVE c-client/ARCHIVE
*** c-client.pure/ARCHIVE	Thu Jan  1 01:00:00 1970
--- c-client/ARCHIVE	Sat Feb  5 16:56:55 2000
***************
*** 0 ****
--- 1 ----
+ ar rc c-client.a mail.o misc.o newsrc.o smanager.o osdep.o utf8.o siglocal.o dummy.o pseudo.o netmsg.o flstring.o fdstring.o rfc822.o nntp.o smtp.o imap4r1.o pop3.o unix.o mbox.o mbx.o mmdf.o tenex.o mtx.o news.o phile.o mh.o mx.o;ranlib c-client.a
diff -c -N c-client.pure/CCTYPE c-client/CCTYPE
*** c-client.pure/CCTYPE	Thu Jan  1 01:00:00 1970
--- c-client/CCTYPE	Sat Feb  5 16:56:55 2000
***************
*** 0 ****
--- 1 ----
+ cc
diff -c -N c-client.pure/CFLAGS c-client/CFLAGS
*** c-client.pure/CFLAGS	Thu Jan  1 01:00:00 1970
--- c-client/CFLAGS	Sat Feb  5 16:56:55 2000
***************
*** 0 ****
--- 1 ----
+ -g -fno-omit-frame-pointer -O6 -DNFSKLUDGE -DNO_IDEA
Common subdirectories: c-client.pure/CVS and c-client/CVS
diff -c -N c-client.pure/LDFLAGS c-client/LDFLAGS
*** c-client.pure/LDFLAGS	Thu Jan  1 01:00:00 1970
--- c-client/LDFLAGS	Sat Feb  5 16:56:55 2000
***************
*** 0 ****
--- 1 ----
+ -lcrypt
diff -c -N c-client.pure/Makefile c-client/Makefile
*** c-client.pure/Makefile	Thu Jan  1 01:00:00 1970
--- c-client/Makefile	Sat Feb  5 15:08:10 2000
***************
*** 0 ****
--- 1,26 ----
+ # Makefile for extra/src/c-client directory
+ # $Id$
+ 
+ CWD = extra/src/c-client
+ CSRC = mail.c misc.c
+ 
+ TARGETS = $(CSRC:.c=.o)
+ 
+ MAKE:=`echo $(MAKE) -f Makefile.ccl | sed "1,1 s/-j[ 0-9]*//g"` # strip off any -j arguments
+ 
+ all:
+ 	echo $(CCLIENTOSTYPE) >../OSTYPE
+ 	echo $(CC) >CCTYPE
+ 	$(MAKE) $(CCLIENTOSTYPE) $(CCLIENT_EXTRAAUTHENTICATORS) $(CCLIENT_EXTRACFLAGS)
+ 
+ include ../../../makerules
+ 
+ clean:
+ 	$(MAKE) clean
+ 
+ doc:
+ 	@echo
+ dep depend:
+ 	touch osdep.h linkage.h # dummy files to suppress warnings
+ 
+ include ../../../makeopts
diff -c -N c-client.pure/Makefile.ccl c-client/Makefile.ccl
*** c-client.pure/Makefile.ccl	Thu Jan  1 01:00:00 1970
--- c-client/Makefile.ccl	Sat Feb  5 15:08:30 2000
***************
*** 0 ****
--- 1,757 ----
+ # Program:	C client makefile
+ #
+ # Author:	Mark Crispin
+ #		Networks and Distributed Computing
+ #		Computing & Communications
+ #		University of Washington
+ #		Administration Building, AG-44
+ #		Seattle, WA  98195
+ #		Internet: MRC@CAC.Washington.EDU
+ #
+ # Date:		11 May 1989
+ # Last Edited:	16 November 1999
+ #
+ # Copyright 1999 by the University of Washington
+ #
+ #  Permission to use, copy, modify, and distribute this software and its
+ # documentation for any purpose and without fee is hereby granted, provided
+ # that the above copyright notice appears in all copies and that both the
+ # above copyright notice and this permission notice appear in supporting
+ # documentation, and that the name of the University of Washington not be
+ # used in advertising or publicity pertaining to distribution of the software
+ # without specific, written prior permission.  This software is made
+ # available "as is", and
+ # THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+ # WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+ # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+ # NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+ # INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+ # LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+ # (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+ # WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ 
+ 
+ # Command line build parameters
+ 
+ EXTRAAUTHENTICATORS=
+ SPECIALAUTHENTICATORS=
+ EXTRADRIVERS=mbox
+ PASSWDTYPE=std
+ 
+ 
+ # Extended flags needed for non-standard passwd types.  You may need to modify.
+ 
+ AFSDIR=/usr/afsws
+ AFSCFLAGS=-Dexit=afs_exit -D_exit=_afs_exit -I$(AFSDIR)/include
+ AFSLIB=$(AFSDIR)/lib
+ AFSLDFLAGS=-L$(AFSLIB)/afs -L$(AFSLIB) -L$(AFSDIR)/domestic/lib\
+  -lkauth -lprot -lubik -lauth -lrxkad -lrx -llwp -ldes -lcom_err\
+  $(AFSLIB)/afs/util.a -laudit -lsys
+ # AFSLDFLAGS may also need -L/usr/ucblib -lucb
+ DCECFLAGS= -DDCE_MINIMAL -DPASSWD_OVERRIDE=\"/opt/pop3/passwd/passwd\"
+ DCELDFLAGS= -ldce
+ PAMLDFLAGS= -lpam -ldl
+ 
+ 
+ # Build parameters normally set by the individual port
+ 
+ CHECKPW=std
+ LOGINPW=std
+ SIGTYPE=bsd
+ ACTIVEFILE=/usr/lib/news/active
+ SPOOLDIR=/usr/spool
+ MAILSPOOL=$(SPOOLDIR)/mail
+ NEWSSPOOL=$(SPOOLDIR)/news
+ RSHPATH=/usr/ucb/rsh
+ LOCKPGM=/etc/mlock
+ 
+ 
+ # Default formats for creating new mailboxes and for empty mailboxes in the
+ # default namespace; must be set to the associated driver's prototype.
+ #
+ # The CREATEPROTO is the default format for new mailbox creation.
+ # The EMPTYPROTO is the default format for handling zero-byte files.
+ #
+ # Normally, this is set by the individual port.
+ #
+ # NOTE: namespace formats (e.g. mh and news) can not be set as a default format
+ # since they do not exist in the default namespace.  Also, it is meaningless to
+ # set certain other formats (e.g. mbx and mx) as the EMPTYPROTO since these
+ # formats can never be empty files.
+ 
+ CREATEPROTO=unixproto
+ EMPTYPROTO=unixproto
+ 
+ 
+ # Commands possibly overriden by the individual port
+ 
+ ARRC=ar rc
+ CC=cc
+ LN=ln -s
+ RANLIB=ranlib
+ 
+ 
+ # Standard distribution build parameters
+ 
+ DEFAULTAUTHENTICATORS=md5 $(SPECIALAUTHENTICATORS) log
+ DEFAULTDRIVERS=imap nntp pop3 mh mx mbx tenex mtx mmdf unix news phile
+ 
+ 
+ # Normally no need to change any of these
+ 
+ ARCHIVE=c-client.a
+ BINARIES=mail.o misc.o newsrc.o smanager.o osdep.o utf8.o siglocal.o \
+  dummy.o pseudo.o netmsg.o flstring.o fdstring.o \
+  rfc822.o nntp.o smtp.o imap4r1.o pop3.o \
+  unix.o mbox.o mbx.o mmdf.o tenex.o mtx.o news.o phile.o mh.o mx.o
+ CFLAGS=$(BASECFLAGS) $(EXTRACFLAGS)
+ MV=mv
+ RM=rm -rf
+ SH=sh
+ 
+ 
+ # Primary build command
+ 
+ BUILDOPTIONS= EXTRACFLAGS="$(EXTRACFLAGS)"\
+  EXTRALDFLAGS="$(EXTRALDFLAGS)"\
+  EXTRADRIVERS="$(EXTRADRIVERS)" EXTRAAUTHENTICATORS="$(EXTRAAUTHENTICATORS)"\
+  PASSWDTYPE=$(PASSWDTYPE) SPECIALAUTHENTICATORS="$(SPECIALAUTHENTICATORS)"
+ BUILD=$(MAKE) build $(BUILDOPTIONS)
+ 
+ # Here if no make argument established
+ 
+ missing: osdep.h
+ 	$(MAKE) all CC=`cat CCTYPE` CFLAGS="`cat CFLAGS`" `cat EXTRASPECIALS`
+ 
+ osdep.h:
+ 	@echo You must specify what type of system
+ 	@false
+ 
+ 
+ # Current ports
+ 
+ a32:	# AIX 3.2 for RS/6000
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx \
+ 	 SPOOLDIR=/var/spool \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -Dunix=1 -D_BSD -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lbsd"
+ 
+ a41:	# AIX 4.1 for RS/6000
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=a41 \
+ 	 SPOOLDIR=/var/spool \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -Dunix=1 -D_BSD -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lbsd -ls"
+ 
+ aix:	# AIX/370
+ 	@echo You are building for AIX on an S/370 class machine
+ 	@echo If you want AIX on an RS/6000 you need to use a32 or a41 instead!
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lbsd"
+ 
+ aos:	# AOS for RT
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE"
+ 
+ art:	# AIX 2.2.1 for RT
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 \
+ 	 SPOOLDIR=/var \
+ 	 ACTIVEFILE=/usr/local/news/control/active \
+ 	 RSHPATH=/bin/rsh \
+ 	 BASECFLAGS="-g -Dconst= -Dvoid=char" \
+ 	 RANLIB=true 
+ 
+ asv:	# Altos SVR4
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 LOGINPW=old \
+ 	 ACTIVEFILE=/usr/spool/news/active \
+ 	 RSHPATH=/usr/bin/rcmd \
+ 	 BASECFLAGS="-Dconst= -DSIGSTOP=SIGKILL" \
+ 	 BASELDFLAGS="-lsocket -lrpc -lgen -lcrypt -lxenix" \
+ 	 RANLIB=true
+ 
+ aux:	# A/UX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 MAILSPOOL=/usr/mail \
+ 	 BASECFLAGS="-g -B/usr/lib/big/ -Dvoid=char -Dconst= -DNFSKLUDGE" \
+ 	 RANLIB=true ARRC="ar -rc"
+ 
+ bs3:	# BSD/i386 3.0 or higher
+ 	$(BUILD) `cat EXTRASPECIALS` OS=bsi CHECKPW=bsi LOGINPW=bsi \
+ 	 SPOOLDIR=/var NEWSSPOOL=/var/news/spool \
+ 	 ACTIVEFILE=/var/news/etc/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O2 -pipe -DNFSKLUDGE" CC=shlicc
+ 
+ bsd:	# BSD UNIX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE"
+ 
+ bsf:	# FreeBSD
+ 	$(BUILD) `cat EXTRASPECIALS` OS=bsi SIGTYPE=psx \
+ 	 SPOOLDIR=/var \
+ 	 ACTIVEFILE=/usr/local/news/lib/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O -pipe -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lcrypt"
+ 
+ bsi:	# BSD/i386
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 SPOOLDIR=/var NEWSSPOOL=/var/news/spool \
+ 	 ACTIVEFILE=/var/news/etc/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O2 -pipe -DNFSKLUDGE"
+ 
+ bso:	# OpenBSD
+ 	$(BUILD) `cat EXTRASPECIALS` OS=bsi SIGTYPE=psx \
+ 	 SPOOLDIR=/var \
+ 	 ACTIVEFILE=/usr/local/news/lib/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-O2 -pipe -DNFSKLUDGE"
+ 
+ cvx:	# Convex
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-O -ext -Dconst= -DNFDKLUDGE"
+ 
+ d-g:	# Data General DG/UX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/local/news/active \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lnsl -lsocket" \
+ 	 RANLIB=true
+ 
+ d54:	# Data General DG/UX 5.4
+ 	$(BUILD) `cat EXTRASPECIALS` OS=d-g SIGTYPE=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/local/news/active \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lnsl -lsocket" \
+ 	 RANLIB=true
+ 
+ dpx:	# Bull DPX/2
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sv4 SIGTYPE=sv4 CHECKPW=sv4 LOGINPW=sv4 \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-Dconst= -DSYSTEM5 -DSHORT_IDENT" \
+ 	 BASELDFLAGS="-linet" \
+ 	 RANLIB=true LN=ln
+ 
+ drs:	# ICL DRS/NX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 CHECKPW=sv4 LOGINPW=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-O -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lsocket -lgen" \
+ 	 RANLIB=true
+ 
+ do4:	# Apollo Domain/OS sr10.4
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-DNFSKLUDGE -A systype,bsd4.3 -D_APOLLO_SOURCE" \
+ 	 RANLIB=true
+ 
+ dyn:	# Dynix
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE"
+ 
+ epx:	# EP/IX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sv4 SIGTYPE=sv4 CHECKPW=sv4 LOGINPW=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/usr/share/news/active \
+ 	 RSHPATH=/usr/net/rsh \
+ 	 BASECFLAGS="-g -systype svr4" \
+ 	 BASELDFLAGS="-lsocket -lnsl -lgen" \
+ 	 RANLIB=true
+ 
+ gas:	# GCC Altos SVR4
+ 	$(BUILD) `cat EXTRASPECIALS` OS=asv SIGTYPE=sv4 LOGINPW=old \
+ 	 ACTIVEFILE=/usr/spool/news/active \
+ 	 RSHPATH=/usr/bin/rcmd \
+ 	 BASECFLAGS="-g -O -DALTOS_SYSTEM_V -DSIGSTOP=SIGKILL" \
+ 	 BASELDFLAGS="-lsocket -lrpc -lgen -lcrypt -lxenix" \
+ 	 RANLIB=true CC=gcc
+ 
+ gh9:	# GCC HP-UX9.x
+ 	$(BUILD) `cat EXTRASPECIALS` OS=hpp SIGTYPE=psx \
+ 	 MAILSPOOL=/usr/mail \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-O2 -DNFSKLUDGE" \
+ 	 RANLIB=true CC=gcc
+ 
+ ghp:	# GCC HP-UX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=hpp SIGTYPE=psx \
+ 	 SPOOLDIR=/var \
+ 	 ACTIVEFILE=/var/news/active \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-O2 -DNFSKLUDGE" \
+ 	 RANLIB=true CC=gcc
+ 
+ gs5:	# GCC 2.7.1 (95q4) SCO Open Server 5.0.x
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sc5 SIGTYPE=psx CHECKPW=sec LOGINPW=sec \
+ 	 CREATEPROTO=mmdfproto EMPTYPROTO=mmdfproto \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rcmd \
+ 	 BASECFLAGS="-O3 -belf -I/usr/include -L/lib" \
+ 	 BASELDFLAGS="-lsocket -lcrypt -lprot -lx -ltinfo -lm" \
+ 	 RANLIB=true
+ 
+ gso:	# GCC Solaris
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sol SIGTYPE=psx CHECKPW=psx \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/usr/share/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O2 -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lsocket -lnsl -lgen" \
+ 	 RANLIB=true CC=gcc
+ 
+ gsu:	# GCC SUN-OS
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sun \
+ 	 BASECFLAGS="-O2 -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-ldl" \
+ 	 CC=gcc
+ 
+ gul:	# GCC Ultrix
+ 	$(BUILD) `cat EXTRASPECIALS` OS=ult SIGTYPE=psx CHECKPW=ult \
+ 	 BASECFLAGS="-g -O -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lauth -lc" \
+ 	 CC=gcc
+ 
+ hpp:	# HP-UX 9.x
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx \
+ 	 MAILSPOOL=/usr/mail \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-g -Aa -D_HPUX_SOURCE -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lnet -lV3" \
+ 	 RANLIB=true
+ 
+ hpx:	# HP-UX 10.x
+ 	$(BUILD) `cat EXTRASPECIALS` OS=hpp SIGTYPE=psx \
+ 	 SPOOLDIR=/var \
+ 	 ACTIVEFILE=/var/news/active \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-g -Ae -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lnet -lV3" \
+ 	 RANLIB=true
+ 
+ isc:	# Interactive
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 CHECKPW=sv4 LOGINPW=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/var/spool/news/active \
+ 	 BASECFLAGS="-Xp -D_SYSV3" \
+ 	 BASELDFLAGS="-linet -lnsl_s -lgen -lx -lsec -liberty" \
+ 	 RANLIB=true
+ 
+ lnp:	# Linux Pluggable Authentication modules
+ 	$(BUILD) `cat EXTRASPECIALS` OS=lnx SIGTYPE=psx CHECKPW=pam \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -fno-omit-frame-pointer -O6 -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lpam -ldl"
+ 
+ lnx:	# Linux non-shadow passwords
+ 	@echo You are building for traditional Linux *without* shadow
+ 	@echo passwords and with the crypt function in the C library.
+ 	@echo If your system has shadow passwords, or if crypt is not
+ 	@echo in the C library, you must use slx, sl4, or sl5 instead!
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O -DNFSKLUDGE"
+ 
+ lyn:	# LynxOS
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 RSHPATH=/bin/rsh \
+ 	 BASECFLAGS="-g -O -pipe -DNFSKLUDGE" \
+ 	 BASELDFLAGS=-lbsd \
+ 	 CC=gcc
+ 
+ mct:	# MachTen - NFSKLUDGE doesn't work (at least not on 2.2)
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 SPOOLDIR=/var/spool \
+ 	 BASECFLAGS="-g -O -pipe"
+ 
+ mnt:	# Mint
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O -DNFSKLUDGE"
+ 
+ neb:	# NetBSD
+ 	$(BUILD) `cat EXTRASPECIALS` OS=bsi \
+ 	 SPOOLDIR=/var \
+ 	 ACTIVEFILE=/var/db/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O -pipe -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lcrypt"
+ 
+ nxt:	# NEXTSTEP
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -O -pipe -DNFSKLUDGE"
+ 
+ nx3:	# NEXTSTEP 3.0 single threaded
+ 	$(BUILD) `cat EXTRASPECIALS` OS=nxt \
+ 	 BASECFLAGS="-g -O -pipe -DNFSKLUDGE -Wall"
+ 	echo "void malloc_singlethreaded (void);" >> linkage.h
+ 	echo "  malloc_singlethreaded ();" >> linkage.c
+ 
+ osf:	# OSF/1
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx \
+ 	 BASECFLAGS="-g3 -O2 -Olimit 1500 -DNFSKLUDGE"
+ 
+ # Note: sia_become_user() used by LOGINPW=os4 doesn't seem to work right.  The
+ # user doesn't get proper file access, and the process can't be killed.
+ 
+ os4:	# OSF/1 (Digital UNIX) 4
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=os4 LOGINPW=os4 \
+ 	 BASECFLAGS="-g3 -O2 -Olimit 1500 -DNFSKLUDGE"
+ 
+ ptx:	# PTX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=svo LOGINPW=sv4 \
+ 	 MAILSPOOL=/usr/mail \
+ 	 RSHPATH=/usr/bin/resh \
+ 	 BASECFLAGS="-Wc,-O3 -Wc,-seq -Dprivate=PRIVATE -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lseq -lsec -lsocket -linet -lnsl -lgen" \
+ 	 RANLIB=true
+ 
+ pyr:	# Pyramid
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE"
+ 
+ qnx:	# QNX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ CHECKPW=psx LOGINPW=old \
+ 	 RSHPATH=/usr/ucb/rsh \
+ 	 BASECFLAGS="-Otax -g -Dunix=1 -D_POSIX_SOURCE" \
+ 	 BASELDFLAGS="-g -N128k -llogin -lsocket -lunix"
+ 
+ s40:	# SUN-OS 4.0
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE"
+ 
+ sc5:	# SCO Open Server 5.0
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=sec LOGINPW=sec \
+ 	 CREATEPROTO=mmdfproto EMPTYPROTO=mmdfproto \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rcmd \
+ 	 BASECFLAGS="-O3 -s" \
+ 	 BASELDFLAGS="-lsocket -lcrypt -lprot -lx -ltinfo -lm" \
+ 	 RANLIB=true
+ 
+ sco:	# Santa Cruz Operation
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 CHECKPW=sec LOGINPW=sec \
+ 	 CREATEPROTO=mmdfproto EMPTYPROTO=mmdfproto \
+ 	 RSHPATH=/usr/bin/rcmd \
+ 	 BASECFLAGS="-O3" \
+ 	 BASELDFLAGS="-lsocket -lprot -lcrypt_i -lx -los" \
+ 	 RANLIB=true LN=ln
+ 
+ # Notes:
+ # 1) setting _POSIX_SOURCE doesn't seem to build it as of SGI IRIX 5.3
+ # 2) SGI make wouldn't build for Steve unless that bizarre "MAKEFLAGS="
+ #    was inserted in the beginning.
+ 
+ sgi:	# Silicon Graphics
+ 	MAKEFLAGS= $(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 \
+ 	 MAILSPOOL=/usr/mail \
+ 	 RSHPATH=/usr/bsd/rsh \
+ 	 BASECFLAGS="-g3 -O2 -Olimit 8192 -DNFSKLUDGE" \
+ 	 RANLIB=true
+ 
+ sg6:	# Silicon Graphics, IRIX 6.5
+ 	MAKEFLAGS= $(BUILD) `cat EXTRASPECIALS` OS=sgi SIGTYPE=sv4 \
+ 	 MAILSPOOL=/usr/mail \
+ 	 RSHPATH=/usr/bsd/rsh \
+ 	 BASECFLAGS="-g3 -O2 -DNFSKLUDGE -woff 1048,1110,1116" \
+ 	 RANLIB=true
+ 
+ # Note: Mark Kaesling says that setluid() isn't in HP-UX with SecureWare.
+ 
+ shp:	# HP-UX with Trusted Computer Base
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=sec LOGINPW=std \
+ 	 SPOOLDIR=/var \
+ 	 ACTIVEFILE=/var/news/active \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-g -Ae -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lnet -lV3 -lsec" \
+ 	 RANLIB=true
+ 
+ slx:	# Secure Linux
+ 	@echo You are building for libc6/glibc versions of Secure Linux
+ 	@echo If you want libc5 versions you must use sl5 instead!
+ 	@echo If you want libc4 versions you must use sl4 instead!
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=psx \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -fno-omit-frame-pointer -O6 -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lcrypt"
+ 
+ sl4:	# Secure Linux using libc4
+ 	@echo You are building for libc4 versions of Secure Linux
+ 	@echo If you want libc6/glibc versions you must use slx instead!
+ 	@echo If you want libc5 versions you must use sl5 instead!
+ 	$(BUILD) `cat EXTRASPECIALS` OS=slx SIGTYPE=psx CHECKPW=psx \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -fno-omit-frame-pointer -O6 -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lshadow"
+ 
+ sl5:	# Secure Linux using libc5
+ 	@echo You are building for libc5 versions of Secure Linux
+ 	@echo If you want libc6/glibc versions you must use slx instead!
+ 	@echo If you want libc4 versions you must use sl4 instead!
+ 	$(BUILD) `cat EXTRASPECIALS` OS=slx SIGTYPE=psx CHECKPW=psx \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -fno-omit-frame-pointer -O6 -DNFSKLUDGE"
+ 
+ snx:	# Siemens Nixdorf SINIX and Reliant UNIX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sv4 SIGTYPE=psx CHECKPW=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/usr/share/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -D_SYS_CLOCK_H -Dconst=" \
+ 	 BASELDFLAGS="-lsocket -lnsl -lgen" \
+ 	 RANLIB=true
+ 
+ # Note: It is a long and disgusting story about why cc is set to ucbcc.  You
+ # need to invoke the C compiler so that it links with the SVR4 libraries and
+ # not the BSD libraries, otherwise readdir() will return the wrong information.
+ # Of all the names in the most common path, ucbcc is the only name to be found
+ # (on /usr/ccs/bin) that points to a suitable compiler.  cc is likely to be
+ # /usr/ucb/cc which is absolutely not the compiler that you want.  The real
+ # SVR4 cc is probably something like /opt/SUNWspro/bin/cc which is rarely in
+ # anyone's path.
+ #
+ # ucbcc is probably a link to acc, e.g. /opt/SUNWspro/SC4.0/bin/acc, and is
+ # the UCB C compiler using the SVR4 libraries.
+ #
+ # If ucbcc isn't on your system, then punt on the SUN C compiler and use gcc
+ # instead (the gso port instead of the sol port).
+ # 
+ # If, in spite of all the above warnings, you choose to change "ucbcc" to "cc",
+ # you will probably find that the -O2 needs to be changed to -O.  If you don't
+ # get any error messages with -O2, that's a pretty good indicator that you
+ # goofed and are running the compiler that will link with the BSD libraries.
+ #
+ # To recap:
+ # 1) The sol port is designed to be built using the UCB compiler using the
+ #    SVR4 libraries.  This compiler is "ucbcc", which is lunk to acc.  You
+ #    use -O2 as one of the CFLAGS.
+ # 2) If you build the sol port with the UCB compiler using the BSD libraries,
+ #    you will get no error messages but you will get bad binaries (the most
+ #    obvious symptom is dropping the first two characters return filenames
+ #    from the imapd LIST command.  This compiler also uses -O2, and is very
+ #    often what the user gets from "cc".  BEWARE!!!
+ # 3) If you build the sol port with the real SVR4 compiler, which is often
+ #    hidden away or unavailable on many systems, then you will get errors
+ #    from -O2 and you need to change that to -O.  But you will get a good
+ #    binary.  However, you should try it with -O2 first, to make sure that
+ #    you got this compiler and not the UCB compiler using BSD libraries.
+ 
+ sol:	# Solaris
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=psx \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/usr/share/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O2 -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lsocket -lnsl -lgen" \
+ 	 RANLIB=true CC=ucbcc
+ 
+ sos:	# Secure OSF/1
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=sec LOGINPW=sec \
+ 	 BASECFLAGS="-g3 -O2 -Olimit 1500 -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lsecurity -laud"
+ 
+ ssn:	# Secure SUN-OS
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sun CHECKPW=ssn \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-ldl"
+ 
+ sun:	# SUN-OS
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-ldl"
+ 
+ sv2:	# SVR2
+ 	@echo You are being *very* optimistic!
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 LOGINPW=old \
+ 	 MAILSPOOL=/usr/mail \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-Dconst= -DSYSTEM5 -DSHORT_IDENT -I/usr/ethernet/include" \
+ 	 BASELDFLAGS="-lnet" \
+ 	 RANLIB=true LN=ln
+ 
+ sv4:	# SVR4
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 CHECKPW=sv4 LOGINPW=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/usr/share/news/active \
+ 	 RSHPATH=/usr/bin/resh \
+ 	 BASECFLAGS="-g -Dconst=" \
+ 	 BASELDFLAGS="-lsocket -lnsl -lgen" \
+ 	 RANLIB=true
+ 
+ ult:	# Ultrix
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=ult \
+ 	 BASECFLAGS="-g3 -O2 -Olimit 1500 -Dconst= -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lauth -lc"
+ 
+ uw2:	# UnixWare SVR4.2
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sv4 SIGTYPE=sv4 CHECKPW=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/var/news/lib/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g" \
+ 	 BASELDFLAGS="-lsocket -lnsl -lgen" \
+ 	 RANLIB=true
+ 
+ vul:	# VAX Ultrix
+ 	$(BUILD) `cat EXTRASPECIALS` OS=ult SIGTYPE=psx CHECKPW=ult \
+ 	 BASECFLAGS="-O2 -Dconst= -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lauth -lc"
+ 
+ vu2:	# VAX Ultrix 2.3, etc.
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-O2 -Dconst= -Dvoid=char -DNFSKLUDGE"
+ 
+ 
+ # Build it!
+ 
+ build:	clean once $(ARCHIVE)
+ 
+ all:	$(ARCHIVE)
+ 
+ $(ARCHIVE): $(BINARIES)
+ 	sh -c '$(RM) $(ARCHIVE) || true'
+ 	@cat ARCHIVE
+ 	@$(SH) ARCHIVE
+ 
+ # Cleanup
+ 
+ clean:
+ 	sh -c '$(RM) auths.c flockbsd.c linkage.[ch] siglocal.c osdep*.[ch] *.o ARCHIVE *FLAGS *TYPE $(ARCHIVE) || true'
+ 
+ 
+ # Dependencies
+ 
+ dummy.o: mail.h misc.h osdep.h dummy.h
+ fdstring.o: mail.h misc.h osdep.h fdstring.h
+ flstring.o: mail.h misc.h osdep.h flstring.h
+ imap4r1.o: mail.h misc.h osdep.h imap4r1.h rfc822.h
+ mail.o: mail.h misc.h osdep.h rfc822.h linkage.h
+ mbox.o: mail.h misc.h osdep.h mbox.h unix.h
+ mbx.o: mail.h misc.h osdep.h mbx.h dummy.h
+ mh.o: mail.h misc.h osdep.h mh.h dummy.h
+ mx.o: mail.h misc.h osdep.h mx.h dummy.h
+ misc.o: mail.h misc.h osdep.h
+ mmdf.o: mail.h misc.h osdep.h mmdf.h pseudo.h dummy.h
+ mtx.o: mail.h misc.h osdep.h mtx.h dummy.h
+ netmsg.o: mail.h misc.h osdep.h netmsg.h
+ news.o: mail.h misc.h osdep.h news.h
+ newsrc.o: mail.h misc.h osdep.h newsrc.h
+ nntp.o: mail.h misc.h osdep.h netmsg.h smtp.h nntp.h rfc822.h
+ phile.o: mail.h misc.h osdep.h phile.h rfc822.h dummy.h
+ pseudo.o: pseudo.h
+ pop3.o: mail.h misc.h osdep.h pop3.h rfc822.h
+ smanager.o: mail.h misc.h osdep.h
+ smtp.o: mail.h misc.h osdep.h smtp.h rfc822.h
+ rfc822.o: mail.h misc.h osdep.h rfc822.h
+ tenex.o: mail.h misc.h osdep.h tenex.h dummy.h
+ unix.o: mail.h misc.h osdep.h unix.h pseudo.h dummy.h
+ utf8.o: mail.h misc.h osdep.h utf8.h
+ 
+ 
+ # OS-dependent
+ 
+ osdep.o:mail.h misc.h env.h fs.h ftl.h nl.h tcp.h \
+ 	osdep.h env_unix.h tcp_unix.h \
+ 	osdep.c env_unix.c fs_unix.c ftl_unix.c nl_unix.c tcp_unix.c \
+ 	auths.c flock.c flockbsd.c flcksafe.c fsync.c gethstid.c \
+ 	gr_wait.c gr_wait4.c gr_waitp.c \
+ 	auth_log.c auth_md5.c \
+ 	scandir.c setpgrp.c strerror.c truncate.c write.c \
+ 	memmove.c memmove2.c memset.c \
+ 	tz_bsd.c tz_nul.c tz_sv4.c \
+ 	write.c \
+ 	strerror.c strpbrk.c strstr.c strtok.c strtoul.c \
+ 	OSCFLAGS
+ 	$(CC) $(CFLAGS) `cat OSCFLAGS` -c osdep.c
+ 
+ osdep.c: osdepbas.c osdepckp.c osdeplog.c
+ 	cat osdepbas.c osdepckp.c osdeplog.c > osdep.c
+ 
+ flockbsd.c:	# cretin Linux
+ 
+ siglocal.c:	# cretin Linux
+ 
+ 
+ # Once-only environment setup
+ 
+ once:	onceenv ckp$(PASSWDTYPE) osdep.c 
+ 
+ onceenv:
+ 	@echo Once-only environment setup...
+ 	echo $(CC) > CCTYPE
+ 	echo $(CFLAGS) > CFLAGS
+ 	echo -DCREATEPROTO=$(CREATEPROTO) -DEMPTYPROTO=$(EMPTYPROTO) \
+ 	 -DMAILSPOOL=\"$(MAILSPOOL)\" \
+ 	 -DANONYMOUSHOME=\"$(MAILSPOOL)/anonymous\" \
+ 	 -DACTIVEFILE=\"$(ACTIVEFILE)\" -DNEWSSPOOL=\"$(NEWSSPOOL)\" \
+ 	 -DRSHPATH=\"$(RSHPATH)\" -DLOCKPGM=\"$(LOCKPGM)\" > OSCFLAGS
+ 	echo $(BASELDFLAGS) $(EXTRALDFLAGS) > LDFLAGS
+ 	echo "$(ARRC) $(ARCHIVE) $(BINARIES);$(RANLIB) $(ARCHIVE)" > ARCHIVE
+ 	./drivers $(EXTRADRIVERS) $(DEFAULTDRIVERS) dummy
+ 	./mkauths $(EXTRAAUTHENTICATORS) $(DEFAULTAUTHENTICATORS)
+ 	$(LN) os_$(OS).h osdep.h
+ 	$(LN) os_$(OS).c osdepbas.c
+ 	$(LN) log_$(LOGINPW).c osdeplog.c
+ 	$(LN) sig_$(SIGTYPE).c siglocal.c
+ 	sh -c '(test -f /usr/include/sys/statvfs.h -a $(OS) != sc5 -a $(OS) != sco) && $(LN) flocksun.c flockbsd.c || $(LN) flocksv4.c flockbsd.c'
+ 
+ # Password checkers
+ 
+ ckpafs:	# AFS
+ 	echo $(AFSCFLAGS) >> OSCFLAGS
+ 	echo $(AFSLDFLAGS) >> LDFLAGS
+ 	$(LN) ckp_afs.c osdepckp.c
+ 
+ ckpdce:	# DCE
+ 	echo $(DCECFLAGS) >> OSCFLAGS
+ 	echo $(DCELDFLAGS) >> LDFLAGS
+ 	$(LN) ckp_dce.c osdepckp.c
+ 
+ ckpkrb:	# Kerberos IV (must have krb EXTRAAUTHENTICATOR as well)
+ 	$(LN) ckp_krb.c osdepckp.c
+ 
+ ckpmd5:	# MD5 database (must have md5 AUTHENTICATOR as well)
+ 	$(LN) ckp_md5.c osdepckp.c
+ 
+ ckpnul:	# NUL authenticator (disables all plaintext authentication)
+ 	echo -DPLAINTEXT_DISABLED >> OSCFLAGS
+ 	$(LN) ckp_nul.c osdepckp.c
+ 
+ ckppam:	# Pluggable Authentication Modules authenticator
+ 	echo $(PAMLDFLAGS) >> LDFLAGS
+ 	$(LN) ckp_pam.c osdepckp.c
+ 
+ ckppmb:	# Broken (e.g. SUN) Pluggable Authentication Modules authenticator
+ 	echo $(PAMLDFLAGS) >> LDFLAGS
+ 	$(LN) ckp_pmb.c osdepckp.c
+ 
+ ckpstd:	# Port standard
+ 	$(LN) ckp_$(CHECKPW).c osdepckp.c
+ 
+ 
+ # A monument to a hack of long ago and far away...
+ 
+ love:
+ 	@echo not war?
diff -c -N c-client.pure/Makefile.ccl~ c-client/Makefile.ccl~
*** c-client.pure/Makefile.ccl~	Thu Jan  1 01:00:00 1970
--- c-client/Makefile.ccl~	Sat Feb  5 15:06:49 2000
***************
*** 0 ****
--- 1,758 ----
+ # Program:	C client makefile
+ #
+ # Author:	Mark Crispin
+ #		Networks and Distributed Computing
+ #		Computing & Communications
+ #		University of Washington
+ #		Administration Building, AG-44
+ #		Seattle, WA  98195
+ #		Internet: MRC@CAC.Washington.EDU
+ #
+ # Date:		11 May 1989
+ # Last Edited:	16 November 1999
+ #
+ # Copyright 1999 by the University of Washington
+ #
+ #  Permission to use, copy, modify, and distribute this software and its
+ # documentation for any purpose and without fee is hereby granted, provided
+ # that the above copyright notice appears in all copies and that both the
+ # above copyright notice and this permission notice appear in supporting
+ # documentation, and that the name of the University of Washington not be
+ # used in advertising or publicity pertaining to distribution of the software
+ # without specific, written prior permission.  This software is made
+ # available "as is", and
+ # THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+ # WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+ # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+ # NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+ # INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+ # LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+ # (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+ # WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ 
+ 
+ # Command line build parameters
+ 
+ EXTRAAUTHENTICATORS=
+ SPECIALAUTHENTICATORS=
+ EXTRADRIVERS=mbox
+ PASSWDTYPE=std
+ 
+ 
+ # Extended flags needed for non-standard passwd types.  You may need to modify.
+ 
+ AFSDIR=/usr/afsws
+ AFSCFLAGS=-Dexit=afs_exit -D_exit=_afs_exit -I$(AFSDIR)/include
+ AFSLIB=$(AFSDIR)/lib
+ AFSLDFLAGS=-L$(AFSLIB)/afs -L$(AFSLIB) -L$(AFSDIR)/domestic/lib\
+  -lkauth -lprot -lubik -lauth -lrxkad -lrx -llwp -ldes -lcom_err\
+  $(AFSLIB)/afs/util.a -laudit -lsys
+ # AFSLDFLAGS may also need -L/usr/ucblib -lucb
+ DCECFLAGS= -DDCE_MINIMAL -DPASSWD_OVERRIDE=\"/opt/pop3/passwd/passwd\"
+ DCELDFLAGS= -ldce
+ PAMLDFLAGS= -lpam -ldl
+ 
+ 
+ # Build parameters normally set by the individual port
+ 
+ CHECKPW=std
+ LOGINPW=std
+ SIGTYPE=bsd
+ ACTIVEFILE=/usr/lib/news/active
+ SPOOLDIR=/usr/spool
+ MAILSPOOL=$(SPOOLDIR)/mail
+ NEWSSPOOL=$(SPOOLDIR)/news
+ RSHPATH=/usr/ucb/rsh
+ LOCKPGM=/etc/mlock
+ 
+ 
+ # Default formats for creating new mailboxes and for empty mailboxes in the
+ # default namespace; must be set to the associated driver's prototype.
+ #
+ # The CREATEPROTO is the default format for new mailbox creation.
+ # The EMPTYPROTO is the default format for handling zero-byte files.
+ #
+ # Normally, this is set by the individual port.
+ #
+ # NOTE: namespace formats (e.g. mh and news) can not be set as a default format
+ # since they do not exist in the default namespace.  Also, it is meaningless to
+ # set certain other formats (e.g. mbx and mx) as the EMPTYPROTO since these
+ # formats can never be empty files.
+ 
+ CREATEPROTO=unixproto
+ EMPTYPROTO=unixproto
+ 
+ 
+ # Commands possibly overriden by the individual port
+ 
+ ARRC=ar rc
+ CC=cc
+ LN=ln -s
+ RANLIB=ranlib
+ 
+ 
+ # Standard distribution build parameters
+ 
+ DEFAULTAUTHENTICATORS=md5 $(SPECIALAUTHENTICATORS) log
+ DEFAULTDRIVERS=imap nntp pop3 mh mx mbx tenex mtx mmdf unix news phile
+ 
+ 
+ # Normally no need to change any of these
+ 
+ ARCHIVE=c-client.a
+ BINARIES=mail.o misc.o newsrc.o smanager.o osdep.o utf8.o siglocal.o \
+  dummy.o pseudo.o netmsg.o flstring.o fdstring.o \
+  rfc822.o nntp.o smtp.o imap4r1.o pop3.o \
+  unix.o mbox.o mbx.o mmdf.o tenex.o mtx.o news.o phile.o mh.o mx.o
+ CFLAGS=$(BASECFLAGS) $(EXTRACFLAGS)
+ MAKE=make
+ MV=mv
+ RM=rm -rf
+ SH=sh
+ 
+ 
+ # Primary build command
+ 
+ BUILDOPTIONS= EXTRACFLAGS="$(EXTRACFLAGS)"\
+  EXTRALDFLAGS="$(EXTRALDFLAGS)"\
+  EXTRADRIVERS="$(EXTRADRIVERS)" EXTRAAUTHENTICATORS="$(EXTRAAUTHENTICATORS)"\
+  PASSWDTYPE=$(PASSWDTYPE) SPECIALAUTHENTICATORS="$(SPECIALAUTHENTICATORS)"
+ BUILD=$(MAKE) build $(BUILDOPTIONS)
+ 
+ # Here if no make argument established
+ 
+ missing: osdep.h
+ 	$(MAKE) all CC=`cat CCTYPE` CFLAGS="`cat CFLAGS`" `cat EXTRASPECIALS`
+ 
+ osdep.h:
+ 	@echo You must specify what type of system
+ 	@false
+ 
+ 
+ # Current ports
+ 
+ a32:	# AIX 3.2 for RS/6000
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx \
+ 	 SPOOLDIR=/var/spool \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -Dunix=1 -D_BSD -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lbsd"
+ 
+ a41:	# AIX 4.1 for RS/6000
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=a41 \
+ 	 SPOOLDIR=/var/spool \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -Dunix=1 -D_BSD -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lbsd -ls"
+ 
+ aix:	# AIX/370
+ 	@echo You are building for AIX on an S/370 class machine
+ 	@echo If you want AIX on an RS/6000 you need to use a32 or a41 instead!
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lbsd"
+ 
+ aos:	# AOS for RT
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE"
+ 
+ art:	# AIX 2.2.1 for RT
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 \
+ 	 SPOOLDIR=/var \
+ 	 ACTIVEFILE=/usr/local/news/control/active \
+ 	 RSHPATH=/bin/rsh \
+ 	 BASECFLAGS="-g -Dconst= -Dvoid=char" \
+ 	 RANLIB=true 
+ 
+ asv:	# Altos SVR4
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 LOGINPW=old \
+ 	 ACTIVEFILE=/usr/spool/news/active \
+ 	 RSHPATH=/usr/bin/rcmd \
+ 	 BASECFLAGS="-Dconst= -DSIGSTOP=SIGKILL" \
+ 	 BASELDFLAGS="-lsocket -lrpc -lgen -lcrypt -lxenix" \
+ 	 RANLIB=true
+ 
+ aux:	# A/UX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 MAILSPOOL=/usr/mail \
+ 	 BASECFLAGS="-g -B/usr/lib/big/ -Dvoid=char -Dconst= -DNFSKLUDGE" \
+ 	 RANLIB=true ARRC="ar -rc"
+ 
+ bs3:	# BSD/i386 3.0 or higher
+ 	$(BUILD) `cat EXTRASPECIALS` OS=bsi CHECKPW=bsi LOGINPW=bsi \
+ 	 SPOOLDIR=/var NEWSSPOOL=/var/news/spool \
+ 	 ACTIVEFILE=/var/news/etc/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O2 -pipe -DNFSKLUDGE" CC=shlicc
+ 
+ bsd:	# BSD UNIX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE"
+ 
+ bsf:	# FreeBSD
+ 	$(BUILD) `cat EXTRASPECIALS` OS=bsi SIGTYPE=psx \
+ 	 SPOOLDIR=/var \
+ 	 ACTIVEFILE=/usr/local/news/lib/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O -pipe -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lcrypt"
+ 
+ bsi:	# BSD/i386
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 SPOOLDIR=/var NEWSSPOOL=/var/news/spool \
+ 	 ACTIVEFILE=/var/news/etc/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O2 -pipe -DNFSKLUDGE"
+ 
+ bso:	# OpenBSD
+ 	$(BUILD) `cat EXTRASPECIALS` OS=bsi SIGTYPE=psx \
+ 	 SPOOLDIR=/var \
+ 	 ACTIVEFILE=/usr/local/news/lib/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-O2 -pipe -DNFSKLUDGE"
+ 
+ cvx:	# Convex
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-O -ext -Dconst= -DNFDKLUDGE"
+ 
+ d-g:	# Data General DG/UX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/local/news/active \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lnsl -lsocket" \
+ 	 RANLIB=true
+ 
+ d54:	# Data General DG/UX 5.4
+ 	$(BUILD) `cat EXTRASPECIALS` OS=d-g SIGTYPE=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/local/news/active \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lnsl -lsocket" \
+ 	 RANLIB=true
+ 
+ dpx:	# Bull DPX/2
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sv4 SIGTYPE=sv4 CHECKPW=sv4 LOGINPW=sv4 \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-Dconst= -DSYSTEM5 -DSHORT_IDENT" \
+ 	 BASELDFLAGS="-linet" \
+ 	 RANLIB=true LN=ln
+ 
+ drs:	# ICL DRS/NX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 CHECKPW=sv4 LOGINPW=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-O -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lsocket -lgen" \
+ 	 RANLIB=true
+ 
+ do4:	# Apollo Domain/OS sr10.4
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-DNFSKLUDGE -A systype,bsd4.3 -D_APOLLO_SOURCE" \
+ 	 RANLIB=true
+ 
+ dyn:	# Dynix
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE"
+ 
+ epx:	# EP/IX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sv4 SIGTYPE=sv4 CHECKPW=sv4 LOGINPW=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/usr/share/news/active \
+ 	 RSHPATH=/usr/net/rsh \
+ 	 BASECFLAGS="-g -systype svr4" \
+ 	 BASELDFLAGS="-lsocket -lnsl -lgen" \
+ 	 RANLIB=true
+ 
+ gas:	# GCC Altos SVR4
+ 	$(BUILD) `cat EXTRASPECIALS` OS=asv SIGTYPE=sv4 LOGINPW=old \
+ 	 ACTIVEFILE=/usr/spool/news/active \
+ 	 RSHPATH=/usr/bin/rcmd \
+ 	 BASECFLAGS="-g -O -DALTOS_SYSTEM_V -DSIGSTOP=SIGKILL" \
+ 	 BASELDFLAGS="-lsocket -lrpc -lgen -lcrypt -lxenix" \
+ 	 RANLIB=true CC=gcc
+ 
+ gh9:	# GCC HP-UX9.x
+ 	$(BUILD) `cat EXTRASPECIALS` OS=hpp SIGTYPE=psx \
+ 	 MAILSPOOL=/usr/mail \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-O2 -DNFSKLUDGE" \
+ 	 RANLIB=true CC=gcc
+ 
+ ghp:	# GCC HP-UX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=hpp SIGTYPE=psx \
+ 	 SPOOLDIR=/var \
+ 	 ACTIVEFILE=/var/news/active \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-O2 -DNFSKLUDGE" \
+ 	 RANLIB=true CC=gcc
+ 
+ gs5:	# GCC 2.7.1 (95q4) SCO Open Server 5.0.x
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sc5 SIGTYPE=psx CHECKPW=sec LOGINPW=sec \
+ 	 CREATEPROTO=mmdfproto EMPTYPROTO=mmdfproto \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rcmd \
+ 	 BASECFLAGS="-O3 -belf -I/usr/include -L/lib" \
+ 	 BASELDFLAGS="-lsocket -lcrypt -lprot -lx -ltinfo -lm" \
+ 	 RANLIB=true
+ 
+ gso:	# GCC Solaris
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sol SIGTYPE=psx CHECKPW=psx \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/usr/share/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O2 -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lsocket -lnsl -lgen" \
+ 	 RANLIB=true CC=gcc
+ 
+ gsu:	# GCC SUN-OS
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sun \
+ 	 BASECFLAGS="-O2 -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-ldl" \
+ 	 CC=gcc
+ 
+ gul:	# GCC Ultrix
+ 	$(BUILD) `cat EXTRASPECIALS` OS=ult SIGTYPE=psx CHECKPW=ult \
+ 	 BASECFLAGS="-g -O -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lauth -lc" \
+ 	 CC=gcc
+ 
+ hpp:	# HP-UX 9.x
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx \
+ 	 MAILSPOOL=/usr/mail \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-g -Aa -D_HPUX_SOURCE -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lnet -lV3" \
+ 	 RANLIB=true
+ 
+ hpx:	# HP-UX 10.x
+ 	$(BUILD) `cat EXTRASPECIALS` OS=hpp SIGTYPE=psx \
+ 	 SPOOLDIR=/var \
+ 	 ACTIVEFILE=/var/news/active \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-g -Ae -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lnet -lV3" \
+ 	 RANLIB=true
+ 
+ isc:	# Interactive
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 CHECKPW=sv4 LOGINPW=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/var/spool/news/active \
+ 	 BASECFLAGS="-Xp -D_SYSV3" \
+ 	 BASELDFLAGS="-linet -lnsl_s -lgen -lx -lsec -liberty" \
+ 	 RANLIB=true
+ 
+ lnp:	# Linux Pluggable Authentication modules
+ 	$(BUILD) `cat EXTRASPECIALS` OS=lnx SIGTYPE=psx CHECKPW=pam \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -fno-omit-frame-pointer -O6 -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lpam -ldl"
+ 
+ lnx:	# Linux non-shadow passwords
+ 	@echo You are building for traditional Linux *without* shadow
+ 	@echo passwords and with the crypt function in the C library.
+ 	@echo If your system has shadow passwords, or if crypt is not
+ 	@echo in the C library, you must use slx, sl4, or sl5 instead!
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O -DNFSKLUDGE"
+ 
+ lyn:	# LynxOS
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 RSHPATH=/bin/rsh \
+ 	 BASECFLAGS="-g -O -pipe -DNFSKLUDGE" \
+ 	 BASELDFLAGS=-lbsd \
+ 	 CC=gcc
+ 
+ mct:	# MachTen - NFSKLUDGE doesn't work (at least not on 2.2)
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 SPOOLDIR=/var/spool \
+ 	 BASECFLAGS="-g -O -pipe"
+ 
+ mnt:	# Mint
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O -DNFSKLUDGE"
+ 
+ neb:	# NetBSD
+ 	$(BUILD) `cat EXTRASPECIALS` OS=bsi \
+ 	 SPOOLDIR=/var \
+ 	 ACTIVEFILE=/var/db/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O -pipe -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lcrypt"
+ 
+ nxt:	# NEXTSTEP
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -O -pipe -DNFSKLUDGE"
+ 
+ nx3:	# NEXTSTEP 3.0 single threaded
+ 	$(BUILD) `cat EXTRASPECIALS` OS=nxt \
+ 	 BASECFLAGS="-g -O -pipe -DNFSKLUDGE -Wall"
+ 	echo "void malloc_singlethreaded (void);" >> linkage.h
+ 	echo "  malloc_singlethreaded ();" >> linkage.c
+ 
+ osf:	# OSF/1
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx \
+ 	 BASECFLAGS="-g3 -O2 -Olimit 1500 -DNFSKLUDGE"
+ 
+ # Note: sia_become_user() used by LOGINPW=os4 doesn't seem to work right.  The
+ # user doesn't get proper file access, and the process can't be killed.
+ 
+ os4:	# OSF/1 (Digital UNIX) 4
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=os4 LOGINPW=os4 \
+ 	 BASECFLAGS="-g3 -O2 -Olimit 1500 -DNFSKLUDGE"
+ 
+ ptx:	# PTX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=svo LOGINPW=sv4 \
+ 	 MAILSPOOL=/usr/mail \
+ 	 RSHPATH=/usr/bin/resh \
+ 	 BASECFLAGS="-Wc,-O3 -Wc,-seq -Dprivate=PRIVATE -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lseq -lsec -lsocket -linet -lnsl -lgen" \
+ 	 RANLIB=true
+ 
+ pyr:	# Pyramid
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE"
+ 
+ qnx:	# QNX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ CHECKPW=psx LOGINPW=old \
+ 	 RSHPATH=/usr/ucb/rsh \
+ 	 BASECFLAGS="-Otax -g -Dunix=1 -D_POSIX_SOURCE" \
+ 	 BASELDFLAGS="-g -N128k -llogin -lsocket -lunix"
+ 
+ s40:	# SUN-OS 4.0
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE"
+ 
+ sc5:	# SCO Open Server 5.0
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=sec LOGINPW=sec \
+ 	 CREATEPROTO=mmdfproto EMPTYPROTO=mmdfproto \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rcmd \
+ 	 BASECFLAGS="-O3 -s" \
+ 	 BASELDFLAGS="-lsocket -lcrypt -lprot -lx -ltinfo -lm" \
+ 	 RANLIB=true
+ 
+ sco:	# Santa Cruz Operation
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 CHECKPW=sec LOGINPW=sec \
+ 	 CREATEPROTO=mmdfproto EMPTYPROTO=mmdfproto \
+ 	 RSHPATH=/usr/bin/rcmd \
+ 	 BASECFLAGS="-O3" \
+ 	 BASELDFLAGS="-lsocket -lprot -lcrypt_i -lx -los" \
+ 	 RANLIB=true LN=ln
+ 
+ # Notes:
+ # 1) setting _POSIX_SOURCE doesn't seem to build it as of SGI IRIX 5.3
+ # 2) SGI make wouldn't build for Steve unless that bizarre "MAKEFLAGS="
+ #    was inserted in the beginning.
+ 
+ sgi:	# Silicon Graphics
+ 	MAKEFLAGS= $(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 \
+ 	 MAILSPOOL=/usr/mail \
+ 	 RSHPATH=/usr/bsd/rsh \
+ 	 BASECFLAGS="-g3 -O2 -Olimit 8192 -DNFSKLUDGE" \
+ 	 RANLIB=true
+ 
+ sg6:	# Silicon Graphics, IRIX 6.5
+ 	MAKEFLAGS= $(BUILD) `cat EXTRASPECIALS` OS=sgi SIGTYPE=sv4 \
+ 	 MAILSPOOL=/usr/mail \
+ 	 RSHPATH=/usr/bsd/rsh \
+ 	 BASECFLAGS="-g3 -O2 -DNFSKLUDGE -woff 1048,1110,1116" \
+ 	 RANLIB=true
+ 
+ # Note: Mark Kaesling says that setluid() isn't in HP-UX with SecureWare.
+ 
+ shp:	# HP-UX with Trusted Computer Base
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=sec LOGINPW=std \
+ 	 SPOOLDIR=/var \
+ 	 ACTIVEFILE=/var/news/active \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-g -Ae -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lnet -lV3 -lsec" \
+ 	 RANLIB=true
+ 
+ slx:	# Secure Linux
+ 	@echo You are building for libc6/glibc versions of Secure Linux
+ 	@echo If you want libc5 versions you must use sl5 instead!
+ 	@echo If you want libc4 versions you must use sl4 instead!
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=psx \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -fno-omit-frame-pointer -O6 -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lcrypt"
+ 
+ sl4:	# Secure Linux using libc4
+ 	@echo You are building for libc4 versions of Secure Linux
+ 	@echo If you want libc6/glibc versions you must use slx instead!
+ 	@echo If you want libc5 versions you must use sl5 instead!
+ 	$(BUILD) `cat EXTRASPECIALS` OS=slx SIGTYPE=psx CHECKPW=psx \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -fno-omit-frame-pointer -O6 -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lshadow"
+ 
+ sl5:	# Secure Linux using libc5
+ 	@echo You are building for libc5 versions of Secure Linux
+ 	@echo If you want libc6/glibc versions you must use slx instead!
+ 	@echo If you want libc4 versions you must use sl4 instead!
+ 	$(BUILD) `cat EXTRASPECIALS` OS=slx SIGTYPE=psx CHECKPW=psx \
+ 	 SPOOLDIR=/var/spool \
+ 	 ACTIVEFILE=/var/lib/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -fno-omit-frame-pointer -O6 -DNFSKLUDGE"
+ 
+ snx:	# Siemens Nixdorf SINIX and Reliant UNIX
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sv4 SIGTYPE=psx CHECKPW=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/usr/share/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -D_SYS_CLOCK_H -Dconst=" \
+ 	 BASELDFLAGS="-lsocket -lnsl -lgen" \
+ 	 RANLIB=true
+ 
+ # Note: It is a long and disgusting story about why cc is set to ucbcc.  You
+ # need to invoke the C compiler so that it links with the SVR4 libraries and
+ # not the BSD libraries, otherwise readdir() will return the wrong information.
+ # Of all the names in the most common path, ucbcc is the only name to be found
+ # (on /usr/ccs/bin) that points to a suitable compiler.  cc is likely to be
+ # /usr/ucb/cc which is absolutely not the compiler that you want.  The real
+ # SVR4 cc is probably something like /opt/SUNWspro/bin/cc which is rarely in
+ # anyone's path.
+ #
+ # ucbcc is probably a link to acc, e.g. /opt/SUNWspro/SC4.0/bin/acc, and is
+ # the UCB C compiler using the SVR4 libraries.
+ #
+ # If ucbcc isn't on your system, then punt on the SUN C compiler and use gcc
+ # instead (the gso port instead of the sol port).
+ # 
+ # If, in spite of all the above warnings, you choose to change "ucbcc" to "cc",
+ # you will probably find that the -O2 needs to be changed to -O.  If you don't
+ # get any error messages with -O2, that's a pretty good indicator that you
+ # goofed and are running the compiler that will link with the BSD libraries.
+ #
+ # To recap:
+ # 1) The sol port is designed to be built using the UCB compiler using the
+ #    SVR4 libraries.  This compiler is "ucbcc", which is lunk to acc.  You
+ #    use -O2 as one of the CFLAGS.
+ # 2) If you build the sol port with the UCB compiler using the BSD libraries,
+ #    you will get no error messages but you will get bad binaries (the most
+ #    obvious symptom is dropping the first two characters return filenames
+ #    from the imapd LIST command.  This compiler also uses -O2, and is very
+ #    often what the user gets from "cc".  BEWARE!!!
+ # 3) If you build the sol port with the real SVR4 compiler, which is often
+ #    hidden away or unavailable on many systems, then you will get errors
+ #    from -O2 and you need to change that to -O.  But you will get a good
+ #    binary.  However, you should try it with -O2 first, to make sure that
+ #    you got this compiler and not the UCB compiler using BSD libraries.
+ 
+ sol:	# Solaris
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=psx \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/usr/share/news/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g -O2 -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lsocket -lnsl -lgen" \
+ 	 RANLIB=true CC=ucbcc
+ 
+ sos:	# Secure OSF/1
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=sec LOGINPW=sec \
+ 	 BASECFLAGS="-g3 -O2 -Olimit 1500 -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lsecurity -laud"
+ 
+ ssn:	# Secure SUN-OS
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sun CHECKPW=ssn \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-ldl"
+ 
+ sun:	# SUN-OS
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-g -Dconst= -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-ldl"
+ 
+ sv2:	# SVR2
+ 	@echo You are being *very* optimistic!
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 LOGINPW=old \
+ 	 MAILSPOOL=/usr/mail \
+ 	 RSHPATH=/usr/bin/remsh \
+ 	 BASECFLAGS="-Dconst= -DSYSTEM5 -DSHORT_IDENT -I/usr/ethernet/include" \
+ 	 BASELDFLAGS="-lnet" \
+ 	 RANLIB=true LN=ln
+ 
+ sv4:	# SVR4
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=sv4 CHECKPW=sv4 LOGINPW=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/usr/share/news/active \
+ 	 RSHPATH=/usr/bin/resh \
+ 	 BASECFLAGS="-g -Dconst=" \
+ 	 BASELDFLAGS="-lsocket -lnsl -lgen" \
+ 	 RANLIB=true
+ 
+ ult:	# Ultrix
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ SIGTYPE=psx CHECKPW=ult \
+ 	 BASECFLAGS="-g3 -O2 -Olimit 1500 -Dconst= -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lauth -lc"
+ 
+ uw2:	# UnixWare SVR4.2
+ 	$(BUILD) `cat EXTRASPECIALS` OS=sv4 SIGTYPE=sv4 CHECKPW=sv4 \
+ 	 SPOOLDIR=/var/spool MAILSPOOL=/var/mail \
+ 	 ACTIVEFILE=/var/news/lib/active \
+ 	 RSHPATH=/usr/bin/rsh \
+ 	 BASECFLAGS="-g" \
+ 	 BASELDFLAGS="-lsocket -lnsl -lgen" \
+ 	 RANLIB=true
+ 
+ vul:	# VAX Ultrix
+ 	$(BUILD) `cat EXTRASPECIALS` OS=ult SIGTYPE=psx CHECKPW=ult \
+ 	 BASECFLAGS="-O2 -Dconst= -DNFSKLUDGE" \
+ 	 BASELDFLAGS="-lauth -lc"
+ 
+ vu2:	# VAX Ultrix 2.3, etc.
+ 	$(BUILD) `cat EXTRASPECIALS` OS=$@ \
+ 	 BASECFLAGS="-O2 -Dconst= -Dvoid=char -DNFSKLUDGE"
+ 
+ 
+ # Build it!
+ 
+ build:	clean once $(ARCHIVE)
+ 
+ all:	$(ARCHIVE)
+ 
+ $(ARCHIVE): $(BINARIES)
+ 	sh -c '$(RM) $(ARCHIVE) || true'
+ 	@cat ARCHIVE
+ 	@$(SH) ARCHIVE
+ 
+ # Cleanup
+ 
+ clean:
+ 	sh -c '$(RM) auths.c flockbsd.c linkage.[ch] siglocal.c osdep*.[ch] *.o ARCHIVE *FLAGS *TYPE $(ARCHIVE) || true'
+ 
+ 
+ # Dependencies
+ 
+ dummy.o: mail.h misc.h osdep.h dummy.h
+ fdstring.o: mail.h misc.h osdep.h fdstring.h
+ flstring.o: mail.h misc.h osdep.h flstring.h
+ imap4r1.o: mail.h misc.h osdep.h imap4r1.h rfc822.h
+ mail.o: mail.h misc.h osdep.h rfc822.h linkage.h
+ mbox.o: mail.h misc.h osdep.h mbox.h unix.h
+ mbx.o: mail.h misc.h osdep.h mbx.h dummy.h
+ mh.o: mail.h misc.h osdep.h mh.h dummy.h
+ mx.o: mail.h misc.h osdep.h mx.h dummy.h
+ misc.o: mail.h misc.h osdep.h
+ mmdf.o: mail.h misc.h osdep.h mmdf.h pseudo.h dummy.h
+ mtx.o: mail.h misc.h osdep.h mtx.h dummy.h
+ netmsg.o: mail.h misc.h osdep.h netmsg.h
+ news.o: mail.h misc.h osdep.h news.h
+ newsrc.o: mail.h misc.h osdep.h newsrc.h
+ nntp.o: mail.h misc.h osdep.h netmsg.h smtp.h nntp.h rfc822.h
+ phile.o: mail.h misc.h osdep.h phile.h rfc822.h dummy.h
+ pseudo.o: pseudo.h
+ pop3.o: mail.h misc.h osdep.h pop3.h rfc822.h
+ smanager.o: mail.h misc.h osdep.h
+ smtp.o: mail.h misc.h osdep.h smtp.h rfc822.h
+ rfc822.o: mail.h misc.h osdep.h rfc822.h
+ tenex.o: mail.h misc.h osdep.h tenex.h dummy.h
+ unix.o: mail.h misc.h osdep.h unix.h pseudo.h dummy.h
+ utf8.o: mail.h misc.h osdep.h utf8.h
+ 
+ 
+ # OS-dependent
+ 
+ osdep.o:mail.h misc.h env.h fs.h ftl.h nl.h tcp.h \
+ 	osdep.h env_unix.h tcp_unix.h \
+ 	osdep.c env_unix.c fs_unix.c ftl_unix.c nl_unix.c tcp_unix.c \
+ 	auths.c flock.c flockbsd.c flcksafe.c fsync.c gethstid.c \
+ 	gr_wait.c gr_wait4.c gr_waitp.c \
+ 	auth_log.c auth_md5.c \
+ 	scandir.c setpgrp.c strerror.c truncate.c write.c \
+ 	memmove.c memmove2.c memset.c \
+ 	tz_bsd.c tz_nul.c tz_sv4.c \
+ 	write.c \
+ 	strerror.c strpbrk.c strstr.c strtok.c strtoul.c \
+ 	OSCFLAGS
+ 	$(CC) $(CFLAGS) `cat OSCFLAGS` -c osdep.c
+ 
+ osdep.c: osdepbas.c osdepckp.c osdeplog.c
+ 	cat osdepbas.c osdepckp.c osdeplog.c > osdep.c
+ 
+ flockbsd.c:	# cretin Linux
+ 
+ siglocal.c:	# cretin Linux
+ 
+ 
+ # Once-only environment setup
+ 
+ once:	onceenv ckp$(PASSWDTYPE) osdep.c 
+ 
+ onceenv:
+ 	@echo Once-only environment setup...
+ 	echo $(CC) > CCTYPE
+ 	echo $(CFLAGS) > CFLAGS
+ 	echo -DCREATEPROTO=$(CREATEPROTO) -DEMPTYPROTO=$(EMPTYPROTO) \
+ 	 -DMAILSPOOL=\"$(MAILSPOOL)\" \
+ 	 -DANONYMOUSHOME=\"$(MAILSPOOL)/anonymous\" \
+ 	 -DACTIVEFILE=\"$(ACTIVEFILE)\" -DNEWSSPOOL=\"$(NEWSSPOOL)\" \
+ 	 -DRSHPATH=\"$(RSHPATH)\" -DLOCKPGM=\"$(LOCKPGM)\" > OSCFLAGS
+ 	echo $(BASELDFLAGS) $(EXTRALDFLAGS) > LDFLAGS
+ 	echo "$(ARRC) $(ARCHIVE) $(BINARIES);$(RANLIB) $(ARCHIVE)" > ARCHIVE
+ 	./drivers $(EXTRADRIVERS) $(DEFAULTDRIVERS) dummy
+ 	./mkauths $(EXTRAAUTHENTICATORS) $(DEFAULTAUTHENTICATORS)
+ 	$(LN) os_$(OS).h osdep.h
+ 	$(LN) os_$(OS).c osdepbas.c
+ 	$(LN) log_$(LOGINPW).c osdeplog.c
+ 	$(LN) sig_$(SIGTYPE).c siglocal.c
+ 	sh -c '(test -f /usr/include/sys/statvfs.h -a $(OS) != sc5 -a $(OS) != sco) && $(LN) flocksun.c flockbsd.c || $(LN) flocksv4.c flockbsd.c'
+ 
+ # Password checkers
+ 
+ ckpafs:	# AFS
+ 	echo $(AFSCFLAGS) >> OSCFLAGS
+ 	echo $(AFSLDFLAGS) >> LDFLAGS
+ 	$(LN) ckp_afs.c osdepckp.c
+ 
+ ckpdce:	# DCE
+ 	echo $(DCECFLAGS) >> OSCFLAGS
+ 	echo $(DCELDFLAGS) >> LDFLAGS
+ 	$(LN) ckp_dce.c osdepckp.c
+ 
+ ckpkrb:	# Kerberos IV (must have krb EXTRAAUTHENTICATOR as well)
+ 	$(LN) ckp_krb.c osdepckp.c
+ 
+ ckpmd5:	# MD5 database (must have md5 AUTHENTICATOR as well)
+ 	$(LN) ckp_md5.c osdepckp.c
+ 
+ ckpnul:	# NUL authenticator (disables all plaintext authentication)
+ 	echo -DPLAINTEXT_DISABLED >> OSCFLAGS
+ 	$(LN) ckp_nul.c osdepckp.c
+ 
+ ckppam:	# Pluggable Authentication Modules authenticator
+ 	echo $(PAMLDFLAGS) >> LDFLAGS
+ 	$(LN) ckp_pam.c osdepckp.c
+ 
+ ckppmb:	# Broken (e.g. SUN) Pluggable Authentication Modules authenticator
+ 	echo $(PAMLDFLAGS) >> LDFLAGS
+ 	$(LN) ckp_pmb.c osdepckp.c
+ 
+ ckpstd:	# Port standard
+ 	$(LN) ckp_$(CHECKPW).c osdepckp.c
+ 
+ 
+ # A monument to a hack of long ago and far away...
+ 
+ love:
+ 	@echo not war?
diff -c -N c-client.pure/Makefile.gss c-client/Makefile.gss
*** c-client.pure/Makefile.gss	Thu Jan  1 01:00:00 1970
--- c-client/Makefile.gss	Sat Feb  5 15:31:17 2000
***************
*** 0 ****
--- 1,42 ----
+ # Program:	GSSAPI makefile
+ #
+ # Author:	Mark Crispin
+ #		Networks and Distributed Computing
+ #		Computing & Communications
+ #		University of Washington
+ #		Administration Building, AG-44
+ #		Seattle, WA  98195
+ #		Internet: MRC@CAC.Washington.EDU
+ #
+ # Date:		11 May 1989
+ # Last Edited:	13 October 1998
+ #
+ # Copyright 1998 by the University of Washington
+ #
+ #  Permission to use, copy, modify, and distribute this software and its
+ # documentation for any purpose and without fee is hereby granted, provided
+ # that the above copyright notice appears in all copies and that both the
+ # above copyright notice and this permission notice appear in supporting
+ # documentation, and that the name of the University of Washington not be
+ # used in advertising or publicity pertaining to distribution of the software
+ # without specific, written prior permission.  This software is made
+ # available "as is", and
+ # THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+ # WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+ # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+ # NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+ # INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+ # LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+ # (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+ # WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ 
+ 
+ # Extended flags needed for additional authenticators.  You may need to modify.
+ 
+ GSSDIR=/usr/local
+ GSSCFLAGS= -I$(GSSDIR)/include
+ GSSLDFLAGS= -L$(GSSDIR)/lib -lgssapi_krb5 -lkrb5 -lcrypto -lcom_err
+ 
+ gss:	# GSSAPI Kerberos V flags
+ 	echo $(GSSCFLAGS) >> OSCFLAGS
+ 	echo $(GSSLDFLAGS) >> LDFLAGS
diff -c -N c-client.pure/Makefile.md5 c-client/Makefile.md5
*** c-client.pure/Makefile.md5	Thu Jan  1 01:00:00 1970
--- c-client/Makefile.md5	Sat Feb  5 15:31:17 2000
***************
*** 0 ****
--- 1,39 ----
+ # Program:	CRAM-MD5 makefile
+ #
+ # Author:	Mark Crispin
+ #		Networks and Distributed Computing
+ #		Computing & Communications
+ #		University of Washington
+ #		Administration Building, AG-44
+ #		Seattle, WA  98195
+ #		Internet: MRC@CAC.Washington.EDU
+ #
+ # Date:		11 May 1989
+ # Last Edited:	24 October 1998
+ #
+ # Copyright 1998 by the University of Washington
+ #
+ #  Permission to use, copy, modify, and distribute this software and its
+ # documentation for any purpose and without fee is hereby granted, provided
+ # that the above copyright notice appears in all copies and that both the
+ # above copyright notice and this permission notice appear in supporting
+ # documentation, and that the name of the University of Washington not be
+ # used in advertising or publicity pertaining to distribution of the software
+ # without specific, written prior permission.  This software is made
+ # available "as is", and
+ # THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+ # WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+ # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+ # NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+ # INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+ # LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+ # (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+ # WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ 
+ 
+ # Extended flags needed for additional authenticators.  You may need to modify.
+ 
+ MD5CFLAGS= -DMD5ENABLE=\"/etc/cram-md5.pwd\"
+ 
+ md5:	# CRAM-MD5 flags
+ 	echo $(MD5CFLAGS) >> OSCFLAGS
diff -c -N c-client.pure/Makefile~ c-client/Makefile~
*** c-client.pure/Makefile~	Thu Jan  1 01:00:00 1970
--- c-client/Makefile~	Sat Feb  5 15:05:10 2000
***************
*** 0 ****
--- 1,26 ----
+ # Makefile for extra/src/c-client directory
+ # $Id$
+ 
+ CWD = extra/src/c-client
+ CSRC = mail.c misc.c
+ 
+ TARGETS = $(CSRC:.c=.o)
+ 
+ MAKE:=`echo $(MAKE) | sed "1,1 s/-j[ 0-9]*//g"` # strip off any -j arguments
+ 
+ all:
+ 	echo $(CCLIENTOSTYPE) >../OSTYPE
+ 	echo $(CC) >CCTYPE
+ 	$(MAKE) -f Makefile.ccl $(CCLIENTOSTYPE) $(CCLIENT_EXTRAAUTHENTICATORS) $(CCLIENT_EXTRACFLAGS)
+ 
+ include ../../../makerules
+ 
+ clean:
+ 	$(MAKE) -f Makefile.ccl clean
+ 
+ doc:
+ 	@echo
+ dep depend:
+ 	touch osdep.h linkage.h # dummy files to suppress warnings
+ 
+ include ../../../makeopts
diff -c -N c-client.pure/OSCFLAGS c-client/OSCFLAGS
*** c-client.pure/OSCFLAGS	Thu Jan  1 01:00:00 1970
--- c-client/OSCFLAGS	Sat Feb  5 16:56:55 2000
***************
*** 0 ****
--- 1,2 ----
+ -DCREATEPROTO=unixproto -DEMPTYPROTO=unixproto -DMAILSPOOL="/var/spool/mail" -DANONYMOUSHOME="/var/spool/mail/anonymous" -DACTIVEFILE="/var/lib/news/active" -DNEWSSPOOL="/var/spool/news" -DRSHPATH="/usr/bin/rsh" -DLOCKPGM="/etc/mlock"
+ -DMD5ENABLE="/etc/cram-md5.pwd"
diff -c -N c-client.pure/acte.c c-client/acte.c
*** c-client.pure/acte.c	Thu Jan  1 01:00:00 1970
--- c-client/acte.c	Sat Feb  5 14:44:02 2000
***************
*** 0 ****
--- 1,48 ----
+ /* acte.c -- Common functions for SASL mechanisms 
+  *
+  *	(C) Copyright 1994 by Carnegie Mellon University
+  *
+  *                      All Rights Reserved
+  *
+  * Permission to use, copy, modify, distribute, and sell this software
+  * and its documentation for any purpose is hereby granted without
+  * fee, provided that the above copyright notice appear in all copies
+  * and that both that copyright notice and this permission notice
+  * appear in supporting documentation, and that the name of Carnegie
+  * Mellon University not be used in advertising or publicity
+  * pertaining to distribution of the software without specific,
+  * written prior permission.  Carnegie Mellon University makes no
+  * representations about the suitability of this software for any
+  * purpose.  It is provided "as is" without express or implied
+  * warranty.
+  *
+  * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+  * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+  * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+  * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+  * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+  * SOFTWARE.
+  *
+  */
+ 
+ #include "acte.h"
+ 
+ char *acte_prottostring(protlevel)
+ int protlevel;
+ {
+     switch (protlevel) {
+     case ACTE_PROT_NONE:
+ 	return "no protection";
+ 
+     case ACTE_PROT_INTEGRITY:
+ 	return "integrity protection";
+ 
+     case ACTE_PROT_PRIVACY:
+ 	return "privacy protection";
+ 
+     default:
+ 	return "unknown";
+     }
+ }
diff -c -N c-client.pure/acte.h c-client/acte.h
*** c-client.pure/acte.h	Thu Jan  1 01:00:00 1970
--- c-client/acte.h	Sat Feb  5 14:44:02 2000
***************
*** 0 ****
--- 1,124 ----
+ /* acte.h -- Interface for IMAP AUTHENTICATE mechanisms 
+  *
+  *	(C) Copyright 1994,1996 by Carnegie Mellon University
+  *
+  *                      All Rights Reserved
+  *
+  * Permission to use, copy, modify, distribute, and sell this software
+  * and its documentation for any purpose is hereby granted without
+  * fee, provided that the above copyright notice appear in all copies
+  * and that both that copyright notice and this permission notice
+  * appear in supporting documentation, and that the name of Carnegie
+  * Mellon University not be used in advertising or publicity
+  * pertaining to distribution of the software without specific,
+  * written prior permission.  Carnegie Mellon University makes no
+  * representations about the suitability of this software for any
+  * purpose.  It is provided "as is" without express or implied
+  * warranty.
+  *
+  * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+  * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+  * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+  * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+  * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+  * SOFTWARE.
+  *
+  */
+ 
+ #ifndef INCLUDED_ACTE_H
+ #define INCLUDED_ACTE_H
+ 
+ #ifndef P
+ #ifdef __STDC__
+ #define P(x) x
+ #else
+ #define P(x) ()
+ #endif
+ #endif
+ 
+ #include <time.h>
+ 
+ struct sockaddr;
+ 
+ typedef const char *acte_encodefunc_t P((void *state,
+ 					  char *input, int inputlen,
+ 					  char *output, int *outputlen));
+ typedef const char *acte_decodefunc_t P((void *state,
+ 					  char *input, int inputlen,
+ 					  char **output, int *outputlen));
+ typedef int acte_authproc_t P((const char *user, const char *auth_identity,
+ 			       const char **reply));
+ 
+ /* Client-side authentication mechanism */
+ struct acte_client {
+     /* Name of authentication mechanism */
+     char *auth_type;
+ 
+     /* Start a client->server authentication */
+     int (*start) P((const char *service, const char *host, const char *user,
+ 		    int protallowed, int maxbufsize,
+ 		    struct sockaddr *localaddr, struct sockaddr *remoteaddr,
+ 		    void **state));
+ 
+     /* Do an authentication protocol exchange */
+     int (*auth) P((void *state, int inputlen, char *input,
+ 		   int *outputlen, char **output));
+     
+     /* Query an authentication state */
+     void (*query_state) P((void *state, char **user, int *protlevel,
+ 			   acte_encodefunc_t **encodefunc,
+ 			   acte_decodefunc_t **decodefunc, int *maxplain));
+ 
+     /* Free an authentication state */
+     void (*free_state) P((void *state));
+     
+     /* Acquire daemon's credentials */
+     const char *(*new_cred) P((const char *service, time_t *lifetime));	
+ 
+     /* Free daemon's credentials */
+     void (*free_cred) P((void));
+ };
+ 
+ /* Server-side authentication mechanism */
+ struct acte_server {
+     /* Name of authentication mechanism */
+     char *auth_type;		
+ 
+     /* Start an incoming authentication */
+     int (*start) P((const char *service, acte_authproc_t *authproc,
+ 		    int protallowed, int maxbufsize,
+ 		    struct sockaddr *localaddr, struct sockaddr *remoteaddr,
+ 		    int *outputlen, char **output,
+ 		    void **state, const char ** reply));
+     
+     /* Do an authentication protocol exchange */
+     int (*auth) P((void *state, int inputlen, char *input,
+ 		   int *outputlen, char **output, const char **reply));
+ 
+     /* Query an authentication state */
+     void (*query_state) P((void *state, char **user, int *protlevel,
+ 			   acte_encodefunc_t **encodefunc,
+ 			   acte_decodefunc_t **decodefunc, int *maxplain));
+ 
+     /* Free an authentication state */
+     void (*free_state) P((void *state));
+     
+     /* Get a cacheid, if available */
+     char *(*get_cacheid) P((void *state));
+ };
+ 
+ /* Protection mechanisms */
+ #define ACTE_PROT_NONE 1
+ #define ACTE_PROT_INTEGRITY 2
+ #define ACTE_PROT_PRIVACY 4
+ #define ACTE_PROT_ANY (ACTE_PROT_NONE|ACTE_PROT_INTEGRITY|ACTE_PROT_PRIVACY)
+ 
+ #define ACTE_FAIL 1		/* Authentication failed */
+ 
+ #define ACTE_DONE 3		/* Server has authenticated user */
+ 
+ extern char *acte_prottostring P((int protlevel));
+ 
+ #endif /* INCLUDED_ACTE_H */
diff -c -N c-client.pure/acte_krb.c c-client/acte_krb.c
*** c-client.pure/acte_krb.c	Thu Jan  1 01:00:00 1970
--- c-client/acte_krb.c	Sat Feb  5 14:44:02 2000
***************
*** 0 ****
--- 1,965 ----
+ /* acte_krb.c -- KERBEROS_V4 authentication routines for IMAP.
+  *
+  *	(C) Copyright 1994 by Carnegie Mellon University
+  *
+  *                      All Rights Reserved
+  *
+  * Permission to use, copy, modify, distribute, and sell this software
+  * and its documentation for any purpose is hereby granted without
+  * fee, provided that the above copyright notice appear in all copies
+  * and that both that copyright notice and this permission notice
+  * appear in supporting documentation, and that the name of Carnegie
+  * Mellon University not be used in advertising or publicity
+  * pertaining to distribution of the software without specific,
+  * written prior permission.  Carnegie Mellon University makes no
+  * representations about the suitability of this software for any
+  * purpose.  It is provided "as is" without express or implied
+  * warranty.
+  *
+  * CARNEGIE MELLON UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO
+  * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+  * AND FITNESS, IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE
+  * FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+  * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+  * SOFTWARE.
+  *
+  */
+ #include <stdio.h>
+ #include <string.h>
+ #include <netdb.h>
+ #include <sys/types.h>
+ #include <sys/param.h>
+ #include <netinet/in.h>
+ #include <krb.h>
+ 
+ #include "acte.h"
+ 
+ extern char *malloc();
+ 
+ extern char *lcase P((char *str));
+ extern char *krb_get_phost P((char *)), *krb_realmofhost P((char *));
+ 
+ static char *srvtab = "";	/* Srvtab filename */
+ 
+ /* Maximum number of bytes of overhead the protection mechanisms use */
+ #define PROTECTION_OVERHEAD 31
+ 
+ /* Private state used by this mechanism */
+ struct krb_state {
+     /* common */
+     char service[MAX_K_NAME_SZ+1];
+     int authstepno;
+     des_cblock session;	/* Our session key */
+     des_key_schedule schedule; /* Schedule for our session key */
+     long challenge;
+     char user[MAX_K_NAME_SZ+1];
+     int protallowed;
+     int maxbufsize;
+     struct sockaddr_in localaddr, remoteaddr;
+     long prot_time_sec;
+     char prot_time_5ms;
+     /* client */
+     char instance[INST_SZ];
+     char realm[REALM_SZ];
+     /* server */
+     int (*authproc)();
+     AUTH_DAT kdata;
+ };
+ 
+ /*
+  * Free the space used by an opaque state pointer
+  */
+ static void
+ krb_free_state(state)
+ void *state;
+ {
+     memset((char *)state, 0, sizeof(struct krb_state));
+     free((char *) state);
+ }
+ 
+ static acte_encodefunc_t krb_en_integrity;
+ static acte_decodefunc_t krb_de_integrity;
+ #ifndef NOPRIVACY
+ static acte_encodefunc_t krb_en_privacy;
+ static acte_decodefunc_t krb_de_privacy;
+ #endif
+ 
+ /*
+  * Query public values of the state pointer after authentiation
+  * complete.  Fills in buffers pointed to by the following arguments:
+  *
+  * user       -- IMAP userid authenticated as
+  * protlevel  -- bitmask for selected protection mechanism
+  * encodefunc -- if nonzero, protection mechanism function to encode
+  *               outgoing data with.
+  * decodefunc -- if nonzero, protection mechanism function to decode
+  *               incoming data with.
+  * maxplain   -- The maximum number of bytes that may be encoded by
+  *                the encodefunc at one time
+  */
+ static void 
+ krb_query_state(state, user, protlevel, encodefunc, decodefunc, maxplain)
+ void *state;
+ char **user;
+ int *protlevel;
+ acte_encodefunc_t **encodefunc;
+ acte_decodefunc_t **decodefunc;
+ int *maxplain;
+ {
+     struct krb_state *kstate = (struct krb_state *)state;
+ 
+     *user = kstate->user;
+     *protlevel = kstate->protallowed;
+ 
+     switch (kstate->protallowed) {
+     case ACTE_PROT_NONE:
+ 	*encodefunc = 0;
+ 	*decodefunc = 0;
+ 	*maxplain = 0;
+ 	return;
+ 
+     case ACTE_PROT_INTEGRITY:
+ 	*encodefunc = krb_en_integrity;
+ 	*decodefunc = krb_de_integrity;
+ 	*maxplain = kstate->maxbufsize - PROTECTION_OVERHEAD;
+ 	return;
+ 
+ #ifndef NOPRIVACY
+     case ACTE_PROT_PRIVACY:
+ 	*encodefunc = krb_en_privacy;
+ 	*decodefunc = krb_de_privacy;
+ 	*maxplain = kstate->maxbufsize - PROTECTION_OVERHEAD;
+ 	return;
+ #endif
+ 
+     default:
+ 	abort();
+     }
+ }
+ 
+ /*
+  * Get the cacheid for 'state'
+  */
+ static char *
+ krb_get_cacheid(state)
+ void *state;
+ {
+     char *cacheid;
+ 
+     struct krb_state *kstate = (struct krb_state *)state;
+ 
+     cacheid = malloc(16);
+     if (!cacheid) return 0;
+ 
+     memset(cacheid, 0, sizeof(cacheid));
+     memcpy(cacheid, kstate->session, sizeof(kstate->session));
+     return cacheid;
+ }
+ 
+ /*
+  * Start the client side of an authentication exchange.
+  */
+ static int krb_client_start(service, host, user, protallowed, maxbufsize,
+ 			    localaddr, remoteaddr, state)
+ const char *service;		/* Name of service */
+ const char *host;		/* Name of server host */
+ const char *user;		/* (optional) user to log in as */
+ int protallowed;		/* Protection mechanisms allowed */
+ int maxbufsize;			/* Maximum ciphertext input buffer size */
+ struct sockaddr *localaddr;	/* Network address of local side */
+ struct sockaddr *remoteaddr;	/* Network address of remote side */
+ void **state;			/* On success, filled in with state ptr */
+ {
+     struct hostent *host_name;
+     char userbuf[MAX_K_NAME_SZ+1];
+     char instance[INST_SZ];
+     char realm[REALM_SZ];
+     char uinst[INST_SZ];
+     char urealm[INST_SZ];
+     KTEXT_ST authent;
+     CREDENTIALS cr;
+     struct krb_state *kstate;
+     char *p;
+ 
+     protallowed &= ACTE_PROT_NONE|ACTE_PROT_INTEGRITY
+ #ifndef NOPRIVACY
+ 	|ACTE_PROT_PRIVACY
+ #endif
+ 	;
+     if (!localaddr || !remoteaddr) {
+ 	protallowed &= ACTE_PROT_NONE;
+     }
+     if (!protallowed) {
+ 	return ACTE_FAIL;
+     }
+     if (maxbufsize > 0xffffff) maxbufsize = 0xffffff;
+ 
+     /* Canonicalize hostname */
+     host_name = gethostbyname(host);
+     if (!host_name) {
+ 	return ACTE_FAIL;
+     }
+ 
+     strncpy(instance, host_name->h_name, sizeof(instance)-1);
+     instance[sizeof(instance)-1] = '\0';
+     if (p = strchr(instance, '.')) *p = '\0';
+ 
+     strcpy(realm, krb_realmofhost(host_name->h_name));
+ 
+     /* Fetch imap.hostname service key */
+     (void) krb_mk_req(&authent, service, instance, realm, 0);
+     memset(&authent, 0, sizeof(authent));
+ 
+     if (krb_get_cred(service, instance, realm, &cr)) {
+ 	return ACTE_FAIL;
+     }
+     
+     if (!user || !user[0]) {
+ 	if (krb_get_tf_fullname(TKT_FILE, userbuf, uinst, urealm)) {
+ 	    memset(&cr, 0, sizeof(cr));
+ 	    return ACTE_FAIL;
+ 	}
+ 	if (uinst[0]) {
+ 	    strcat(userbuf, ".");
+ 	    strcat(userbuf, uinst);
+ 	}
+ 	if (strcmp(urealm, realm) != 0) {
+ 	    strcat(userbuf, "@");
+ 	    strcat(userbuf, urealm);
+ 	}
+ 	user = userbuf;
+     }
+     else if (strlen(user) > MAX_K_NAME_SZ) {
+ 	return ACTE_FAIL;
+     }
+ 
+     kstate = (struct krb_state *)malloc(sizeof(struct krb_state));
+     if (!kstate) return ACTE_FAIL;
+     memset((char *)kstate, 0, sizeof(*kstate));
+     strcpy(kstate->service, service);
+     kstate->authstepno = 0;
+     memcpy(kstate->session, cr.session, sizeof(des_cblock));
+     des_key_sched(kstate->session, kstate->schedule);
+     strcpy(kstate->user, user);
+     kstate->protallowed = protallowed;
+     kstate->maxbufsize = maxbufsize;
+     if (localaddr && remoteaddr) {
+ 	kstate->localaddr = *(struct sockaddr_in *)localaddr;
+ 	kstate->remoteaddr = *(struct sockaddr_in *)remoteaddr;
+     }
+     strcpy(kstate->instance, instance);
+     strcpy(kstate->realm, realm);
+ 
+     memset(&cr, 0, sizeof(cr));
+     *state = (void *)kstate;
+     return 0;
+ }
+ 
+ /*
+  * Perform client-side authentication protocol exchange
+  * Returns ACTE_DONE if authentication can be complete after
+  * sending our client reply.
+  */
+ static int krb_client_auth(state, inputlen, input, outputlen, output)
+ void *state;			/* State of exchange */
+ int inputlen;			/* Length of server response */
+ char *input;			/* Server response data */
+ int *outputlen;			/* Set to length of client reply */
+ char **output;			/* Set to point to client reply data */
+ {
+     static KTEXT_ST authent;
+     struct krb_state *kstate = (struct krb_state *)state;
+     char tmp[4];
+     int code;
+     int maxbufsize;
+ 
+     switch (kstate->authstepno++) {
+     case 0:
+ 	/* Server gave us challenge, respond with ticket+authenticator */
+ 	if (inputlen < 4) {
+ 	    kstate->authstepno = -1;
+ 	    return ACTE_FAIL;
+ 	}
+ 	memcpy(tmp, input, 4);
+ 	kstate->challenge = ntohl(*(int *)tmp);
+ 
+ 	code = krb_mk_req(&authent, kstate->service, kstate->instance,
+ 			  kstate->realm, kstate->challenge);
+ 	if (code) {
+ 	    kstate->authstepno = -1;
+ 	    return ACTE_FAIL;
+ 	}
+ 	*outputlen = authent.length;
+ 	*output = authent.dat;
+ 	return 0;
+ 
+     case 1:
+ 	/*
+ 	 * Server gave us mutual auth reply+available protection mechanisms.
+ 	 * Respond with challenge, desired protection mechanism, userid
+ 	 */
+ 	if (inputlen < 8) {
+ 	    kstate->authstepno = -1;
+ 	    return ACTE_FAIL;
+ 	}
+ 	des_ecb_encrypt(input, input, kstate->schedule, 0);
+ 	memcpy(tmp, input, 4);
+ 	if (ntohl(*(int *)tmp) != kstate->challenge + 1) {
+ 	    /* Server failed to mutually authenticte */
+ 	    kstate->authstepno = -1;
+ 	    return ACTE_FAIL;
+ 	}	    
+ 	memcpy(tmp, input+4, 4);
+ 	maxbufsize = ntohl(*(int *)tmp) & 0xfffff;
+ 	kstate->protallowed &= input[4];
+ 	if (maxbufsize <= PROTECTION_OVERHEAD) {
+ 	    /* Protection buffer too small */
+ 	    kstate->protallowed &= ACTE_PROT_NONE;
+ 	}
+ #ifndef NOPRIVACY
+ 	if (kstate->protallowed & ACTE_PROT_PRIVACY) {
+ 	    kstate->protallowed = ACTE_PROT_PRIVACY;
+ 	}
+ 	else
+ #endif
+ 	if (kstate->protallowed & ACTE_PROT_INTEGRITY) {
+ 	    kstate->protallowed = ACTE_PROT_INTEGRITY;
+ 	}
+ 	else if (kstate->protallowed & ACTE_PROT_NONE) {
+ 	    kstate->protallowed = ACTE_PROT_NONE;
+ 	}
+ 	else {
+ 	    /* No mutually agreeable protection mechanism */
+ 	    kstate->authstepno = -1;
+ 	    return ACTE_FAIL;
+ 	}
+ 
+ 	*(int *)authent.dat = htonl(kstate->challenge);
+ 	*(int *)(authent.dat+4) = htonl(kstate->maxbufsize);
+ 	authent.dat[4] = kstate->protallowed;
+ 	strcpy(&authent.dat[8], kstate->user);
+ 	authent.length = 8+strlen(kstate->user);
+ 	do {
+ 	    authent.dat[authent.length++] = '\0';
+ 	} while (authent.length & 7);
+ 	des_pcbc_encrypt(authent.dat, authent.dat, authent.length,
+ 			 kstate->schedule, kstate->session, 1);
+ 	*output = authent.dat;
+ 	*outputlen = authent.length;
+ 	if (maxbufsize < kstate->maxbufsize) kstate->maxbufsize = maxbufsize;
+ 	return ACTE_DONE;
+ 
+     default:
+ 	kstate->authstepno = -1;
+ 	return ACTE_FAIL;
+     }
+ }
+ 
+ /*
+  * Acquire daemon client credentials for 'service'.  Places lifetime
+  * of credentials in seconds in the buffer pointed to by 'lifetime'
+  * Returns error message on failure, NULL on success.
+  */
+ static const char *
+ krb_new_cred(service, lifetime)
+ const char *service;
+ time_t *lifetime;
+ {
+     static int inited = 0;
+     char hostname[MAXHOSTNAMELEN+1];
+     char instance[MAXHOSTNAMELEN+1];
+     char realm[REALM_SZ];
+     char tktstring[256];
+     int r;
+     CREDENTIALS cr;
+ 
+     if (!inited++) {
+ 	sprintf(tktstring, "/tmp/tkt_pid_%d", getpid());
+ 	krb_set_tkt_string(tktstring);
+     }
+ 
+     if (krb_get_lrealm(realm,1) != KSUCCESS) {
+ 	return "cannot get local Kerberos realm";
+     }
+ 
+     gethostname(hostname, sizeof(hostname));
+     strcpy(instance, krb_get_phost(hostname));
+ 
+     r = krb_get_svc_in_tkt(service, instance, realm, "krbtgt", realm, 127,
+ 		       srvtab);
+ 
+     if (!r) {
+ 	r = krb_get_cred("krbtgt", realm, realm, &cr);
+ 	if (!r) *lifetime = cr.lifetime*5*60;
+ 	memset((char *)&cr, 0, sizeof(cr));
+     }
+ 
+     if (r) return krb_err_txt[r];
+     return 0;
+ }
+     
+ static void
+ krb_free_cred()
+ {
+     dest_tkt();
+ }
+ 
+ /* Exported definition of client-side authentication mechanism */
+ struct acte_client krb_acte_client = {
+     "KERBEROS_V4",
+     krb_client_start,
+     krb_client_auth,
+     krb_query_state,
+     krb_free_state,
+     krb_new_cred,
+     krb_free_cred,
+ };
+ 
+ /*
+  * Start the server side of an authentication exchange
+  */
+ static int
+ krb_server_start(service, authproc, protallowed, maxbufsize,
+ 		 localaddr, remoteaddr, outputlen, output, state, reply)
+ const char *service;
+ acte_authproc_t *authproc;	/* (optional) function to decide
+ 				 * authoriztion to log in as given user
+ 				 */
+ int protallowed;		/* Protection mechanisms allowed */
+ int maxbufsize;			/* Maximum ciphertext input buffer size */
+ struct sockaddr *localaddr;	/* Network address of local side */
+ struct sockaddr *remoteaddr;	/* Network address of remote side */
+ int *outputlen;			/* Set to length of initial reply */
+ char **output;			/* Set to point to initial reply data */
+ void **state;			/* On success, filled in with state ptr */
+ const char **reply;		/* On failure, filled in with ptr to reason */
+ {
+     static char outputbuf[4];
+     struct krb_state *kstate;
+ 
+     protallowed &= ACTE_PROT_NONE|ACTE_PROT_INTEGRITY
+ #ifndef NOPRIVACY
+ 	|ACTE_PROT_PRIVACY
+ #endif
+ 	;
+     if (!localaddr || !remoteaddr) {
+ 	protallowed &= ACTE_PROT_NONE;
+     }
+     if (!protallowed) {
+ 	*reply = "No suitable protection mechanism";
+ 	return ACTE_FAIL;
+     }
+     if (maxbufsize > 0xffffff) maxbufsize = 0xffffff;
+ 
+     kstate = (struct krb_state *)malloc(sizeof(struct krb_state));
+     if (!kstate) {
+ 	*reply = "Out of memory";
+ 	return ACTE_FAIL;
+     }
+     memset((char *)kstate, 0, sizeof(*kstate));
+     strcpy(kstate->service, service);
+     kstate->authstepno = 0;
+     kstate->challenge = time(0) ^ getpid();
+     kstate->protallowed = protallowed;
+     kstate->maxbufsize = maxbufsize;
+     if (localaddr && remoteaddr) {
+ 	kstate->localaddr = *(struct sockaddr_in *)localaddr;
+ 	kstate->remoteaddr = *(struct sockaddr_in *)remoteaddr;
+     }
+     kstate->authproc = authproc;
+ 
+     *(int *)outputbuf = htonl(kstate->challenge);
+     *output = outputbuf;
+     *outputlen = 4;
+     *state = (void *)kstate;
+     
+     return 0;
+ }
+ 
+ /*
+  * Perform server-side authentication protocol exchange.
+  * Returns 0 to continue exchange, ACTE_FAIL on failure, and ACTE_DONE
+  * if user is now successfully authenticated
+  */
+ static int krb_server_auth(state, inputlen, input, outputlen, output, reply)
+ void *state;			/* State of exchange */
+ int inputlen;			/* Length of client response */
+ char *input;			/* Client response data */
+ int *outputlen;			/* Set to length of server reply */
+ char **output;			/* Set to point to server reply data */
+ const char ** reply;		/* On failure, filled in with ptr to reason */
+ {
+     struct krb_state *kstate = (struct krb_state *)state;
+     static char outputbuf[8];
+     KTEXT_ST authent;
+     int code;
+     char tmp[4];
+     char instance[INST_SZ];
+     char realm[REALM_SZ];
+     int protallowed;
+     int maxbufsize;
+     char clientname[MAX_K_NAME_SZ+1];
+ 
+     switch (kstate->authstepno++) {
+     case 0:
+ 	/*
+ 	 * Client gave us ticket+authenticator
+ 	 * reply with mutual auth + supported protection mechanisms
+ 	 */
+ 	if (inputlen > MAX_KTXT_LEN) {
+ 	    kstate->authstepno = -1;
+ 	    *reply = "Kerberos authenticator too long";
+ 	    return ACTE_FAIL;
+ 	}
+ 	authent.length = inputlen;
+ 	memcpy(authent.dat, input, inputlen);
+ 	authent.mbz = 0;
+ 	strcpy(instance, "*");
+ 	code = krb_rd_req(&authent, kstate->service, instance, 0L,
+ 			  &kstate->kdata, srvtab);
+ 	if (code) {
+ 	    kstate->authstepno = -1;
+ 	    *reply = krb_err_txt[code];
+ 	    return ACTE_FAIL;
+ 	}
+ 	if (kstate->kdata.checksum != kstate->challenge) {
+ 	    kstate->authstepno = -1;
+ 	    *reply = "Incorrect checksum in Kerberos authenticator";
+ 	    return ACTE_FAIL;
+ 	}
+ 	memcpy(kstate->session, kstate->kdata.session, sizeof(des_cblock));
+ 	des_key_sched(kstate->session, kstate->schedule);
+ 	
+ 	*(int *)outputbuf = htonl(kstate->challenge+1);
+ 	*(int *)(outputbuf+4) = htonl(kstate->maxbufsize);
+ 	outputbuf[4] = kstate->protallowed;
+ 	des_ecb_encrypt(outputbuf, outputbuf, kstate->schedule, 1);
+ 	*output = outputbuf;
+ 	*outputlen = 8;
+ 
+ 	return 0;
+ 
+     case 1:
+ 	/* Client gave us selected protection mechanism + userid, we're done */
+ 	if (inputlen < 16 || inputlen & 7) {
+ 	    kstate->authstepno = -1;
+ 	    *reply = "Kerberos authenticator has incorrect length";
+ 	    return ACTE_FAIL;
+ 	}
+ 	des_pcbc_encrypt(input, input, inputlen,
+ 			 kstate->schedule, kstate->session, 0);
+ 	memcpy(tmp, input, 4);
+ 	if (ntohl(*(int *)tmp) != kstate->challenge) {
+ 	    kstate->authstepno = -1;
+ 	    *reply = "Incorrect checksum in Kerberos authenticator";
+ 	    return ACTE_FAIL;
+ 	}
+ 	memcpy(tmp, input+4, 4);
+ 	maxbufsize = ntohl(*(int *)tmp) & 0xfffff;
+ 	if (maxbufsize < kstate->maxbufsize) kstate->maxbufsize = maxbufsize;
+ 	protallowed = input[4];
+ 	if (!(protallowed & kstate->protallowed)) {
+ 	    kstate->authstepno = -1;
+ 	    *reply = "No suitable protection mechanism selected";
+ 	    return ACTE_FAIL;
+ 	}
+ 	if (
+ #ifndef NOPRIVACY
+ 	    protallowed != ACTE_PROT_PRIVACY &&
+ #endif
+ 	    protallowed != ACTE_PROT_INTEGRITY &&
+ 	    protallowed != ACTE_PROT_NONE) {
+ 	    kstate->authstepno = -1;
+ 	    *reply = "Multiple protection mechanisms selected";
+ 	    return ACTE_FAIL;
+ 	}
+ 	if (protallowed != ACTE_PROT_NONE &&
+ 	    kstate->maxbufsize <= PROTECTION_OVERHEAD) {
+ 	    /* Protection buffer too small */
+ 	    kstate->authstepno = -1;
+ 	    *reply = "Protection buffer size too small";
+ 	    return ACTE_FAIL;
+ 	}
+ 	kstate->protallowed = protallowed;
+ 
+ 	if (input[inputlen-1] != '\0') {
+ 	    *reply = "User name not nul-terminated";
+ 	    return ACTE_FAIL;
+ 	}
+ 	strcpy(kstate->user, input+8);
+ 
+ 	/* Check kerberos identity can log in as user */
+ 	if (krb_get_lrealm(realm,1)) {
+ 	    *reply = "Can't find local Kerberos realm";
+ 	    return ACTE_FAIL;
+ 	}
+ 	if (kstate->authproc) {
+ 	    strcpy(clientname, kstate->kdata.pname);
+ 	    if (kstate->kdata.pinst[0]) {
+ 		strcat(clientname, ".");
+ 		strcat(clientname, kstate->kdata.pinst);
+ 	    }
+ 	    if (kstate->kdata.prealm[0]) {
+ 		strcat(clientname, "@");
+ 		strcat(clientname, kstate->kdata.prealm);
+ 	    }
+ 	    if (kstate->authproc(kstate->user, clientname, reply) != 0) {
+ 		return ACTE_FAIL;
+ 	    }
+ 	}
+ 	else {
+ 	    if (strcmp(kstate->kdata.pname, kstate->user) != 0 ||
+ 		kstate->kdata.pinst[0] ||
+ 		strcmp(kstate->kdata.prealm, realm) != 0) {
+ 		*reply = "Kerberos ID does not match user name";
+ 		return ACTE_FAIL;
+ 	    }
+ 	}
+ 
+ 	return ACTE_DONE;
+ 
+     default:
+ 	*reply = "Internal error: invalid state in krb_server_auth";
+ 	return ACTE_FAIL;
+     }
+ }
+ 
+ /* Exported definition of server-side authentication mechanism */
+ struct acte_server krb_acte_server = {
+     "KERBEROS_V4",
+     krb_server_start,
+     krb_server_auth,
+     krb_query_state,
+     krb_free_state,
+     krb_get_cacheid,
+ };
+ 
+ /*
+  * Apply integrity protection to the 'inputlen' bytes of data at 'input',
+  * using the state in 'state', placing the output data and length in the
+  * buffers pointed to by 'output' and 'outputlen' respectively.
+  */
+ static const char *
+ krb_en_integrity(state, input, inputlen, output, outputlen)
+ void *state;
+ char *input;
+ int inputlen;
+ char *output;
+ int *outputlen;
+ {
+     struct krb_state *kstate = (struct krb_state *)state;
+ 
+     *outputlen = krb_mk_safe(input, output, inputlen, kstate->session,
+ 			     &kstate->localaddr, &kstate->remoteaddr);
+     return 0;
+ }
+ 
+ /*
+  * Decode integrity protection on the 'inputlen' bytes of data at
+  * 'input', using the state in 'state', placing a pointer to the
+  * output data and length in the buffers pointed to by 'output' and
+  * 'outputlen' respectively.
+  */
+ static const char *
+ krb_de_integrity(state, input, inputlen, output, outputlen)
+ void *state;
+ char *input;
+ int inputlen;
+ char **output;
+ int *outputlen;
+ {
+     struct krb_state *kstate = (struct krb_state *)state;
+     int code;
+     MSG_DAT m_data;
+ 
+     code = krb_rd_safe(input, inputlen, kstate->session,
+ 		       &kstate->remoteaddr, &kstate->localaddr, &m_data);
+     if (code) return krb_err_txt[code];
+     if (m_data.time_sec < kstate->prot_time_sec ||
+ 	(m_data.time_sec == kstate->prot_time_sec &&
+ 	 m_data.time_5ms < kstate->prot_time_5ms)) {
+ 	return krb_err_txt[RD_AP_TIME];
+     }
+     kstate->prot_time_sec = m_data.time_sec;
+     kstate->prot_time_5ms = m_data.time_5ms;
+ 
+     *output = m_data.app_data;
+     *outputlen = m_data.app_length;
+     return 0;
+ }
+ 
+ #ifndef NOPRIVACY
+ /*
+  * Apply privacy protection to the 'inputlen' bytes of data at 'input',
+  * using the state in 'state', placing the output data and length in the
+  * buffers pointed to by 'output' and 'outputlen' respectively.
+  */
+ static const char *
+ krb_en_privacy(state, input, inputlen, output, outputlen)
+ void *state;
+ char *input;
+ int inputlen;
+ char *output;
+ int *outputlen;
+ {
+     struct krb_state *kstate = (struct krb_state *)state;
+ 
+     *outputlen = krb_mk_priv(input, output, inputlen, kstate->schedule,
+ 			     kstate->session, &kstate->localaddr,
+ 			     &kstate->remoteaddr);
+     return 0;
+ }
+ 
+ /*
+  * Decode privacy protection on the 'inputlen' bytes of data at
+  * 'input', using the state in 'state', placing a pointer to the
+  * output data and length in the buffers pointed to by 'output' and
+  * 'outputlen' respectively.
+  */
+ static const char *
+ krb_de_privacy(state, input, inputlen, output, outputlen)
+ void *state;
+ char *input;
+ int inputlen;
+ char **output;
+ int *outputlen;
+ {
+     struct krb_state *kstate = (struct krb_state *)state;
+     int code;
+     MSG_DAT m_data;
+ 
+     code = krb_rd_priv(input, inputlen, kstate->schedule, kstate->session,
+ 		       &kstate->remoteaddr, &kstate->localaddr, &m_data);
+     if (code) return krb_err_txt[code];
+     if (m_data.time_sec < kstate->prot_time_sec ||
+ 	(m_data.time_sec == kstate->prot_time_sec &&
+ 	 m_data.time_5ms < kstate->prot_time_5ms)) {
+ 	return krb_err_txt[RD_AP_TIME];
+     }
+     kstate->prot_time_sec = m_data.time_sec;
+     kstate->prot_time_5ms = m_data.time_5ms;
+ 
+     *output = m_data.app_data;
+     *outputlen = m_data.app_length;
+     return 0;
+ }
+ #endif /* !NOPRIVACY */
+ 
+ static afs_string_to_key P((char *str, des_cblock *key, char *cell));
+ 
+ /*
+  * Kerberos set srvtab filename
+  * Accepts: name of srvtab file to use in reading authenticators
+  */
+ int kerberos_set_srvtab(fname)
+ char *fname;
+ {
+     srvtab = fname;
+     return 0;
+ }
+ 
+ /*
+  * Kerberos get srvtab filename
+  * Returns: name of srvtab file to use in reading authenticators
+  */
+ char *kerberos_get_srvtab()
+ {
+     return srvtab;
+ }
+ 
+ static use_key(user, instance, realm, key, returned_key)
+ char *user;
+ char *instance;
+ char *realm;
+ des_cblock key;
+ des_cblock returned_key;
+ {
+     memcpy (returned_key, key, sizeof(des_cblock));
+     return 0;
+ }
+ 
+ /*
+  * Securely verify the plaintext password 'passwd' for user 'user'
+  * against the Kerberos database.  "service" is the name of a service
+  * we can verify the returned ticket against.  Returns 1 for success,
+  * 0 for failure.  On failure, 'reply' is filled in with a pointer to
+  * the reason.
+  */
+ int kerberos_verify_password(user, passwd, service, reply)
+ char *user;
+ char *passwd;
+ char *service;
+ const char **reply;
+ {
+     int result;
+     des_cblock key;
+     char tfname[40];
+     char realm[REALM_SZ];
+     char cell[REALM_SZ];
+     char hostname[MAXHOSTNAMELEN+1];
+     char phost[MAXHOSTNAMELEN+1];
+     KTEXT_ST authent;
+     char instance[INST_SZ];
+     AUTH_DAT kdata;
+ 
+     if (krb_get_lrealm(realm,1)) return 0;
+ 
+     sprintf(tfname, "/tmp/tkt_imapd_%d", getpid());
+     krb_set_tkt_string(tfname);
+ 
+     /* First try Kerberos string-to-key */
+     des_string_to_key(passwd, key);
+     
+     result = krb_get_in_tkt(user, "", realm,
+ 			    "krbtgt", realm, 1, use_key, NULL, key);
+ 
+     if (result == INTK_BADPW) {
+ 	/* Now try andrew string-to-key */
+ 	strcpy(cell, realm);
+ 	lcase(cell);
+ 	afs_string_to_key(passwd, &key, cell);
+     
+ 	result = krb_get_in_tkt(user, "", realm,
+ 				"krbtgt", realm, 1, use_key, NULL, key);
+     }
+ 
+     memset(key, 0, sizeof(key));
+ 
+     if (result != 0) {
+ 	dest_tkt();
+ 	*reply = krb_err_txt[result];
+ 	return 0;
+     }
+ 
+     /* Check validity of returned ticket */
+     gethostname(hostname, sizeof(hostname));
+     strcpy(phost, krb_get_phost(hostname));
+     result = krb_mk_req(&authent, service, phost, realm, 0);
+     if (result != 0) {
+ 	memset(&authent, 0, sizeof(authent));
+ 	dest_tkt();
+ 	*reply = krb_err_txt[result];
+ 	return 0;
+     }
+     strcpy(instance, "*");
+     result = krb_rd_req(&authent, service, instance, 0L, &kdata, srvtab);
+     memset(&authent, 0, sizeof(authent));
+     memset(kdata.session, 0, sizeof(kdata.session));
+     if (result != 0 || strcmp(kdata.pname, user) != 0 || kdata.pinst[0] ||
+ 	strcmp(kdata.prealm, realm) != 0) {
+ 	if (result != 0) {
+ 	    *reply = krb_err_txt[result];
+ 	}
+ 	else {
+ 	    *reply = "Kerberos ID does not match user name";
+ 	}
+ 	result = 0;
+     }
+     else result = 1;
+ 
+     dest_tkt();
+     return result;
+ }
+ 
+ /* andrewstk.c -- afs string to key function
+  *
+  * Code taken from AuthMan from University of Michigan
+  */
+ 
+ /* forward declarations */
+ static afs_transarc_StringToKey P((char *str, char *cell, des_cblock *key));
+ static afs_cmu_StringToKey P((char *str, char *cell, des_cblock *key));
+ 
+ extern char *crypt();
+ 
+ /* This defines the Andrew string_to_key function.  It accepts a password
+  * string as input and converts its via a one-way encryption algorithm to a DES
+  * encryption key.  It is compatible with the original Andrew authentication
+  * service password database.
+  */
+ 
+ static
+ afs_cmu_StringToKey (str, cell, key)
+ char *str;
+ char *cell;                  /* cell for password */
+ des_cblock *key;
+ {   char  password[8+1];                /* crypt is limited to 8 chars anyway */
+     int   i;
+     int   passlen;
+ 
+     memset(key, 0, sizeof(des_cblock));
+     memset((void *)password, 0, sizeof(password));
+ 
+     strncpy (password, cell, 8);
+     passlen = strlen (str);
+     if (passlen > 8) passlen = 8;
+ 
+     for (i=0; i<passlen; i++)
+         password[i] = str[i] ^ cell[i];
+ 
+     for (i=0;i<8;i++)
+         if (password[i] == '\0') password[i] = 'X';
+ 
+     /* crypt only considers the first 8 characters of password but for some
+        reason returns eleven characters of result (plus the two salt chars). */
+     strncpy((void *)key, crypt(password, "p1") + 2, sizeof(des_cblock));
+ 
+     /* parity is inserted into the LSB so leftshift each byte up one bit.  This
+        allows ascii characters with a zero MSB to retain as much significance
+        as possible. */
+     {   char *keybytes = (char *)key;
+         unsigned int temp;
+ 
+         for (i = 0; i < 8; i++) {
+             temp = (unsigned int) keybytes[i];
+             keybytes[i] = (unsigned char) (temp << 1);
+         }
+     }
+     des_fixup_key_parity (key);
+ }
+ 
+ static
+ afs_transarc_StringToKey (str, cell, key)
+ char *str;
+ char *cell;                  /* cell for password */
+ des_cblock *key;
+ {   des_key_schedule schedule;
+     char temp_key[8];
+     char ivec[8];
+     char password[BUFSIZ];
+     int  passlen;
+ 
+     strncpy (password, str, sizeof(password));
+     if ((passlen = strlen (password)) < sizeof(password)-1)
+         strncat (password, cell, sizeof(password)-passlen);
+     if ((passlen = strlen(password)) > sizeof(password)) passlen = sizeof(password);
+ 
+     memcpy (ivec, "kerberos", 8);
+     memcpy (temp_key, "kerberos", 8);
+     des_fixup_key_parity ((void *)temp_key);
+     des_key_sched (temp_key, schedule);
+     des_cbc_cksum (password, ivec, passlen, schedule, ivec);
+ 
+     memcpy (temp_key, ivec, 8);
+     des_fixup_key_parity ((void *)temp_key);
+     des_key_sched (temp_key, schedule);
+     des_cbc_cksum (password, (void *)key, passlen, schedule, ivec);
+ 
+     des_fixup_key_parity (key);
+ }
+ 
+ static afs_string_to_key(str, key, cell)
+ char *str;
+ des_cblock *key;
+ char *cell;                  /* cell for password */
+ {
+     if (strlen(str) > 8) {
+ 	afs_transarc_StringToKey (str, cell, key);
+     }
+     else {
+ 	afs_cmu_StringToKey (str, cell, key);
+     }
+ }
+ 
diff -c -N c-client.pure/auth_krb.c c-client/auth_krb.c
*** c-client.pure/auth_krb.c	Thu Jan  1 01:00:00 1970
--- c-client/auth_krb.c	Sat Feb  5 14:44:02 2000
***************
*** 0 ****
--- 1,87 ----
+ /*
+  * Program:	Kerberos authenticator
+  *
+  * Author:	Mark Crispin
+  *		Networks and Distributed Computing
+  *		Computing & Communications
+  *		University of Washington
+  *		Administration Building, AG-44
+  *		Seattle, WA  98195
+  *		Internet: MRC@CAC.Washington.EDU
+  *
+  * Date:	1 May 1996
+  * Last Edited:	2 April 1998
+  *
+  * Copyright 1998 by the University of Washington.
+  *
+  *  Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notice appears in all copies and that both the
+  * above copyright notice and this permission notice appear in supporting
+  * documentation, and that the name of the University of Washington not be
+  * used in advertising or publicity pertaining to distribution of the software
+  * without specific, written prior permission.  This software is made available
+  * "as is", and
+  * THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+  * WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+  * NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+  * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+  * (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+  * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  */
+ 
+ /* Thanks to Daniel A. Root at CMU who contributed the original version */
+ 
+ #include "acte_krb.c"
+ 
+ long auth_krb_client (authchallenge_t challenger,authrespond_t responder,
+ 		      NETMBX *mb,void *stream,unsigned long *trial,char *user);
+ char *auth_krb_server (authresponse_t responder,int argc,char *argv[]);
+ 
+ AUTHENTICATOR auth_krb = {
+   "KERBEROS_V4",		/* authenticator name */
+   NIL,				/* always valid */
+   auth_krb_client,		/* client method */
+   NIL,				/* server method */
+   NIL				/* next authenticator */
+ };
+ 
+ /* Client authenticator
+  * Accepts: challenger function
+  *	    responder function
+  *	    parsed network mailbox structure
+  *	    stream argument for functions
+  *	    pointer to trial number
+  *	    returned user name
+  * Returns: T if success, NIL otherwise
+  */
+ 
+ long auth_krb_client (authchallenge_t challenger,authrespond_t responder,
+ 		      NETMBX *mb,void *stream,unsigned long *trial,char *user)
+ {
+   struct acte_client *mech;
+   void *challenge;
+   char *response;
+   unsigned long clen, rlen;
+   struct krb_state *state;
+   int rc;
+   mech = &krb_acte_client;
+   *trial = 0;			/* don't retry if failure */
+   user[0] = '\0';		/* can't help much on this */
+ 				/* fetch proper service tickets */
+   if (mech->start ("imap",mb->host,0,ACTE_PROT_NONE,0,0,0,&state))
+     return NIL;
+ 				/* get challenge/response */
+   do {				/* until ACTE_DONE or something fails */
+     if (!(challenge = (*challenger) (stream,&clen))) return NIL;
+     rc = mech->auth (state,clen,challenge,&rlen,&response);
+     if (rc == ACTE_FAIL) return NIL;
+     fs_give ((void **) &challenge);
+     if (!((*responder) (stream,response,rlen))) return NIL;
+   } while (rc != ACTE_DONE);
+   mech->free_state (state);	/* clean up */
+   return T;
+ }
diff -c -N c-client.pure/auth_ssl.c c-client/auth_ssl.c
*** c-client.pure/auth_ssl.c	Thu Jan  1 01:00:00 1970
--- c-client/auth_ssl.c	Sat Feb  5 14:44:03 2000
***************
*** 0 ****
--- 1,438 ----
+ /*
+  * V1.4 - 08 Jan 2000
+  *
+  * Pine v4 SSL add-on hack
+  *
+  * Copyright 1999 Nick Sayer, All Rights Reserved
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  * 1. Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+  * 3. Redistributions of either source or binary form must not
+  *    violate US export laws.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+  * SUCH DAMAGE.
+  *
+  */
+ 
+ #include <openssl/ssl.h>
+ 
+ static SSL_CTX *ctx;
+ 
+ struct ssl_stream {
+ 	TCPSTREAM *tcp_stream;
+ 	SSL *ssl;
+ 	char *read_buf;
+ 	int read_len;
+ };
+ 
+ typedef struct ssl_stream SSL_STREAM;
+ 
+ static long ssl_getbuffer();
+ static long ssl_readmore();
+ static void ssl_clear();
+ 
+ /*
+  * Open a normal connection to the host/service/port triple.
+  * Mostly, those 3 params will be just passed to tcp_open().
+  * Note that the 'service' has already had the ALT_*NAME
+  * substitution, which means we will be passing tcp_open()
+  * a name starting with '*'. This will make tcp_open() not
+  * do a bunch of read-ahead stuff we don't want it to do.
+  *
+  * Return either a void* that will be passed on future calls
+  * or NIL for failure.
+  */
+ static void *ssl_open(host, service, port)
+ char *host,*service;
+ unsigned long port;
+ {
+   SSL_STREAM *ssl;
+ 
+   ssl=(SSL_STREAM *)malloc(sizeof(SSL_STREAM));
+ 
+   if ((ssl->ssl=SSL_new(ctx))==NULL)
+   {
+     mm_log("SSL library error, should never happen!",ERROR);
+     free(ssl);
+     return NIL;
+   }
+   if ((ssl->tcp_stream=tcp_open(host,service,port))==NULL)
+   {
+     SSL_free(ssl->ssl);
+     free(ssl);
+     return NIL; /* tcp_open will mm_log() */
+   }
+ 
+   SSL_set_rfd(ssl->ssl,ssl->tcp_stream->tcpsi);
+   SSL_set_wfd(ssl->ssl,ssl->tcp_stream->tcpso);
+   SSL_set_read_ahead(ssl->ssl,1);
+   if (SSL_connect(ssl->ssl)<0)
+   {
+     char string1[120],string2[150];
+ 
+     ERR_error_string(ERR_get_error(), string1);
+     sprintf(string2,"SSL protocol error: %s",string1);
+     mm_log(string2,ERROR);
+     tcp_close(ssl->tcp_stream);
+     SSL_free(ssl->ssl);
+     free(ssl);
+     return NIL;
+   }
+ 
+   {
+     char string[120];
+     int b;
+ 
+     SSL_get_cipher_bits(ssl->ssl,&b);
+     sprintf(string,"SSL connection type: %s (%d bits)",
+       SSL_get_cipher(ssl->ssl),b);
+     mm_log(string,WARN);
+   }
+ 
+   /*
+    * At this point, we really should analyze and/or display
+    * the server certificate.
+    */
+ 
+   ssl->read_buf=NULL;
+   ssl->read_len=0;
+ 
+   return ssl;
+ }
+ 
+ /*
+  * I don't even know what this is for. In unix_tcp.c, this section
+  * of code appears to do the rsh-to-imap style of open.
+  * Returning NIL always appears to work ok.
+  */
+ static void *ssl_aopen(mb, service, usrbuf)
+ NETMBX *mb;
+ char *service,*usrbuf;
+ {
+   return NIL;
+ }
+ 
+ /*
+  * Get a line of input from the given stream.
+  * Return it in a freshly malloc()ed buffer.
+  * Presume line termination is two characters long,
+  * starting with either \015 or \012. Eat the second
+  * character, and replace the first with \0 (C style
+  * end of line).
+  *
+  * Input should not block. If you can't read before
+  * you get a CR or LF, return NIL and store what you
+  * read so far so that perhaps you can finish it on the
+  * next call.
+  */
+ static char *ssl_getline(stream)
+ SSL_STREAM *stream;
+ {
+   int n;
+   char *outline;
+ 
+   for(n=0;;n++) {
+     if (n>=stream->read_len)
+       if (!ssl_readmore(stream))
+ 	return NIL;
+ 
+     if (*(stream->read_buf+n)=='\n' || *(stream->read_buf+n)=='\r')
+       break;
+   }
+ 
+   outline=malloc(n+3);
+   while(ssl_getbuffer(stream,n+2,outline)==NIL) mm_log("getbufr NIL!",NIL);
+   outline[n]='\0';
+   outline=realloc(outline,n+1);
+   if (outline==NULL)
+     mm_log("realloc ate output line! Should never happen!",ERROR);
+ 
+   return outline;
+ }
+ 
+ /*
+  * Fill a buffer from the given stream. Note that the size is actually
+  * one more than the read size, since this routine is supposed to \0
+  * terminate the buffer (believe it or not).
+  *
+  * This routine should not block. Return T if you satisfy the read,
+  * otherwise return NIL and buffer the stuff you read so far in the
+  * hope that the next try will work.
+  *
+  */
+ static long ssl_getbuffer(stream, size, buffer)
+ SSL_STREAM *stream;
+ unsigned long size;
+ char *buffer;
+ {
+ 
+   while(size>stream->read_len && ssl_readmore(stream)) ;
+ 
+   if (size>stream->read_len)
+     return NIL;
+ 
+   bcopy(stream->read_buf,buffer,size);
+ 
+   ssl_clear(stream,size);
+ 
+   buffer[size]='\0'; /* THAT'S friggin' goofey! Check tcp_unix.c if you
+                      don't believe me */
+   return T;
+ }
+ 
+ /*
+  * This is an internal routine. It extends the readahead buffer.
+  * It takes an SSL structure pointer, and if there's any data
+  * pending, lengthens the buffer by that much and reads it in.
+  * Returns T if it did any work, NIL otherwise.
+  */
+ 
+ static long ssl_readmore(ssl)
+ SSL_STREAM *ssl;
+ {
+   int n;
+ 
+   {
+     char toss; /* "kick start" SSL_pending */
+     SSL_read(ssl->ssl,&toss,0);
+   }
+ 
+   if ((n=SSL_pending(ssl->ssl))<=0) {
+     mm_log("ssl_readmore returning NIL",NIL);
+     return NIL;
+   }
+ 
+   if ((ssl->read_buf=realloc(ssl->read_buf,ssl->read_len+n))==NULL) {
+     mm_log("SSL memory allocation error!",ERROR);
+     return NIL;
+   }
+ 
+   if (SSL_read(ssl->ssl,ssl->read_buf+ssl->read_len,n)!=n) {
+     mm_log("SSL short read, should never happen !",ERROR);
+     return NIL;
+   }
+ 
+   ssl->read_len+=n;
+ 
+   return T;
+ }
+ 
+ /*
+  * n bytes have been read from the buffer. Close ranks.
+  */
+ static void ssl_clear(stream,n)
+ SSL_STREAM *stream;
+ int n;
+ {
+   int i;
+ 
+   if (n>stream->read_len) {
+     mm_log("clearing more than available! Should never happen!",ERROR);
+     return ;
+   }
+ 
+   if (n==stream->read_len) {
+     free(stream->read_buf);
+     stream->read_buf=NULL;
+     stream->read_len=0;
+     return;
+   }
+ 
+   bcopy(stream->read_buf+n,stream->read_buf,stream->read_len-n);
+ 
+   stream->read_buf=realloc(stream->read_buf,stream->read_len-n);
+   if (stream->read_buf == NULL) {
+     mm_log("memory shrink failed!",ERROR);
+     stream->read_len=0;
+     return;
+   }
+   stream->read_len-=n;
+ }
+ 
+ /*
+  * send the sized string to stdout. Return T on success, NIL on
+  * failure. I suppose this is supposed to be non-blocking, but
+  * I don't really care. Pine doesn't do a lot of talking.
+  */
+ static long ssl_sout(stream, string, size)
+ SSL_STREAM *stream;
+ char *string;
+ unsigned long size;
+ {
+   return (size==SSL_write(stream->ssl,string,size));
+ }
+ 
+ /*
+  * Same as above, but figure out the length with strlen()
+  */
+ static long ssl_soutr(stream, string)
+ SSL_STREAM *stream;
+ char *string;
+ {
+   return ssl_sout(stream,string,strlen(string));
+ }
+ 
+ /*
+  * close the named stream
+  */
+ static void ssl_close(stream)
+ SSL_STREAM *stream;
+ {
+   tcp_close(stream->tcp_stream);
+   SSL_free(stream->ssl);
+   if (stream->read_buf!=NULL)
+     free(stream->read_buf);
+   free(stream);
+ }
+ 
+ /*
+  * The rest of these just use the underlying tcp_driver services,
+  * so I don't feel like documenting them.
+  */
+ static char *ssl_localhost(stream)
+ SSL_STREAM *stream;
+ {
+   return tcp_localhost(stream->tcp_stream);
+ }
+ 
+ static char *ssl_remotehost(stream)
+ SSL_STREAM *stream;
+ {
+   return tcp_remotehost(stream->tcp_stream);
+ }
+ 
+ static unsigned long ssl_port(stream)
+ SSL_STREAM *stream;
+ {
+   return tcp_port(stream->tcp_stream);
+ }
+ 
+ static char *ssl_host(stream)
+ SSL_STREAM *stream;
+ {
+   return tcp_host(stream->tcp_stream);
+ }
+ 
+ /*
+  * This is our real interface with Pine.
+  */
+ static NETDRIVER ssldriver = {
+   ssl_open,
+   ssl_aopen,
+   ssl_getline,
+   ssl_getbuffer,
+   ssl_soutr,
+   ssl_sout,
+   ssl_close,
+   ssl_host,
+   ssl_remotehost,
+   ssl_port,
+   ssl_localhost,
+ };
+ 
+ /*
+  * This is our dummy initialization routine. See below for how this
+  * ends up getting called. This driver must make a series of calls
+  * to inform the c-client layer that an alternate net driver exists.
+  * Users can select the alternate driver by matching the parameter
+  * to SET_ALTDRIVERNAME after a "/" in a remote server spec
+  * (e.g. {localhost/imap/ssl}). When it is selected, the standard
+  * service names (imap, pop3, smtp and nntp) will be substituted
+  * for the alternate ones listed. The '*' will be noted by tcp_open()
+  * and stripped off. Also, the port numbers (used if either the user
+  * specifies it or getservbyname() fails) will be substituted as well.
+  */
+ static long ssl_init()
+ {
+   mail_parameters(NIL,SET_ALTDRIVER,&ssldriver);
+   mail_parameters(NIL,SET_ALTDRIVERNAME,"ssl");
+ 
+   /*
+    * We have to tack a '*' on the front of the service. This will
+    * disable some adverse look-ahead behavior in tcp_open.
+    * We have to do this because we won't be using any of the
+    * other functionality of the TCP netdriver, as SSL deals with
+    * the socket directly.
+    */
+ 
+   mail_parameters(NIL,SET_ALTIMAPNAME,"*imaps");
+   mail_parameters(NIL,SET_ALTPOPNAME,"*pop3s");
+   mail_parameters(NIL,SET_ALTNNTPNAME,"*nntps");
+   mail_parameters(NIL,SET_ALTSMTPNAME,"*smtps");
+ 
+   mail_parameters(NIL,SET_ALTIMAPPORT,(void *) 993);
+   mail_parameters(NIL,SET_ALTPOPPORT,(void *) 995);
+   mail_parameters(NIL,SET_ALTNNTPPORT,(void *) 563);
+   mail_parameters(NIL,SET_ALTSMTPPORT,(void *) 465);
+ 
+   SSL_library_init();
+   SSL_load_error_strings();
+ 
+   /*
+    * A few SSL/TLS servers refuse to accept any other method but
+    * their own (notably SIMS 3.5 which only likes SSLv3) for connections.
+    *
+    * According to the now-obsolete SSLv3 specification, SSLv3 servers
+    * should accept SSLv2 client hellos, but this is not always the case
+    * since RFC 2246 (TLS) calls for SSLv2's demise. RFC 2246 also indicates
+    * that TLSv1 servers should accept SSLv3 client hellos since the two
+    * protocols are similar.
+    *
+    * By specifying EXTRACFLAGS=-DSSLV3ONLYSERVER at the end of the
+    * usual build command, the client will speak only SSLv3 by default,
+    * thus alleviating some difficulties where TLSv1/SSLv2 are not supported.
+    * If EXTRACFLAGS=-DTLSV1ONLYSERVER is specified, the client will
+    * try to connect using TLSv1. If neither is specified, it will speak
+    * SSLv3 and can rollback to SSLv2 (using SSLv23_client_method()).
+    *
+    * See <openssl/ssl.h> for further information.
+    *
+    */
+ 
+ #if defined(SSLV3ONLYSERVER) && !defined(TLSV1ONLYSERVER)
+   ctx=SSL_CTX_new(SSLv3_client_method());
+ #elif defined(TLSV1ONLYSERVER) && !defined(SSLV3ONLYSERVER)
+   ctx=SSL_CTX_new(TLSv1_client_method());
+ #else
+   ctx=SSL_CTX_new(SSLv23_client_method());
+ #endif
+ 
+   return NIL; /* Must always return NIL or Pine will think the
+ 		 AUTHENTICATOR struct actually means something */
+ };
+ 
+ /*
+  * We really aren't an authenticator. But it's the most straightforward
+  * way to hook into pine. We need to run ssl_init() at startup.
+  * By calling ourselves an EXTRAAUTHENTICATORS, we get a line in
+  * linkage.c to link this structure into the list of authenticators.
+  * In doing so, it calls the valid() function to see whether or not
+  * this authenticator works on this machine. The answer will always be
+  * "no", but we can hook in our own way and Pine will be n'er the
+  * wiser.
+  */
+ 
+ AUTHENTICATOR auth_ssl={
+   T,
+   "ignore",
+   ssl_init,
+   NULL,
+   NULL,
+   NULL,
+ };
diff -c -N c-client.pure/auths.c c-client/auths.c
*** c-client.pure/auths.c	Sat Feb  5 18:29:51 2000
--- c-client/auths.c	Sat Feb  5 16:56:55 2000
***************
*** 1,2 ****
--- 1,3 ----
+ #include "auth_ssl.c"
  #include "auth_md5.c"
  #include "auth_log.c"
diff -c -N c-client.pure/auths_nt.c c-client/auths_nt.c
*** c-client.pure/auths_nt.c	Thu Jan  1 01:00:00 1970
--- c-client/auths_nt.c	Sat Feb  5 14:44:03 2000
***************
*** 0 ****
--- 1 ----
+ #include "auth_log.c"
Binary files c-client.pure/baklib.a and c-client/baklib.a differ
Binary files c-client.pure/c-client.a and c-client/c-client.a differ
diff -c -N c-client.pure/cclient.dsp c-client/cclient.dsp
*** c-client.pure/cclient.dsp	Thu Jan  1 01:00:00 1970
--- c-client/cclient.dsp	Sat Feb  5 14:44:03 2000
***************
*** 0 ****
--- 1,283 ----
+ # Microsoft Developer Studio Project File - Name="cclient" - Package Owner=<4>
+ # Microsoft Developer Studio Generated Build File, Format Version 6.00
+ # ** DO NOT EDIT **
+ 
+ # TARGTYPE "Win32 (x86) Static Library" 0x0104
+ 
+ CFG=cclient - Win32 Debug
+ !MESSAGE This is not a valid makefile. To build this project using NMAKE,
+ !MESSAGE use the Export Makefile command and run
+ !MESSAGE 
+ !MESSAGE NMAKE /f "cclient.mak".
+ !MESSAGE 
+ !MESSAGE You can specify a configuration when running NMAKE
+ !MESSAGE by defining the macro CFG on the command line. For example:
+ !MESSAGE 
+ !MESSAGE NMAKE /f "cclient.mak" CFG="cclient - Win32 Debug"
+ !MESSAGE 
+ !MESSAGE Possible choices for configuration are:
+ !MESSAGE 
+ !MESSAGE "cclient - Win32 Release" (based on "Win32 (x86) Static Library")
+ !MESSAGE "cclient - Win32 Debug" (based on "Win32 (x86) Static Library")
+ !MESSAGE 
+ 
+ # Begin Project
+ # PROP AllowPerConfigDependencies 0
+ # PROP Scc_ProjName ""
+ # PROP Scc_LocalPath ""
+ CPP=cl.exe
+ RSC=rc.exe
+ 
+ !IF  "$(CFG)" == "cclient - Win32 Release"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "Release"
+ # PROP BASE Intermediate_Dir "Release"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "Release"
+ # PROP Intermediate_Dir "Release"
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+ # ADD CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+ # ADD BASE RSC /l 0x409 /d "NDEBUG"
+ # ADD RSC /l 0x409 /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LIB32=link.exe -lib
+ # ADD BASE LIB32 /nologo
+ # ADD LIB32 /nologo
+ 
+ !ELSEIF  "$(CFG)" == "cclient - Win32 Debug"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 1
+ # PROP BASE Output_Dir "Debug"
+ # PROP BASE Intermediate_Dir "Debug"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 1
+ # PROP Output_Dir "Debug"
+ # PROP Intermediate_Dir "Debug"
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+ # ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+ # ADD BASE RSC /l 0x409 /d "_DEBUG"
+ # ADD RSC /l 0x409 /d "_DEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LIB32=link.exe -lib
+ # ADD BASE LIB32 /nologo
+ # ADD LIB32 /nologo
+ 
+ !ENDIF 
+ 
+ # Begin Target
+ 
+ # Name "cclient - Win32 Release"
+ # Name "cclient - Win32 Debug"
+ # Begin Group "Source Files"
+ 
+ # PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+ # Begin Source File
+ 
+ SOURCE=.\dummynt.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\fdstring.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\flstring.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\imap4r1.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\mail.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\mbxnt.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\mh.c
+ # PROP Exclude_From_Build 1
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\mhnt.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\misc.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\mtxnt.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\netmsg.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\news.c
+ # PROP Exclude_From_Build 1
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\newsnt.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\newsrc.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\nntp.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\os_nt.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\pop3.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\pseudo.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\rfc822.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\smanager.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\smtp.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\tenexnt.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\unixnt.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\utf8.c
+ # End Source File
+ # End Group
+ # Begin Group "Header Files"
+ 
+ # PROP Default_Filter "h;hpp;hxx;hm;inl"
+ # Begin Source File
+ 
+ SOURCE=.\auths.c
+ 
+ !IF  "$(CFG)" == "cclient - Win32 Release"
+ 
+ # PROP Ignore_Default_Tool 1
+ # Begin Custom Build - Creating auths.c...
+ InputDir=.
+ InputPath=.\auths.c
+ 
+ "$(InputDir)\auths.c" : $(SOURCE) "$(INTDIR)" "$(OUTDIR)"
+ 	copy $(InputDir)\auths_nt.c $(InputDir)\auths.c
+ 
+ # End Custom Build
+ 
+ !ELSEIF  "$(CFG)" == "cclient - Win32 Debug"
+ 
+ # PROP Ignore_Default_Tool 1
+ # Begin Custom Build - Creating auths.c...
+ InputDir=.
+ InputPath=.\auths.c
+ 
+ "$(InputDir)\auths.c" : $(SOURCE) "$(INTDIR)" "$(OUTDIR)"
+ 	copy $(InputDir)\auths_nt.c $(InputDir)\auths.c
+ 
+ # End Custom Build
+ 
+ !ENDIF 
+ 
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\linkage.h
+ 
+ !IF  "$(CFG)" == "cclient - Win32 Release"
+ 
+ USERDEP__LINKA="link_nt.h"	
+ # Begin Custom Build - Creating linkage.h...
+ InputDir=.
+ InputPath=.\linkage.h
+ 
+ "$(InputDir)\linkage.h" : $(SOURCE) "$(INTDIR)" "$(OUTDIR)"
+ 	copy $(InputDir)\link_nt.h $(InputDir)\linkage.h
+ 
+ # End Custom Build
+ 
+ !ELSEIF  "$(CFG)" == "cclient - Win32 Debug"
+ 
+ USERDEP__LINKA="link_nt.h"	
+ # Begin Custom Build - Creating linkage.h...
+ InputDir=.
+ InputPath=.\linkage.h
+ 
+ "$(InputDir)\linkage.h" : $(SOURCE) "$(INTDIR)" "$(OUTDIR)"
+ 	copy $(InputDir)\link_nt.h $(InputDir)\linkage.h
+ 
+ # End Custom Build
+ 
+ !ENDIF 
+ 
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\osdep.h
+ 
+ !IF  "$(CFG)" == "cclient - Win32 Release"
+ 
+ USERDEP__OSDEP="os_nt.h"	
+ # Begin Custom Build - Creating osdep.h...
+ InputDir=.
+ InputPath=.\osdep.h
+ 
+ "$(InputDir)\osdep.h" : $(SOURCE) "$(INTDIR)" "$(OUTDIR)"
+ 	copy $(InputDir)\os_nt.h $(InputDir)\osdep.h
+ 
+ # End Custom Build
+ 
+ !ELSEIF  "$(CFG)" == "cclient - Win32 Debug"
+ 
+ USERDEP__OSDEP="os_nt.h"	
+ # Begin Custom Build - Creating osdep.h...
+ InputDir=.
+ InputPath=.\osdep.h
+ 
+ "$(InputDir)\osdep.h" : $(SOURCE) "$(INTDIR)" "$(OUTDIR)"
+ 	copy $(InputDir)\os_nt.h $(InputDir)\osdep.h
+ 
+ # End Custom Build
+ 
+ !ENDIF 
+ 
+ # End Source File
+ # End Group
+ # End Target
+ # End Project
diff -c -N c-client.pure/ckp_krb.c c-client/ckp_krb.c
*** c-client.pure/ckp_krb.c	Thu Jan  1 01:00:00 1970
--- c-client/ckp_krb.c	Sat Feb  5 14:44:02 2000
***************
*** 0 ****
--- 1,49 ----
+ /*
+  * Program:	Kerberos check password
+  *
+  * Author:	Mark Crispin
+  *		Networks and Distributed Computing
+  *		Computing & Communications
+  *		University of Washington
+  *		Administration Building, AG-44
+  *		Seattle, WA  98195
+  *		Internet: MRC@CAC.Washington.EDU
+  *
+  * Date:	1 August 1988
+  * Last Edited:	2 December 1997
+  *
+  * Copyright 1997 by the University of Washington
+  *
+  *  Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notice appears in all copies and that both the
+  * above copyright notice and this permission notice appear in supporting
+  * documentation, and that the name of the University of Washington not be
+  * used in advertising or publicity pertaining to distribution of the software
+  * without specific, written prior permission.  This software is made available
+  * "as is", and
+  * THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+  * WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+  * NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+  * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+  * (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+  * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  */
+ 
+ /* Check password
+  * Accepts: login passwd struct
+  *	    password string
+  *	    argument count
+  *	    argument vector
+  * Returns: passwd struct if password validated, NIL otherwise
+  */
+ 
+ struct passwd *checkpw (struct passwd *pw,char *pass,int argc,char *argv[])
+ {
+   char *reply;
+   return kerberos_verify_password (pw->pw_name,pass,&reply) ? pw : NIL;
+ }
+ 
diff -c -N c-client.pure/ckp_md5.c c-client/ckp_md5.c
*** c-client.pure/ckp_md5.c	Thu Jan  1 01:00:00 1970
--- c-client/ckp_md5.c	Sat Feb  5 14:44:02 2000
***************
*** 0 ****
--- 1,54 ----
+ /*
+  * Program:	MD5 check password
+  *
+  * Author:	Mark Crispin
+  *		Networks and Distributed Computing
+  *		Computing & Communications
+  *		University of Washington
+  *		Administration Building, AG-44
+  *		Seattle, WA  98195
+  *		Internet: MRC@CAC.Washington.EDU
+  *
+  * Date:	1 August 1988
+  * Last Edited:	9 December 1998
+  *
+  * Copyright 1998 by the University of Washington
+  *
+  *  Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notice appears in all copies and that both the
+  * above copyright notice and this permission notice appear in supporting
+  * documentation, and that the name of the University of Washington not be
+  * used in advertising or publicity pertaining to distribution of the software
+  * without specific, written prior permission.  This software is made available
+  * "as is", and
+  * THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+  * WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+  * NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+  * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+  * (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+  * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  */
+ 
+ /* Check password
+  * Accepts: login passwd struct
+  *	    password string
+  *	    argument count
+  *	    argument vector
+  * Returns: passwd struct if password validated, NIL otherwise
+  */
+ 
+ struct passwd *checkpw (struct passwd *pw,char *pass,int argc,char *argv[])
+ {
+   char *p;
+ 				/* verify password */
+   if (!(p = auth_md5_pwd (pw->pw_name)) || strcmp (pass,p)) pw = NIL;
+   if (p) {
+     memset (p,0,strlen (p));	/* erase sensitive information */
+     fs_give ((void **) &p);	/* flush erased password */
+   }
+   return pw;
+ }
diff -c -N c-client.pure/cns-14.c c-client/cns-14.c
*** c-client.pure/cns-14.c	Thu Jan  1 01:00:00 1970
--- c-client/cns-14.c	Sat Feb  5 14:44:02 2000
***************
*** 0 ****
--- 1,904 ----
+ /*
+  * Program:	CSN 11643 plane 14 conversion table
+  *
+  * Author:	Mark Crispin
+  *		Networks and Distributed Computing
+  *		Computing & Communications
+  *		University of Washington
+  *		Administration Building, AG-44
+  *		Seattle, WA  98195
+  *		Internet: MRC@CAC.Washington.EDU
+  *
+  * Date:	15 May 1998
+  * Last Edited:	24 July 1998
+  *
+  * Copyright 1998 by the University of Washington
+  *
+  *  Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notices appear in all copies and that both the
+  * above copyright notices and this permission notice appear in supporting
+  * documentation, and that the name of the University of Washington not be
+  * used in advertising or publicity pertaining to distribution of the software
+  * without specific, written prior permission.  This software is made
+  * available "as is", and
+  * THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+  * WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+  * NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+  * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING
+  * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+  * (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  */
+ 
+ /* CNS 11643 is the national standard of the Republic of China (Taiwan). */
+ 
+ #define MAX_CNS11643_KU_14 71
+ 
+ 
+ #define CNS14TOUNICODE(c,c1,ku,ten)					\
+   ((((ku = (c & 0x7f) - BASE_CNS11643_KU) < MAX_CNS11643_KU_14) &&	\
+     ((ten = (c1 & 0x7f) - BASE_CNS11643_TEN) < MAX_CNS11643_TEN)) ?	\
+    cns11643_14tab[ku][ten] : 0xfffd)
+ 
+ 
+ /* CNS 11643 plane 14 conversion table */
+ 
+ static const unsigned short
+   cns11643_14tab[MAX_CNS11643_KU_14][MAX_CNS11643_TEN] = {
+ {
+   {				/* ku 01 */
+     0x4e28,0x4e36,0x4e3f,0x4e85,0x4e05,0x4e04,0x5182,0x5196,0x5338,0x5369,
+     0x53b6,0x4e2a,0x4e87,0x4e49,0x51e2,0x4e46,0x4e8f,0x4ebc,0x4ebe,0x5166,
+     0x51e3,0x5204,0x529c,0x0000,0x5902,0x590a,0x5b80,0x5ddb,0x5e7a,0x5e7f,
+     0x5ef4,0x5f50,0x5f51,0x5f61,0x961d,0x0000,0x4e63,0x4e62,0x4ea3,0x5185,
+     0x4ec5,0x4ecf,0x4ece,0x4ecc,0x5184,0x5186,0x0000,0x0000,0x51e4,0x5205,
+     0x529e,0x529d,0x52fd,0x5300,0x533a,0x0000,0x5346,0x535d,0x5386,0x53b7,
+     0x0000,0x53cc,0x0000,0x53ce,0x5721,0x0000,0x5e00,0x5f0c,0x6237,0x6238,
+     0x6534,0x6535,0x65e0,0x0000,0x738d,0x4e97,0x4ee0,0x0000,0x0000,0x4ee7,
+     0x0000,0x4ee6,0x0000,0x0000,0x0000,0x0000,0x56d8,0x518b,0x518c,0x5199,
+     0x51e5,0x0000,0x520b,0x0000
+   },
+   {				/* ku 02 */
+     0x0000,0x5304,0x5303,0x5307,0x0000,0x531e,0x535f,0x536d,0x5389,0x53ba,
+     0x53d0,0x0000,0x53f6,0x53f7,0x53f9,0x0000,0x53f4,0x0000,0x0000,0x5724,
+     0x5904,0x5918,0x5932,0x5930,0x5934,0x0000,0x5975,0x0000,0x5b82,0x5bf9,
+     0x5c14,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x5e81,0x5e83,
+     0x5f0d,0x5f52,0x0000,0x5fca,0x5fc7,0x6239,0x0000,0x624f,0x65e7,0x672f,
+     0x6b7a,0x6c39,0x0000,0x0000,0x6c37,0x6c44,0x6c45,0x738c,0x7592,0x7676,
+     0x9093,0x9092,0x0000,0x0000,0x4e21,0x4e20,0x4e22,0x4e68,0x4e89,0x4e98,
+     0x4ef9,0x4eef,0x0000,0x0000,0x4ef8,0x4f06,0x4f03,0x4efc,0x4eee,0x4f16,
+     0x0000,0x4f28,0x4f1c,0x4f07,0x4f1a,0x4efa,0x4f17,0x514a,0x0000,0x5172,
+     0x0000,0x51b4,0x51b3,0x51b2
+   },
+   {				/* ku 03 */
+     0x0000,0x51e8,0x0000,0x5214,0x520f,0x5215,0x5218,0x52a8,0x0000,0x534b,
+     0x534f,0x0000,0x5350,0x0000,0x538b,0x0000,0x53be,0x0000,0x53d2,0x5416,
+     0x53ff,0x0000,0x5400,0x0000,0x5405,0x5413,0x5415,0x0000,0x0000,0x56e3,
+     0x5735,0x5736,0x5731,0x5732,0x58ee,0x5905,0x4e54,0x0000,0x5936,0x0000,
+     0x0000,0x0000,0x597a,0x0000,0x5986,0x0000,0x0000,0x5b86,0x5f53,0x5c18,
+     0x0000,0x5c3d,0x5c78,0x0000,0x0000,0x0000,0x0000,0x5c80,0x0000,0x5e08,
+     0x0000,0x0000,0x0000,0x0000,0x5ef5,0x5f0e,0x0000,0x0000,0x0000,0x5fd3,
+     0x5fda,0x0000,0x5fdb,0x0000,0x620f,0x625d,0x625f,0x6267,0x6257,0x9f50,
+     0x0000,0x65eb,0x65ea,0x0000,0x6737,0x0000,0x6732,0x6736,0x6b22,0x6bce,
+     0x0000,0x6c58,0x6c51,0x6c77
+   },
+   {				/* ku 04 */
+     0x6c3c,0x0000,0x6c5a,0x0000,0x6c53,0x706f,0x7072,0x706e,0x0000,0x0000,
+     0x7073,0x72b1,0x72b2,0x0000,0x738f,0x0000,0x0000,0x0000,0x793c,0x0000,
+     0x808d,0x808e,0x0000,0x827b,0x0000,0x8d71,0x8fb9,0x9096,0x909a,0x0000,
+     0x4e24,0x4e71,0x0000,0x4e9c,0x4f45,0x4f4a,0x4f39,0x4f37,0x0000,0x4f32,
+     0x4f42,0x0000,0x4f44,0x4f4b,0x0000,0x4f40,0x4f35,0x4f31,0x5151,0x0000,
+     0x5150,0x514e,0x0000,0x0000,0x519d,0x0000,0x51b5,0x51b8,0x51ec,0x5223,
+     0x5227,0x5226,0x521f,0x522b,0x5220,0x52b4,0x52b3,0x0000,0x5325,0x533b,
+     0x5374,0x0000,0x0000,0x0000,0x0000,0x0000,0x544d,0x0000,0x0000,0x543a,
+     0x0000,0x0000,0x5444,0x544c,0x5423,0x541a,0x5432,0x544b,0x5421,0x0000,
+     0x5434,0x5449,0x5450,0x5422
+   },
+   {				/* ku 05 */
+     0x543f,0x5451,0x545a,0x542f,0x0000,0x56e9,0x56f2,0x56f3,0x56ef,0x56ed,
+     0x56ec,0x56e6,0x5748,0x0000,0x5744,0x573f,0x573c,0x5753,0x5756,0x0000,
+     0x575f,0x5743,0x5758,0x5757,0x0000,0x0000,0x0000,0x5746,0x0000,0x573d,
+     0x0000,0x5742,0x5754,0x5755,0x58f1,0x58f2,0x58f0,0x590b,0x9ea6,0x56f1,
+     0x593d,0x0000,0x5994,0x598c,0x0000,0x599c,0x0000,0x0000,0x599f,0x0000,
+     0x599b,0x0000,0x5989,0x599a,0x0000,0x6588,0x0000,0x5b8d,0x0000,0x5bfe,
+     0x5bff,0x5bfd,0x5c2b,0x0000,0x5c84,0x5c8e,0x5c9c,0x0000,0x0000,0x5c85,
+     0x5df5,0x5e09,0x0000,0x0000,0x5e0b,0x0000,0x5e92,0x5e90,0x5f03,0x0000,
+     0x5f1e,0x5f63,0x0000,0x5fe7,0x5ffe,0x5fe6,0x5fdc,0x5fce,0x0000,0x5ffc,
+     0x5fdf,0x5fec,0x5ff6,0x0000
+   },
+   {				/* ku 06 */
+     0x5ff2,0x5ff0,0x5ff9,0x0000,0x6213,0x0000,0x0000,0x623b,0x623c,0x6282,
+     0x0000,0x0000,0x0000,0x6278,0x628b,0x0000,0x629e,0x62a5,0x629b,0x629c,
+     0x6299,0x628d,0x6285,0x629d,0x6275,0x0000,0x0000,0x0000,0x65f6,0x0000,
+     0x0000,0x0000,0x66f5,0x675b,0x0000,0x6754,0x6752,0x0000,0x6758,0x6744,
+     0x674a,0x6761,0x0000,0x6c7f,0x6c91,0x6c9e,0x0000,0x6c6e,0x6c7c,0x6c9f,
+     0x6c75,0x0000,0x6c56,0x6ca2,0x6c79,0x0000,0x6ca1,0x0000,0x6caa,0x6ca0,
+     0x0000,0x7079,0x7077,0x707e,0x0000,0x7075,0x707b,0x7264,0x0000,0x72bb,
+     0x72bc,0x72c7,0x72b9,0x72be,0x72b6,0x0000,0x0000,0x7398,0x0000,0x0000,
+     0x0000,0x0000,0x7593,0x7680,0x0000,0x7683,0x76c0,0x76c1,0x0000,0x0000,
+     0x77f4,0x77f5,0x0000,0x7acc
+   },
+   {				/* ku 07 */
+     0x7acd,0x7cfa,0x809f,0x8091,0x8097,0x8094,0x0000,0x8286,0x828c,0x0000,
+     0x8295,0x0000,0x866c,0x0000,0x8fb5,0x8fbe,0x8fc7,0x0000,0x8fc1,0x90a9,
+     0x90a4,0x0000,0x0000,0x0000,0x90a8,0x9627,0x9626,0x962b,0x9633,0x9634,
+     0x9629,0x4e3d,0x0000,0x4e9d,0x4f93,0x4f8a,0x0000,0x0000,0x4f6d,0x4f8e,
+     0x4fa0,0x4fa2,0x4fa1,0x4f9f,0x4fa3,0x0000,0x4f72,0x0000,0x4f8c,0x5156,
+     0x0000,0x0000,0x5190,0x0000,0x0000,0x0000,0x51ed,0x51fe,0x522f,0x0000,
+     0x523c,0x5234,0x5239,0x52b9,0x52b5,0x52bf,0x5355,0x0000,0x5376,0x537a,
+     0x5393,0x0000,0x53c1,0x53c2,0x53d5,0x5485,0x0000,0x545f,0x5493,0x5489,
+     0x5479,0x9efe,0x548f,0x5469,0x546d,0x0000,0x5494,0x546a,0x548a,0x0000,
+     0x56fd,0x56fb,0x56f8,0x0000
+   },
+   {				/* ku 08 */
+     0x56fc,0x56f6,0x5765,0x5781,0x5763,0x5767,0x0000,0x576e,0x5778,0x577f,
+     0x0000,0x0000,0x58f3,0x594b,0x594c,0x0000,0x0000,0x0000,0x59ad,0x0000,
+     0x59c4,0x0000,0x59c2,0x59b0,0x0000,0x0000,0x0000,0x0000,0x59bf,0x0000,
+     0x59c9,0x59b8,0x59ac,0x0000,0x0000,0x0000,0x59b7,0x59d7,0x0000,0x5b60,
+     0x0000,0x5b96,0x5b9e,0x5b94,0x5b9f,0x5b9d,0x0000,0x5c00,0x5c19,0x0000,
+     0x0000,0x5c49,0x5c4a,0x0000,0x5cbb,0x5cc1,0x0000,0x0000,0x0000,0x5cb9,
+     0x5c9e,0x5cb4,0x5cba,0x5df6,0x5e13,0x5e12,0x5e77,0x0000,0x5e98,0x0000,
+     0x5e99,0x5e9d,0x5ef8,0x0000,0x5ef9,0x0000,0x5f06,0x5f21,0x0000,0x5f25,
+     0x5f55,0x0000,0x0000,0x0000,0x5f84,0x5f83,0x6030,0x6007,0x0000,0x6036,
+     0x0000,0x0000,0x0000,0x5fe9
+   },
+   {				/* ku 09 */
+     0x603d,0x6008,0x0000,0x0000,0x62ba,0x62b2,0x0000,0x62b7,0x62e4,0x62a7,
+     0x0000,0x0000,0x0000,0x62d5,0x62e1,0x62dd,0x62a6,0x62c1,0x62c5,0x62c0,
+     0x62df,0x62e0,0x62de,0x0000,0x6589,0x0000,0x65a6,0x65ba,0x0000,0x65ff,
+     0x0000,0x6617,0x6618,0x6601,0x65fe,0x0000,0x670c,0x0000,0x676b,0x6796,
+     0x6782,0x678a,0x0000,0x67a3,0x0000,0x67a2,0x678f,0x0000,0x67f9,0x6780,
+     0x6b26,0x6b27,0x6b68,0x6b69,0x0000,0x6b81,0x6bb4,0x6bd1,0x0000,0x0000,
+     0x6c1c,0x0000,0x0000,0x0000,0x0000,0x0000,0x6c97,0x6c6c,0x6cdf,0x0000,
+     0x6cea,0x0000,0x6ce4,0x6cd8,0x6cb2,0x6cce,0x6cc8,0x0000,0x708b,0x7088,
+     0x7090,0x708f,0x0000,0x7087,0x7089,0x708d,0x7081,0x0000,0x708c,0x0000,
+     0x0000,0x7240,0x0000,0x0000
+   },
+   {				/* ku 0a */
+     0x7265,0x7266,0x7268,0x0000,0x0000,0x72cd,0x72d3,0x72db,0x0000,0x72cf,
+     0x73a7,0x73a3,0x739e,0x0000,0x73af,0x0000,0x0000,0x73aa,0x739c,0x0000,
+     0x7542,0x7544,0x753b,0x7541,0x0000,0x759b,0x759e,0x0000,0x79c4,0x79c3,
+     0x79c6,0x0000,0x0000,0x79c7,0x0000,0x79ca,0x0000,0x0000,0x7acf,0x7c76,
+     0x7c74,0x7cff,0x7cfc,0x0000,0x0000,0x7f59,0x80a8,0x0000,0x0000,0x80b0,
+     0x0000,0x80b3,0x0000,0x80a4,0x80b6,0x80a7,0x80ac,0x0000,0x80a6,0x5367,
+     0x820e,0x82c4,0x833e,0x829c,0x0000,0x0000,0x0000,0x0000,0x0000,0x82aa,
+     0x0000,0x82c9,0x0000,0x0000,0x82a6,0x82b2,0x0000,0x0000,0x0000,0x8fcc,
+     0x8fd9,0x8fca,0x8fd8,0x8fcf,0x90b7,0x0000,0x90ad,0x90b9,0x9637,0x0000,
+     0x9641,0x963e,0x96b6,0x9751
+   },
+   {				/* ku 0b */
+     0x9763,0x4e57,0x4e79,0x4eb2,0x4eb0,0x4eaf,0x4eb1,0x4fd2,0x4fd5,0x0000,
+     0x4fbe,0x4fb8,0x4fb0,0x4fb1,0x4fc8,0x0000,0x0000,0x4fc6,0x4fcc,0x4fe5,
+     0x4fe3,0x4fb4,0x516a,0x0000,0x519f,0x0000,0x51c1,0x0000,0x51c2,0x51c3,
+     0x5245,0x5248,0x0000,0x0000,0x524f,0x0000,0x0000,0x52c5,0x52ca,0x52c4,
+     0x5327,0x5358,0x537d,0x0000,0x53dd,0x53dc,0x53da,0x53d9,0x54b9,0x0000,
+     0x54d0,0x54b4,0x54ca,0x0000,0x54a3,0x54da,0x54a4,0x0000,0x54b2,0x549e,
+     0x549f,0x54b5,0x0000,0x0000,0x54cd,0x0000,0x54cc,0x0000,0x5700,0x57ac,
+     0x5791,0x578e,0x578d,0x5792,0x57a1,0x5790,0x57a6,0x57a8,0x0000,0x579c,
+     0x5796,0x57a7,0x0000,0x0000,0x0000,0x0000,0x58f5,0x0000,0x5909,0x5908,
+     0x0000,0x5952,0x0000,0x0000
+   },
+   {				/* ku 0c */
+     0x59df,0x0000,0x59eb,0x59ef,0x59f0,0x59d5,0x5a0d,0x5a04,0x59f9,0x5a02,
+     0x59f8,0x59e2,0x59d9,0x59e7,0x5b6a,0x0000,0x0000,0x5bab,0x0000,0x5c1b,
+     0x5c2f,0x0000,0x663c,0x0000,0x0000,0x0000,0x5cd1,0x5cdc,0x5ce6,0x5ce1,
+     0x5ccd,0x0000,0x5ce2,0x5cdd,0x5ce5,0x5dfb,0x5dfa,0x5e1e,0x0000,0x5ea1,
+     0x0000,0x0000,0x5efc,0x5efb,0x5f2f,0x0000,0x0000,0x5f66,0x0000,0x0000,
+     0x0000,0x605c,0x0000,0x604e,0x6051,0x0000,0x0000,0x6023,0x6031,0x607c,
+     0x6052,0x0000,0x6060,0x604a,0x6061,0x0000,0x6218,0x0000,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x631f,0x6317,0x62ea,0x6321,0x6304,0x6305,
+     0x0000,0x6531,0x6544,0x6540,0x0000,0x6542,0x65be,0x0000,0x6629,0x661b,
+     0x0000,0x6623,0x662c,0x661a
+   },
+   {				/* ku 0d */
+     0x6630,0x663b,0x661e,0x6637,0x6638,0x0000,0x670e,0x0000,0x0000,0x67e8,
+     0x67d6,0x0000,0x67c7,0x67bc,0x6852,0x67bf,0x67d5,0x67fe,0x8363,0x67fb,
+     0x0000,0x67b1,0x6801,0x6805,0x6800,0x67d7,0x0000,0x6b2a,0x6b6b,0x0000,
+     0x0000,0x0000,0x0000,0x6be1,0x0000,0x0000,0x6d23,0x6cff,0x6d14,0x6d05,
+     0x6d13,0x6d06,0x6d21,0x0000,0x6d15,0x6caf,0x6cf4,0x6d02,0x6d45,0x0000,
+     0x6d26,0x0000,0x6d44,0x0000,0x6d24,0x70a5,0x0000,0x70a3,0x0000,0x70a2,
+     0x70bb,0x70a0,0x70aa,0x0000,0x0000,0x70a8,0x70b6,0x70b2,0x70a7,0x0000,
+     0x0000,0x70b9,0x722e,0x0000,0x723c,0x0000,0x726d,0x0000,0x0000,0x72e7,
+     0x72ed,0x0000,0x72ec,0x72e5,0x72e2,0x0000,0x73c4,0x73bd,0x73cf,0x73c9,
+     0x73c1,0x73d0,0x0000,0x73ce
+   },
+   {				/* ku 0e */
+     0x74ed,0x74eb,0x0000,0x74ef,0x7549,0x7550,0x7546,0x754a,0x0000,0x754d,
+     0x75a6,0x0000,0x0000,0x0000,0x75a8,0x0000,0x0000,0x76c7,0x76ff,0x0000,
+     0x76fd,0x77e6,0x780a,0x0000,0x7804,0x780b,0x7807,0x0000,0x7815,0x7808,
+     0x0000,0x79d3,0x79d4,0x79d0,0x79d7,0x7a7c,0x0000,0x0000,0x7a7d,0x7a83,
+     0x7a82,0x0000,0x7ad4,0x7ad5,0x7ad3,0x7ad0,0x7ad2,0x7afe,0x7afc,0x7c77,
+     0x7c7c,0x7c7b,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x7f8f,0x80d3,0x0000,0x80cb,0x80d2,0x0000,0x8109,0x80e2,0x80df,0x80c6,
+     0x0000,0x8224,0x82f7,0x82d8,0x82dd,0x0000,0x0000,0x82f8,0x82fc,0x0000,
+     0x0000,0x82e9,0x0000,0x82ee,0x0000,0x82d0,0x830e,0x82e2,0x830b,0x82fd,
+     0x5179,0x8676,0x0000,0x8678
+   },
+   {				/* ku 0f */
+     0x0000,0x0000,0x8675,0x867d,0x0000,0x8842,0x8866,0x0000,0x898c,0x8a05,
+     0x0000,0x8a06,0x0000,0x8c9f,0x0000,0x8ff1,0x8fe7,0x8fe9,0x8fef,0x90c2,
+     0x90bc,0x0000,0x90c6,0x90c0,0x0000,0x0000,0x90cd,0x90c9,0x0000,0x90c4,
+     0x0000,0x9581,0x0000,0x9cec,0x5032,0x4ff9,0x501d,0x4fff,0x5004,0x4ff0,
+     0x5003,0x0000,0x5002,0x4ffc,0x4ff2,0x5024,0x5008,0x5036,0x502e,0x0000,
+     0x5010,0x5038,0x5039,0x4ffd,0x5056,0x4ffb,0x51a3,0x51a6,0x51a1,0x0000,
+     0x0000,0x51c7,0x51c9,0x5260,0x5264,0x5259,0x5265,0x5267,0x5257,0x5263,
+     0x0000,0x5253,0x0000,0x52cf,0x0000,0x52ce,0x52d0,0x52d1,0x52cc,0x0000,
+     0x0000,0x0000,0x550d,0x54f4,0x0000,0x5513,0x54ef,0x54f5,0x54f9,0x5502,
+     0x5500,0x0000,0x0000,0x5518
+   },
+   {				/* ku 10 */
+     0x54f0,0x54f6,0x0000,0x0000,0x5519,0x0000,0x5705,0x57c9,0x0000,0x57b7,
+     0x57cd,0x0000,0x0000,0x0000,0x57be,0x57bb,0x0000,0x57db,0x57c8,0x57c4,
+     0x57c5,0x57d1,0x57ca,0x57c0,0x0000,0x0000,0x5a21,0x5a2a,0x0000,0x5a1d,
+     0x0000,0x5a0b,0x0000,0x0000,0x0000,0x0000,0x5a22,0x0000,0x0000,0x5a24,
+     0x0000,0x5a14,0x5a31,0x0000,0x5a2f,0x5a1a,0x5a12,0x0000,0x0000,0x5a26,
+     0x0000,0x0000,0x5bbc,0x5bbb,0x5bb7,0x5c05,0x5c06,0x5c52,0x5c53,0x0000,
+     0x0000,0x5cfa,0x5ceb,0x0000,0x5cf3,0x5cf5,0x5ce9,0x5cef,0x0000,0x5e2a,
+     0x5e30,0x5e2e,0x5e2c,0x5e2f,0x5eaf,0x5ea9,0x0000,0x5efd,0x5f32,0x5f8e,
+     0x5f93,0x5f8f,0x604f,0x6099,0x0000,0x607e,0x0000,0x6074,0x604b,0x6073,
+     0x6075,0x0000,0x0000,0x6056
+   },
+   {				/* ku 11 */
+     0x60a9,0x608b,0x60a6,0x0000,0x6093,0x60ae,0x609e,0x60a7,0x6245,0x0000,
+     0x0000,0x632e,0x0000,0x6352,0x6330,0x635b,0x0000,0x6319,0x631b,0x0000,
+     0x6331,0x635d,0x6337,0x6335,0x6353,0x0000,0x635c,0x633f,0x654b,0x0000,
+     0x0000,0x658b,0x0000,0x659a,0x6650,0x6646,0x664e,0x6640,0x0000,0x664b,
+     0x6648,0x0000,0x6660,0x6644,0x664d,0x0000,0x6837,0x6824,0x0000,0x0000,
+     0x681b,0x6836,0x0000,0x682c,0x6819,0x6856,0x6847,0x683e,0x681e,0x0000,
+     0x6815,0x6822,0x6827,0x6859,0x6858,0x6855,0x6830,0x6823,0x6b2e,0x6b2b,
+     0x6b30,0x6b6c,0x0000,0x6b8b,0x0000,0x6be9,0x6bea,0x6be5,0x6d6b,0x0000,
+     0x0000,0x6d73,0x6d57,0x0000,0x0000,0x6d5d,0x6d56,0x6d8f,0x6d5b,0x6d1c,
+     0x6d9a,0x6d9b,0x6d99,0x0000
+   },
+   {				/* ku 12 */
+     0x6d81,0x6d71,0x0000,0x0000,0x6d72,0x6d5c,0x6d96,0x70c4,0x70db,0x70cc,
+     0x70d0,0x70e3,0x70df,0x0000,0x70d6,0x70ee,0x70d5,0x0000,0x0000,0x0000,
+     0x0000,0x727a,0x0000,0x72f5,0x7302,0x0000,0x0000,0x73e2,0x73ec,0x73d5,
+     0x73f9,0x73df,0x73e6,0x0000,0x0000,0x0000,0x0000,0x73e4,0x73e1,0x74f3,
+     0x0000,0x0000,0x0000,0x0000,0x7556,0x7555,0x7558,0x7557,0x755e,0x75c3,
+     0x0000,0x0000,0x75b4,0x0000,0x75b1,0x0000,0x0000,0x76cb,0x76cc,0x772a,
+     0x0000,0x7716,0x770f,0x0000,0x0000,0x773f,0x772b,0x770e,0x7724,0x0000,
+     0x7721,0x7718,0x77dd,0x0000,0x0000,0x7824,0x7836,0x0000,0x7958,0x7959,
+     0x0000,0x7962,0x79da,0x79d9,0x0000,0x79e1,0x79e5,0x79e8,0x79db,0x0000,
+     0x79e2,0x79f0,0x0000,0x0000
+   },
+   {				/* ku 13 */
+     0x0000,0x0000,0x7ada,0x7add,0x0000,0x7adb,0x7adc,0x0000,0x0000,0x7b0d,
+     0x7b0b,0x7b14,0x7c8e,0x7c86,0x0000,0x7c87,0x7c83,0x7c8b,0x0000,0x0000,
+     0x0000,0x0000,0x7d24,0x0000,0x0000,0x0000,0x7d25,0x7f62,0x7f93,0x7f99,
+     0x7f97,0x0000,0x0000,0x7fc4,0x7fc6,0x800a,0x0000,0x0000,0x8040,0x803c,
+     0x803b,0x80f6,0x80ff,0x80ee,0x8104,0x8103,0x8107,0x0000,0x0000,0x80f7,
+     0x0000,0x0000,0x822d,0x0000,0x8227,0x8229,0x831f,0x8357,0x0000,0x0000,
+     0x0000,0x0000,0x8321,0x0000,0x0000,0x8318,0x8358,0x0000,0x0000,0x0000,
+     0x0000,0x0000,0x8684,0x869f,0x869b,0x8689,0x86a6,0x8692,0x868f,0x86a0,
+     0x884f,0x8878,0x887a,0x886e,0x887b,0x8884,0x8873,0x0000,0x0000,0x8a0d,
+     0x8a0b,0x8a19,0x0000,0x0000
+   },
+   {				/* ku 14 */
+     0x0000,0x0000,0x0000,0x0000,0x8ff9,0x9009,0x9008,0x0000,0x90de,0x9151,
+     0x0000,0x0000,0x91db,0x91df,0x91de,0x91d6,0x91e0,0x9585,0x9660,0x9659,
+     0x0000,0x9656,0x0000,0x0000,0x96bd,0x0000,0x0000,0x5042,0x5059,0x0000,
+     0x5044,0x5066,0x5052,0x5054,0x5071,0x5050,0x507b,0x507c,0x5058,0x0000,
+     0x0000,0x5079,0x506c,0x5078,0x51a8,0x51d1,0x51cf,0x5268,0x5276,0x52d4,
+     0x0000,0x53a0,0x53c4,0x0000,0x5558,0x554c,0x5568,0x0000,0x5549,0x0000,
+     0x0000,0x555d,0x5529,0x0000,0x5554,0x5553,0x0000,0x555a,0x0000,0x553a,
+     0x553f,0x552b,0x57ea,0x0000,0x57ef,0x0000,0x0000,0x57dd,0x57fe,0x0000,
+     0x57de,0x57e6,0x0000,0x57e8,0x57ff,0x5803,0x58f7,0x68a6,0x591f,0x0000,
+     0x595b,0x595d,0x595e,0x0000
+   },
+   {				/* ku 15 */
+     0x0000,0x5a2b,0x0000,0x5a3b,0x0000,0x0000,0x5a61,0x5a3a,0x5a6e,0x5a4b,
+     0x5a6b,0x0000,0x0000,0x5a45,0x5a4e,0x5a68,0x5a3d,0x5a71,0x5a3f,0x5a6f,
+     0x5a75,0x0000,0x5a73,0x5a2c,0x5a59,0x5a54,0x5a4f,0x5a63,0x0000,0x0000,
+     0x5bc8,0x0000,0x5bc3,0x0000,0x5c5b,0x5c61,0x0000,0x5d21,0x5d0a,0x5d09,
+     0x0000,0x5d2c,0x5d08,0x0000,0x0000,0x5d2a,0x5d15,0x0000,0x5d10,0x5d13,
+     0x0000,0x5d2f,0x5d18,0x0000,0x5de3,0x5e39,0x5e35,0x5e3a,0x5e32,0x0000,
+     0x0000,0x0000,0x0000,0x5ebb,0x5eba,0x5f34,0x5f39,0x0000,0x0000,0x0000,
+     0x0000,0x6098,0x0000,0x60d0,0x0000,0x0000,0x0000,0x60d7,0x60aa,0x0000,
+     0x60a1,0x60a4,0x0000,0x60ee,0x0000,0x60e7,0x0000,0x0000,0x60de,0x0000,
+     0x0000,0x637e,0x638b,0x0000
+   },
+   {				/* ku 16 */
+     0x0000,0x6379,0x6386,0x6393,0x0000,0x6373,0x636a,0x0000,0x636c,0x0000,
+     0x637f,0x0000,0x63b2,0x63ba,0x0000,0x0000,0x6366,0x6374,0x0000,0x655a,
+     0x0000,0x654e,0x654d,0x658d,0x658e,0x65ad,0x0000,0x65c7,0x65ca,0x0000,
+     0x65c9,0x0000,0x65e3,0x6657,0x0000,0x6663,0x6667,0x671a,0x6719,0x6716,
+     0x0000,0x0000,0x689e,0x68b6,0x6898,0x6873,0x0000,0x689a,0x688e,0x68b7,
+     0x68db,0x68a5,0x686c,0x68c1,0x6884,0x0000,0x0000,0x6895,0x687a,0x6899,
+     0x0000,0x68b8,0x68b9,0x6870,0x0000,0x6b35,0x0000,0x6b90,0x6bbb,0x6bed,
+     0x0000,0x0000,0x0000,0x6dc1,0x6dc3,0x6dce,0x0000,0x0000,0x6dad,0x6e04,
+     0x0000,0x6db9,0x0000,0x6de7,0x0000,0x6e08,0x6e06,0x0000,0x6e0a,0x6db0,
+     0x0000,0x6df8,0x6e0c,0x0000
+   },
+   {				/* ku 17 */
+     0x6db1,0x0000,0x6e02,0x6e07,0x6e09,0x6e01,0x6e17,0x6dff,0x6e12,0x0000,
+     0x0000,0x7103,0x7107,0x7101,0x70f5,0x70f1,0x7108,0x70f2,0x710f,0x0000,
+     0x70fe,0x0000,0x0000,0x0000,0x731a,0x7310,0x730e,0x7402,0x73f3,0x0000,
+     0x0000,0x73fb,0x0000,0x0000,0x0000,0x751b,0x7523,0x7561,0x7568,0x0000,
+     0x7567,0x75d3,0x0000,0x0000,0x7690,0x0000,0x0000,0x76d5,0x76d7,0x76d6,
+     0x7730,0x0000,0x7726,0x0000,0x7740,0x0000,0x771e,0x0000,0x0000,0x0000,
+     0x7847,0x0000,0x784b,0x7851,0x784f,0x7842,0x7846,0x0000,0x796e,0x796c,
+     0x79f2,0x0000,0x79f1,0x79f5,0x79f3,0x79f9,0x0000,0x0000,0x0000,0x7a9a,
+     0x7a93,0x7a91,0x7ae1,0x0000,0x0000,0x7b21,0x7b1c,0x7b16,0x7b17,0x7b36,
+     0x7b1f,0x0000,0x7c93,0x7c99
+   },
+   {				/* ku 18 */
+     0x7c9a,0x7c9c,0x0000,0x7d49,0x0000,0x7d34,0x7d37,0x0000,0x7d2d,0x0000,
+     0x7d4c,0x0000,0x0000,0x7d48,0x0000,0x0000,0x7f3b,0x0000,0x0000,0x0000,
+     0x0000,0x8008,0x801a,0x0000,0x801d,0x0000,0x8049,0x8045,0x8044,0x7c9b,
+     0x0000,0x0000,0x812a,0x812e,0x0000,0x0000,0x8131,0x0000,0x811a,0x8134,
+     0x8117,0x0000,0x0000,0x0000,0x831d,0x8371,0x8384,0x8380,0x8372,0x83a1,
+     0x0000,0x8379,0x8391,0x0000,0x839f,0x83ad,0x0000,0x0000,0x8323,0x0000,
+     0x8385,0x839c,0x83b7,0x8658,0x865a,0x0000,0x8657,0x86b2,0x0000,0x86ae,
+     0x0000,0x0000,0x0000,0x8845,0x889c,0x8894,0x88a3,0x888f,0x88a5,0x88a9,
+     0x88a6,0x888a,0x88a0,0x8890,0x8992,0x8991,0x8994,0x0000,0x8a26,0x8a32,
+     0x8a28,0x0000,0x0000,0x8a1c
+   },
+   {				/* ku 19 */
+     0x0000,0x8a2b,0x8a20,0x0000,0x8a29,0x0000,0x0000,0x0000,0x8a21,0x8c3a,
+     0x0000,0x8c5b,0x8c58,0x8c7c,0x0000,0x8ca6,0x8cae,0x8cad,0x8d65,0x0000,
+     0x8d7e,0x0000,0x8d7c,0x8d7f,0x8d7a,0x8dbd,0x0000,0x0000,0x8dc0,0x8dbb,
+     0x8ead,0x8eaf,0x8ed6,0x0000,0x0000,0x0000,0x0000,0x0000,0x8ed9,0x0000,
+     0x0000,0x9012,0x900e,0x9025,0x0000,0x9013,0x90ee,0x0000,0x90ab,0x90f7,
+     0x0000,0x9159,0x9154,0x91f2,0x91f0,0x91e5,0x91f6,0x0000,0x0000,0x9587,
+     0x0000,0x965a,0x0000,0x0000,0x966e,0x0000,0x0000,0x0000,0x9679,0x0000,
+     0x98e1,0x98e6,0x0000,0x9ec4,0x9ed2,0x4e80,0x0000,0x4e81,0x508f,0x5097,
+     0x5088,0x5089,0x0000,0x0000,0x5081,0x5160,0x0000,0x0000,0x5e42,0x51d3,
+     0x0000,0x0000,0x51d2,0x51d6
+   },
+   {				/* ku 1a */
+     0x5273,0x0000,0x5270,0x0000,0x0000,0x0000,0x53a8,0x53a6,0x53c5,0x5597,
+     0x55de,0x0000,0x0000,0x5596,0x55b4,0x0000,0x5585,0x0000,0x559b,0x55a0,
+     0x0000,0x5559,0x0000,0x5586,0x0000,0x0000,0x55af,0x557a,0x0000,0x0000,
+     0x0000,0x559e,0x0000,0x55a9,0x570f,0x570e,0x581a,0x0000,0x581f,0x0000,
+     0x583c,0x5818,0x583e,0x5826,0x0000,0x583a,0x0000,0x5822,0x0000,0x58fb,
+     0x5963,0x5964,0x0000,0x5aa8,0x5aa3,0x5a82,0x5a88,0x5aa1,0x5a85,0x5a98,
+     0x0000,0x5a99,0x0000,0x5a89,0x5a81,0x5a96,0x5a80,0x0000,0x0000,0x5a91,
+     0x0000,0x0000,0x0000,0x0000,0x5acf,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x0000,0x5a87,0x5aa0,0x0000,0x5a79,0x0000,0x5a86,0x5aab,0x5aaa,0x5aa4,
+     0x5a8d,0x5a7e,0x0000,0x5bd5
+   },
+   {				/* ku 1b */
+     0x0000,0x0000,0x0000,0x5c1e,0x5c5f,0x5c5e,0x5d44,0x5d3e,0x0000,0x5d48,
+     0x5d1c,0x0000,0x5d5b,0x5d4d,0x0000,0x0000,0x5d57,0x0000,0x5d53,0x5d4f,
+     0x0000,0x5d3b,0x5d46,0x0000,0x0000,0x5e46,0x5e47,0x0000,0x5e48,0x5ec0,
+     0x5ebd,0x5ebf,0x0000,0x5f11,0x0000,0x5f3e,0x5f3b,0x0000,0x5f3a,0x0000,
+     0x0000,0x0000,0x5fa7,0x0000,0x60ea,0x0000,0x6107,0x6122,0x610c,0x0000,
+     0x0000,0x60b3,0x60d6,0x60d2,0x0000,0x60e3,0x60e5,0x60e9,0x0000,0x0000,
+     0x6111,0x60fd,0x0000,0x0000,0x611e,0x6120,0x6121,0x621e,0x0000,0x63e2,
+     0x63de,0x63e6,0x0000,0x0000,0x0000,0x0000,0x63f8,0x0000,0x63fe,0x63c1,
+     0x63bf,0x63f7,0x63d1,0x655f,0x6560,0x6561,0x0000,0x0000,0x65d1,0x0000,
+     0x0000,0x667d,0x666b,0x667f
+   },
+   {				/* ku 1c */
+     0x0000,0x0000,0x6673,0x6681,0x666d,0x6669,0x0000,0x0000,0x671e,0x68ed,
+     0x0000,0x0000,0x0000,0x0000,0x6903,0x0000,0x68fe,0x68e5,0x691e,0x6902,
+     0x0000,0x0000,0x6909,0x68ca,0x6900,0x0000,0x6901,0x6918,0x68e2,0x68cf,
+     0x0000,0x692e,0x68c5,0x68ff,0x0000,0x691c,0x68c3,0x0000,0x6b6f,0x0000,
+     0x6b6e,0x0000,0x6bbe,0x0000,0x6bf4,0x6c2d,0x0000,0x6db6,0x6e75,0x6e1e,
+     0x0000,0x6e18,0x0000,0x6e48,0x0000,0x6e4f,0x0000,0x6e42,0x6e6a,0x6e70,
+     0x6dfe,0x0000,0x0000,0x6e6d,0x0000,0x6e7b,0x6e7e,0x6e59,0x0000,0x6e57,
+     0x0000,0x6e80,0x6e50,0x0000,0x6e29,0x6e76,0x6e2a,0x6e4c,0x712a,0x0000,
+     0x7135,0x712c,0x7137,0x711d,0x0000,0x0000,0x7138,0x0000,0x7134,0x712b,
+     0x7133,0x7127,0x7124,0x0000
+   },
+   {				/* ku 1d */
+     0x712d,0x7232,0x7283,0x7282,0x7287,0x7306,0x7324,0x7338,0x732a,0x732c,
+     0x732b,0x0000,0x732f,0x7328,0x7417,0x0000,0x0000,0x7419,0x7438,0x0000,
+     0x741f,0x7414,0x743c,0x73f7,0x741c,0x7415,0x7418,0x7439,0x74f9,0x7524,
+     0x0000,0x0000,0x0000,0x756e,0x756d,0x7571,0x758e,0x0000,0x75e5,0x0000,
+     0x0000,0x0000,0x0000,0x7694,0x76b3,0x0000,0x76d9,0x0000,0x7748,0x7749,
+     0x7743,0x0000,0x0000,0x7742,0x77df,0x0000,0x7863,0x7876,0x0000,0x785f,
+     0x7866,0x7966,0x7971,0x0000,0x0000,0x7976,0x7984,0x7975,0x79ff,0x7a07,
+     0x0000,0x7a0e,0x7a09,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7ae7,
+     0x7ae2,0x7b55,0x0000,0x0000,0x7b43,0x7b57,0x7b6c,0x7b42,0x7b53,0x0000,
+     0x7b41,0x0000,0x0000,0x7ca7
+   },
+   {				/* ku 1e */
+     0x7ca0,0x7ca6,0x7ca4,0x7d74,0x0000,0x7d59,0x0000,0x7d60,0x7d57,0x7d6c,
+     0x7d7e,0x7d64,0x0000,0x7d5a,0x7d5d,0x0000,0x0000,0x0000,0x7d76,0x7d4d,
+     0x7d75,0x0000,0x7fd3,0x7fd6,0x0000,0x0000,0x8060,0x804e,0x8145,0x813b,
+     0x0000,0x8148,0x8142,0x8149,0x8140,0x8114,0x8141,0x0000,0x81ef,0x81f6,
+     0x8203,0x0000,0x83ed,0x0000,0x83da,0x8418,0x83d2,0x8408,0x0000,0x8400,
+     0x0000,0x0000,0x0000,0x8417,0x8346,0x8414,0x83d3,0x8405,0x841f,0x8402,
+     0x8416,0x83cd,0x83e6,0x0000,0x865d,0x86d5,0x86e1,0x0000,0x0000,0x0000,
+     0x0000,0x86ee,0x8847,0x8846,0x0000,0x0000,0x88bb,0x0000,0x88bf,0x88b4,
+     0x0000,0x88b5,0x0000,0x899a,0x8a43,0x0000,0x0000,0x8a5a,0x0000,0x0000,
+     0x0000,0x8a35,0x8a38,0x8a42
+   },
+   {				/* ku 1f */
+     0x8a49,0x8a5d,0x8a4b,0x8a3d,0x0000,0x0000,0x0000,0x0000,0x8c60,0x8c5e,
+     0x8c7f,0x8c7e,0x8c83,0x0000,0x8cb1,0x8d87,0x0000,0x0000,0x8d88,0x8d83,
+     0x0000,0x0000,0x8d86,0x8d8b,0x8d82,0x8dca,0x8dd2,0x0000,0x0000,0x8dd4,
+     0x8dc9,0x8eb0,0x0000,0x0000,0x0000,0x8ef2,0x8ee4,0x8ef3,0x8eea,0x0000,
+     0x8efd,0x0000,0x8f9d,0x902b,0x902a,0x0000,0x9028,0x9029,0x902c,0x0000,
+     0x0000,0x903a,0x9030,0x9037,0x903b,0x0000,0x910a,0x0000,0x0000,0x0000,
+     0x91fe,0x9220,0x0000,0x920b,0x0000,0x9218,0x9222,0x0000,0x921b,0x9208,
+     0x0000,0x920e,0x9213,0x0000,0x0000,0x9595,0x0000,0x0000,0x0000,0x968c,
+     0x967b,0x967f,0x9681,0x0000,0x9682,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x96ee,0x96ed,0x0000,0x96ec
+   },
+   {				/* ku 20 */
+     0x975f,0x976f,0x0000,0x976d,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x98f0,0x0000,0x0000,0x0000,0x9aa9,0x0000,0x0000,0x9ae0,0x4eb7,0x0000,
+     0x0000,0x50cc,0x50bc,0x0000,0x50aa,0x50b9,0x0000,0x50ab,0x50c3,0x50cd,
+     0x517e,0x527e,0x5279,0x0000,0x0000,0x52e1,0x52e0,0x52e7,0x5380,0x53ab,
+     0x53aa,0x53a9,0x53e0,0x55ea,0x0000,0x55d7,0x0000,0x0000,0x55c1,0x5715,
+     0x0000,0x586c,0x0000,0x585c,0x5850,0x5861,0x586a,0x5869,0x5856,0x5860,
+     0x5866,0x585f,0x5923,0x5966,0x5968,0x0000,0x0000,0x5ace,0x0000,0x5ac5,
+     0x5ac3,0x0000,0x0000,0x5ad0,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x5b74,0x5b76,0x5bdc,0x5bd7,0x5bda,0x5bdb,0x0000,0x5c20,0x5d6d,0x5d66,
+     0x0000,0x5d64,0x5d6e,0x0000
+   },
+   {				/* ku 21 */
+     0x5d60,0x5f42,0x5f5a,0x5f6e,0x0000,0x0000,0x6130,0x613a,0x612a,0x6143,
+     0x6119,0x6131,0x0000,0x613d,0x0000,0x0000,0x0000,0x6408,0x6432,0x6438,
+     0x0000,0x6431,0x0000,0x6419,0x0000,0x6411,0x0000,0x0000,0x6429,0x641d,
+     0x0000,0x0000,0x0000,0x643c,0x0000,0x6446,0x6447,0x0000,0x0000,0x643a,
+     0x6407,0x0000,0x656b,0x0000,0x6570,0x656d,0x0000,0x65e4,0x6693,0x0000,
+     0x0000,0x0000,0x0000,0x668f,0x0000,0x0000,0x6692,0x0000,0x668e,0x0000,
+     0x6946,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x6931,0x0000,
+     0x0000,0x693e,0x0000,0x697c,0x6943,0x0000,0x6973,0x0000,0x6955,0x0000,
+     0x0000,0x6985,0x694d,0x6950,0x6947,0x6967,0x6936,0x6964,0x6961,0x0000,
+     0x697d,0x6b44,0x6b40,0x6b71
+   },
+   {				/* ku 22 */
+     0x6b73,0x6b9c,0x0000,0x0000,0x0000,0x6bc1,0x0000,0x6bfa,0x6c31,0x6c32,
+     0x0000,0x0000,0x6eb8,0x6ea8,0x0000,0x6e91,0x6ebb,0x0000,0x6e9a,0x0000,
+     0x0000,0x6ea9,0x0000,0x0000,0x6eb5,0x6e6c,0x6ee8,0x0000,0x6edd,0x6eda,
+     0x6ee6,0x6eac,0x0000,0x0000,0x0000,0x6ed9,0x6ee3,0x6ee9,0x6edb,0x0000,
+     0x716f,0x0000,0x0000,0x7148,0x0000,0x714a,0x716b,0x0000,0x714f,0x7157,
+     0x7174,0x0000,0x0000,0x0000,0x7145,0x7151,0x716d,0x0000,0x7251,0x7250,
+     0x724e,0x0000,0x7341,0x0000,0x732e,0x7346,0x0000,0x7427,0x0000,0x7448,
+     0x7453,0x743d,0x0000,0x745d,0x7456,0x0000,0x741e,0x7447,0x7443,0x7458,
+     0x7449,0x0000,0x744c,0x7445,0x743e,0x0000,0x7501,0x751e,0x0000,0x0000,
+     0x757a,0x75ee,0x7602,0x7697
+   },
+   {				/* ku 23 */
+     0x7698,0x0000,0x0000,0x0000,0x775d,0x7764,0x7753,0x7758,0x7882,0x7890,
+     0x788a,0x0000,0x787a,0x787d,0x0000,0x788b,0x7878,0x0000,0x0000,0x788d,
+     0x7888,0x7892,0x7881,0x797e,0x7983,0x0000,0x0000,0x0000,0x7980,0x0000,
+     0x0000,0x0000,0x7a0f,0x0000,0x0000,0x7a1d,0x0000,0x7aa1,0x7aa4,0x0000,
+     0x7ae9,0x7aea,0x0000,0x7b62,0x7b6b,0x0000,0x7b5e,0x0000,0x7b79,0x0000,
+     0x0000,0x7b6f,0x7b68,0x0000,0x0000,0x7cae,0x0000,0x0000,0x0000,0x7cb0,
+     0x0000,0x7d90,0x0000,0x7d8a,0x0000,0x7d8b,0x7d99,0x7d95,0x0000,0x7d87,
+     0x7d78,0x7d97,0x7d89,0x7d98,0x0000,0x0000,0x0000,0x7fa3,0x0000,0x0000,
+     0x0000,0x7fdd,0x8057,0x0000,0x8163,0x816a,0x816c,0x0000,0x0000,0x0000,
+     0x815d,0x8175,0x0000,0x815f
+   },
+   {				/* ku 24 */
+     0x0000,0x817d,0x816d,0x0000,0x0000,0x8241,0x844f,0x8484,0x0000,0x847f,
+     0x0000,0x8448,0x842a,0x847b,0x8472,0x8464,0x842e,0x845c,0x8453,0x0000,
+     0x8441,0x84c8,0x0000,0x8462,0x8480,0x843e,0x8483,0x8471,0x0000,0x844a,
+     0x8455,0x8458,0x0000,0x0000,0x0000,0x86fc,0x86fd,0x8715,0x0000,0x8716,
+     0x86ff,0x0000,0x0000,0x0000,0x8858,0x88cf,0x88e0,0x0000,0x0000,0x0000,
+     0x0000,0x89e7,0x8a6a,0x8a80,0x0000,0x8a6f,0x8a65,0x0000,0x8a78,0x8a7d,
+     0x8a88,0x0000,0x0000,0x8a64,0x8a7e,0x0000,0x8a67,0x8c63,0x8c88,0x0000,
+     0x8ccd,0x0000,0x8cc9,0x0000,0x8ded,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x0000,0x0000,0x8eb1,0x0000,0x0000,0x8f04,0x8f9e,0x8fa0,0x9043,0x9046,
+     0x9048,0x9045,0x9040,0x904c
+   },
+   {				/* ku 25 */
+     0x0000,0x0000,0x910c,0x9113,0x9115,0x0000,0x916b,0x9167,0x925d,0x9255,
+     0x9235,0x0000,0x9259,0x922f,0x923c,0x928f,0x925c,0x926a,0x9262,0x925f,
+     0x926b,0x926e,0x923b,0x9244,0x9241,0x959a,0x0000,0x9599,0x0000,0x0000,
+     0x0000,0x968f,0x0000,0x9696,0x0000,0x0000,0x0000,0x96f4,0x96fc,0x0000,
+     0x9755,0x0000,0x9779,0x0000,0x0000,0x0000,0x97ee,0x97f5,0x0000,0x980b,
+     0x0000,0x98f3,0x0000,0x0000,0x98f7,0x98ff,0x98f5,0x0000,0x98ec,0x98f1,
+     0x0000,0x0000,0x999a,0x0000,0x9ae2,0x9b3d,0x9b5d,0x9ce8,0x0000,0x9ceb,
+     0x9cef,0x9cee,0x9e81,0x9f14,0x50d0,0x50d9,0x50dc,0x50d8,0x0000,0x50e1,
+     0x50eb,0x0000,0x0000,0x50f4,0x50e2,0x50de,0x0000,0x0000,0x0000,0x51f4,
+     0x0000,0x0000,0x0000,0x52ed
+   },
+   {				/* ku 26 */
+     0x52ea,0x0000,0x5332,0x0000,0x53ae,0x53b0,0x0000,0x55fb,0x5603,0x560b,
+     0x0000,0x5607,0x0000,0x55f8,0x0000,0x5628,0x561e,0x0000,0x5618,0x5611,
+     0x5651,0x5605,0x5717,0x5892,0x0000,0x588c,0x0000,0x5878,0x5884,0x5873,
+     0x58ad,0x5897,0x5895,0x5877,0x5872,0x5896,0x588d,0x5910,0x0000,0x596c,
+     0x0000,0x5ae7,0x0000,0x5ae4,0x0000,0x0000,0x5aef,0x5626,0x0000,0x0000,
+     0x5af0,0x5d7b,0x0000,0x5d83,0x0000,0x0000,0x5d8b,0x5d8c,0x0000,0x5d78,
+     0x5e52,0x0000,0x0000,0x5ed0,0x5ecf,0x0000,0x5fb3,0x5fb4,0x0000,0x0000,
+     0x0000,0x617b,0x0000,0x616f,0x6181,0x613c,0x6142,0x6138,0x6133,0x0000,
+     0x6160,0x6169,0x617d,0x6186,0x622c,0x6228,0x0000,0x644c,0x0000,0x6457,
+     0x647c,0x0000,0x0000,0x6455
+   },
+   {				/* ku 27 */
+     0x6462,0x6471,0x646a,0x6456,0x643b,0x6481,0x0000,0x644f,0x647e,0x6464,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x6571,0x0000,0x0000,0x66a5,0x669a,
+     0x669c,0x0000,0x66a6,0x0000,0x66a4,0x698f,0x69c5,0x69c8,0x6992,0x69b2,
+     0x0000,0x0000,0x0000,0x69e3,0x69c0,0x69d6,0x69d1,0x699f,0x69a2,0x69d2,
+     0x0000,0x0000,0x0000,0x69e1,0x69d5,0x699d,0x0000,0x0000,0x6998,0x0000,
+     0x6b74,0x6ba1,0x0000,0x6ef0,0x6ef3,0x0000,0x0000,0x6f1b,0x6f0c,0x6f1d,
+     0x6f34,0x6f28,0x6f17,0x0000,0x6f44,0x6f42,0x6f04,0x6f11,0x6efa,0x6f4a,
+     0x7191,0x718e,0x0000,0x718b,0x718d,0x717f,0x718c,0x717e,0x717c,0x7183,
+     0x0000,0x7188,0x0000,0x0000,0x7294,0x0000,0x7355,0x7353,0x734f,0x7354,
+     0x746c,0x7465,0x7466,0x7461
+   },
+   {				/* ku 28 */
+     0x746b,0x7468,0x7476,0x0000,0x7460,0x0000,0x7474,0x7506,0x760e,0x0000,
+     0x7607,0x0000,0x0000,0x76b9,0x0000,0x76b7,0x76e2,0x0000,0x7774,0x7777,
+     0x7776,0x7775,0x0000,0x7778,0x7771,0x0000,0x777a,0x715b,0x777b,0x78a6,
+     0x78ae,0x78b8,0x0000,0x0000,0x0000,0x78b1,0x78af,0x0000,0x7989,0x7987,
+     0x0000,0x0000,0x7a29,0x0000,0x7a2a,0x0000,0x7a2d,0x7a2c,0x0000,0x7a32,
+     0x0000,0x7aec,0x7af0,0x7b81,0x7b9e,0x7b83,0x0000,0x7b92,0x0000,0x7ba3,
+     0x7b9f,0x7b93,0x0000,0x7b86,0x7cb8,0x7cb7,0x0000,0x0000,0x0000,0x0000,
+     0x0000,0x7dc8,0x7db6,0x0000,0x7dd1,0x0000,0x7da8,0x7dab,0x0000,0x7db3,
+     0x7dcd,0x0000,0x7dcf,0x7da4,0x0000,0x0000,0x7f41,0x7f6f,0x7f71,0x0000,
+     0x0000,0x0000,0x0000,0x0000
+   },
+   {				/* ku 29 */
+     0x0000,0x8023,0x805b,0x0000,0x8061,0x805f,0x8181,0x0000,0x0000,0x8184,
+     0x8213,0x0000,0x824a,0x824c,0x0000,0x0000,0x0000,0x84bd,0x8495,0x0000,
+     0x8492,0x84c3,0x0000,0x8496,0x84a5,0x84b5,0x84b3,0x84a3,0x84e4,0x84d8,
+     0x84d5,0x0000,0x84b7,0x84ad,0x84da,0x8493,0x8736,0x0000,0x0000,0x0000,
+     0x873d,0x872b,0x8747,0x8739,0x0000,0x8745,0x871d,0x0000,0x88ff,0x88ea,
+     0x0000,0x88f5,0x0000,0x8900,0x88ed,0x8903,0x88e9,0x0000,0x0000,0x89ea,
+     0x0000,0x8a9b,0x8a8e,0x8aa2,0x0000,0x8a9c,0x8a94,0x8a90,0x8aa9,0x8aac,
+     0x0000,0x8a9f,0x0000,0x0000,0x8a9d,0x0000,0x8c67,0x0000,0x0000,0x8cd0,
+     0x8cd6,0x8cd4,0x8d98,0x8d9a,0x8d97,0x0000,0x0000,0x0000,0x8e0b,0x8e08,
+     0x8e01,0x8eb4,0x8eb3,0x0000
+   },
+   {				/* ku 2a */
+     0x8fa1,0x8fa2,0x0000,0x905a,0x0000,0x9061,0x905f,0x0000,0x0000,0x9125,
+     0x917b,0x9176,0x917c,0x0000,0x9289,0x92f6,0x92b1,0x92ad,0x9292,0x9281,
+     0x9284,0x0000,0x92ae,0x9290,0x929e,0x0000,0x0000,0x0000,0x95a2,0x95a7,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x96a0,0x969d,0x969f,0x96d0,0x0000,
+     0x96d1,0x0000,0x0000,0x9759,0x0000,0x9764,0x0000,0x0000,0x0000,0x9819,
+     0x0000,0x9814,0x9815,0x981a,0x0000,0x0000,0x0000,0x0000,0x9906,0x0000,
+     0x98f8,0x9901,0x0000,0x99be,0x99bc,0x99b7,0x99b6,0x99c0,0x0000,0x99b8,
+     0x0000,0x0000,0x0000,0x99c4,0x0000,0x99bf,0x0000,0x9ada,0x9ae4,0x9ae9,
+     0x9ae8,0x9aea,0x9ae5,0x0000,0x9b26,0x0000,0x0000,0x9b40,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x0000
+   },
+   {				/* ku 2b */
+     0x0000,0x9ebd,0x0000,0x0000,0x0000,0x0000,0x510e,0x0000,0x50f7,0x0000,
+     0x50fc,0x510d,0x5101,0x51da,0x51d9,0x51db,0x5286,0x528e,0x52ee,0x5333,
+     0x53b1,0x0000,0x5647,0x562d,0x5654,0x0000,0x564b,0x5652,0x5631,0x5644,
+     0x5656,0x5650,0x562b,0x0000,0x564d,0x5637,0x564f,0x58a2,0x58b7,0x0000,
+     0x58b2,0x0000,0x58aa,0x58b5,0x58b0,0x0000,0x58b4,0x58a4,0x58a7,0x0000,
+     0x5926,0x5afe,0x0000,0x5b04,0x0000,0x5afc,0x0000,0x5b06,0x5b0a,0x5afa,
+     0x5b0d,0x5b00,0x5b0e,0x0000,0x0000,0x0000,0x5d91,0x0000,0x5d8f,0x5d90,
+     0x5d98,0x5da4,0x5d9b,0x5da3,0x5d96,0x5de4,0x5e5a,0x0000,0x0000,0x5e5e,
+     0x0000,0x5fb8,0x6157,0x615c,0x61a6,0x6195,0x6188,0x0000,0x61a3,0x618f,
+     0x0000,0x6164,0x0000,0x6159
+   },
+   {				/* ku 2c */
+     0x6178,0x0000,0x6185,0x6187,0x619e,0x0000,0x0000,0x6198,0x619c,0x0000,
+     0x0000,0x622f,0x6480,0x649b,0x648e,0x648d,0x6494,0x64c6,0x0000,0x64a8,
+     0x6483,0x0000,0x64b9,0x6486,0x64b4,0x64af,0x6491,0x0000,0x64aa,0x64a1,
+     0x64a7,0x66b6,0x66b3,0x0000,0x66bc,0x66ac,0x0000,0x66ad,0x6a0e,0x0000,
+     0x6a1c,0x6a1a,0x0000,0x0000,0x6a0b,0x0000,0x69ef,0x6a0c,0x69f0,0x6a22,
+     0x0000,0x69d8,0x0000,0x6a12,0x69fa,0x0000,0x6a2a,0x0000,0x6a10,0x0000,
+     0x0000,0x6a29,0x69f9,0x69ea,0x6a2c,0x6a24,0x0000,0x69e9,0x6b52,0x6b4f,
+     0x6b53,0x0000,0x0000,0x6f10,0x6f65,0x6f75,0x0000,0x0000,0x0000,0x0000,
+     0x6fd0,0x0000,0x6f5c,0x6f3d,0x6f71,0x0000,0x6f91,0x6f0b,0x6f79,0x6f81,
+     0x6f8f,0x0000,0x6f59,0x6f74
+   },
+   {				/* ku 2d */
+     0x0000,0x71ae,0x0000,0x71a3,0x71ad,0x0000,0x0000,0x71ab,0x71a6,0x71a2,
+     0x0000,0x52f2,0x7257,0x7255,0x7299,0x734b,0x747a,0x0000,0x0000,0x0000,
+     0x748c,0x7484,0x0000,0x0000,0x7482,0x7493,0x747b,0x0000,0x7509,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x778a,0x0000,0x7790,0x0000,0x78c6,
+     0x78d3,0x78c0,0x78d2,0x78c7,0x78c2,0x0000,0x799f,0x799d,0x799e,0x0000,
+     0x7a41,0x0000,0x7a38,0x7a3a,0x7a42,0x0000,0x0000,0x7a3e,0x7ab0,0x7bae,
+     0x7bb3,0x0000,0x0000,0x7bbf,0x0000,0x0000,0x7bcd,0x0000,0x7bb2,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7cc4,0x7ccd,0x7cc2,0x7cc6,
+     0x7cc3,0x7cc9,0x7cc7,0x0000,0x7df8,0x0000,0x7ded,0x7de2,0x0000,0x0000,
+     0x0000,0x7ddc,0x7e02,0x7e01
+   },
+   {				/* ku 2e */
+     0x0000,0x7dd6,0x0000,0x7de4,0x7dfe,0x0000,0x7e00,0x7dfc,0x7dfd,0x0000,
+     0x7df5,0x7dff,0x0000,0x7deb,0x7de5,0x7f78,0x7fae,0x7fe7,0x0000,0x8065,
+     0x806a,0x8066,0x8068,0x806b,0x8194,0x81a1,0x8192,0x8196,0x8193,0x0000,
+     0x0000,0x8501,0x0000,0x84f8,0x0000,0x84f5,0x0000,0x8504,0x0000,0x0000,
+     0x0000,0x0000,0x851b,0x8503,0x8533,0x8534,0x84ed,0x0000,0x0000,0x8535,
+     0x0000,0x8505,0x0000,0x0000,0x0000,0x0000,0x877d,0x0000,0x0000,0x0000,
+     0x8771,0x0000,0x885c,0x88e6,0x890f,0x891b,0x0000,0x89a9,0x89a5,0x89ee,
+     0x8ab1,0x0000,0x8acc,0x8ace,0x0000,0x8ab7,0x0000,0x8ab5,0x8ae9,0x8ab4,
+     0x0000,0x8ab3,0x8ac1,0x8aaf,0x8aca,0x8ad0,0x0000,0x0000,0x0000,0x8c8e,
+     0x0000,0x0000,0x8ce9,0x8cdb
+   },
+   {				/* ku 2f */
+     0x0000,0x8ceb,0x8da4,0x0000,0x8da2,0x8d9d,0x0000,0x0000,0x0000,0x0000,
+     0x8e2a,0x8e28,0x0000,0x0000,0x8eb8,0x8eb6,0x8eb9,0x8eb7,0x8f22,0x8f2b,
+     0x8f27,0x8f19,0x8fa4,0x0000,0x8fb3,0x0000,0x9071,0x906a,0x0000,0x0000,
+     0x9188,0x918c,0x92bf,0x92b8,0x92be,0x92dc,0x92e5,0x0000,0x0000,0x92d4,
+     0x92d6,0x0000,0x92da,0x92ed,0x92f3,0x92db,0x0000,0x92b9,0x92e2,0x92eb,
+     0x95af,0x0000,0x95b2,0x95b3,0x0000,0x0000,0x0000,0x96a3,0x96a5,0x0000,
+     0x0000,0x0000,0x0000,0x970a,0x0000,0x9787,0x9789,0x978c,0x97ef,0x982a,
+     0x9822,0x0000,0x981f,0x0000,0x9919,0x0000,0x99ca,0x99da,0x0000,0x0000,
+     0x0000,0x99de,0x99c8,0x99e0,0x0000,0x9ab6,0x9ab5,0x0000,0x9af4,0x0000,
+     0x9b6b,0x9b69,0x9b72,0x9b63
+   },
+   {				/* ku 30 */
+     0x0000,0x9d0d,0x0000,0x9d01,0x9d0c,0x0000,0x9cf8,0x0000,0x0000,0x9cfe,
+     0x9d02,0x9e84,0x0000,0x9eab,0x9eaa,0x511d,0x5116,0x0000,0x512b,0x511e,
+     0x511b,0x5290,0x5294,0x5314,0x0000,0x0000,0x5667,0x0000,0x567b,0x0000,
+     0x565f,0x5661,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x58c3,
+     0x58ca,0x58bb,0x58c0,0x58c4,0x5901,0x5b1f,0x5b18,0x5b11,0x5b15,0x0000,
+     0x5b12,0x5b1c,0x0000,0x5b22,0x5b79,0x5da6,0x0000,0x5db3,0x5dab,0x5eea,
+     0x0000,0x5f5b,0x0000,0x0000,0x61b7,0x61ce,0x61b9,0x61bd,0x61cf,0x61c0,
+     0x6199,0x6197,0x0000,0x61bb,0x61d0,0x61c4,0x6231,0x0000,0x64d3,0x64c0,
+     0x0000,0x0000,0x0000,0x0000,0x64dc,0x64d1,0x64c8,0x0000,0x64d5,0x66c3,
+     0x0000,0x0000,0x66bf,0x66c5
+   },
+   {				/* ku 31 */
+     0x0000,0x66cd,0x66c1,0x6706,0x0000,0x6724,0x6a63,0x6a42,0x6a52,0x0000,
+     0x6a43,0x6a33,0x0000,0x6a6c,0x6a57,0x0000,0x6a4c,0x6a6e,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x6a37,0x0000,0x6a71,0x6a4a,0x6a36,0x0000,0x6a53,
+     0x0000,0x6a45,0x6a70,0x0000,0x0000,0x6a5c,0x6b58,0x6b57,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x6fbb,0x0000,0x0000,0x6fbe,0x0000,0x0000,
+     0x0000,0x6fb5,0x6fd3,0x6f9f,0x0000,0x6fb7,0x6ff5,0x71b7,0x0000,0x71bb,
+     0x0000,0x71d1,0x0000,0x71ba,0x0000,0x71b6,0x71cc,0x0000,0x0000,0x71d3,
+     0x749b,0x0000,0x0000,0x7496,0x74a2,0x749d,0x750a,0x750e,0x0000,0x7581,
+     0x762c,0x7637,0x7636,0x763b,0x0000,0x76a1,0x0000,0x0000,0x7798,0x0000,
+     0x7796,0x0000,0x0000,0x0000
+   },
+   {				/* ku 32 */
+     0x78d6,0x78eb,0x0000,0x78dc,0x0000,0x79a5,0x79a9,0x9834,0x7a53,0x7a45,
+     0x0000,0x7a4f,0x0000,0x7abd,0x7abb,0x7af1,0x0000,0x0000,0x7bec,0x7bed,
+     0x0000,0x0000,0x7cd3,0x0000,0x7ce1,0x0000,0x7e19,0x0000,0x0000,0x0000,
+     0x7e27,0x7e26,0x0000,0x0000,0x806e,0x81af,0x0000,0x0000,0x81ad,0x0000,
+     0x81aa,0x8218,0x0000,0x0000,0x0000,0x0000,0x856f,0x854c,0x0000,0x8542,
+     0x0000,0x855c,0x8570,0x855f,0x0000,0x855a,0x854b,0x853f,0x878a,0x0000,
+     0x878b,0x87a1,0x878e,0x0000,0x0000,0x8799,0x885e,0x885f,0x8924,0x89a7,
+     0x8aea,0x8afd,0x8af9,0x8ae3,0x8ae5,0x0000,0x0000,0x8aec,0x0000,0x0000,
+     0x0000,0x0000,0x8cf2,0x0000,0x8cef,0x0000,0x8da6,0x0000,0x0000,0x0000,
+     0x8e3b,0x8e43,0x0000,0x8e32
+   },
+   {				/* ku 33 */
+     0x8f31,0x8f30,0x0000,0x8f2d,0x8f3c,0x8fa7,0x8fa5,0x0000,0x0000,0x0000,
+     0x9137,0x9195,0x918e,0x0000,0x9196,0x0000,0x9345,0x930a,0x0000,0x0000,
+     0x92fd,0x9317,0x931c,0x9307,0x9331,0x9332,0x932c,0x9330,0x9303,0x9305,
+     0x0000,0x95c2,0x0000,0x95b8,0x0000,0x95c1,0x0000,0x0000,0x0000,0x96ab,
+     0x96b7,0x0000,0x0000,0x9715,0x9714,0x0000,0x0000,0x970c,0x9717,0x0000,
+     0x9793,0x0000,0x97d2,0x0000,0x0000,0x9836,0x9831,0x9833,0x983c,0x982e,
+     0x983a,0x0000,0x983d,0x0000,0x98b5,0x9922,0x9923,0x9920,0x991c,0x991d,
+     0x0000,0x99a0,0x0000,0x99ef,0x99e8,0x99eb,0x0000,0x0000,0x0000,0x99e1,
+     0x99e6,0x0000,0x0000,0x9af8,0x9af5,0x0000,0x0000,0x9b83,0x9b94,0x9b84,
+     0x0000,0x9b8b,0x9b8f,0x0000
+   },
+   {				/* ku 34 */
+     0x9b8c,0x0000,0x9b89,0x0000,0x9b8e,0x0000,0x0000,0x0000,0x9d24,0x9d0f,
+     0x0000,0x9d13,0x9d0a,0x0000,0x0000,0x0000,0x0000,0x9d2a,0x9d1a,0x0000,
+     0x9d27,0x9d16,0x9d21,0x0000,0x9e85,0x9eac,0x9ec6,0x9ec5,0x9ed7,0x9f53,
+     0x0000,0x5128,0x5127,0x51df,0x0000,0x5335,0x53b3,0x0000,0x568a,0x567d,
+     0x5689,0x0000,0x58cd,0x58d0,0x0000,0x5b2b,0x5b33,0x5b29,0x5b35,0x5b31,
+     0x5b37,0x5c36,0x5dbe,0x0000,0x5db9,0x0000,0x5dbb,0x0000,0x61e2,0x61db,
+     0x61dd,0x61dc,0x61da,0x0000,0x61d9,0x0000,0x0000,0x64df,0x0000,0x0000,
+     0x64e1,0x0000,0x64ee,0x0000,0x65b5,0x66d4,0x66d5,0x0000,0x66d0,0x66d1,
+     0x66ce,0x66d7,0x0000,0x0000,0x6a7d,0x6a8a,0x0000,0x6aa7,0x0000,0x6a99,
+     0x6a82,0x6a88,0x0000,0x0000
+   },
+   {				/* ku 35 */
+     0x6a86,0x0000,0x6a98,0x6a9d,0x0000,0x0000,0x6a8f,0x0000,0x6aaa,0x0000,
+     0x6b5d,0x0000,0x6c0a,0x0000,0x6fd7,0x6fd6,0x6fe5,0x0000,0x0000,0x0000,
+     0x6fd9,0x6fda,0x6fea,0x0000,0x6ff6,0x0000,0x0000,0x71e3,0x0000,0x71e9,
+     0x0000,0x71eb,0x71ef,0x71f3,0x71ea,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x7371,0x0000,0x74ae,0x0000,0x74b3,0x0000,0x74ac,0x0000,0x0000,0x7583,
+     0x7645,0x764e,0x7644,0x76a3,0x76a5,0x77a6,0x77a4,0x0000,0x77a9,0x77af,
+     0x0000,0x0000,0x0000,0x78f0,0x78f8,0x78f1,0x0000,0x7a49,0x0000,0x0000,
+     0x0000,0x7ac2,0x7af2,0x7af3,0x7bfa,0x0000,0x7bf6,0x7bfc,0x7c18,0x7c08,
+     0x7c12,0x0000,0x0000,0x7cdb,0x7cda,0x0000,0x0000,0x0000,0x7e2c,0x7e4d,
+     0x0000,0x0000,0x7f46,0x7ff6
+   },
+   {				/* ku 36 */
+     0x802b,0x8074,0x81b8,0x81c8,0x0000,0x0000,0x0000,0x8592,0x8593,0x0000,
+     0x857f,0x85ab,0x8597,0x0000,0x0000,0x85ac,0x0000,0x0000,0x0000,0x87ce,
+     0x0000,0x87cd,0x0000,0x0000,0x87c1,0x87b1,0x87c7,0x0000,0x8940,0x0000,
+     0x893f,0x8939,0x0000,0x8943,0x0000,0x0000,0x0000,0x89ab,0x0000,0x8b1f,
+     0x8b09,0x8b0c,0x0000,0x0000,0x8c40,0x0000,0x8c96,0x0000,0x8cf6,0x8cf7,
+     0x0000,0x8e46,0x8e4f,0x0000,0x0000,0x0000,0x8f3d,0x8f41,0x9366,0x9378,
+     0x935d,0x9369,0x9374,0x937d,0x936e,0x9372,0x9373,0x9362,0x9348,0x9353,
+     0x935f,0x9368,0x0000,0x937f,0x936b,0x0000,0x95c4,0x0000,0x96af,0x96ad,
+     0x96b2,0x0000,0x0000,0x971a,0x971b,0x0000,0x0000,0x0000,0x0000,0x979b,
+     0x979f,0x0000,0x0000,0x0000
+   },
+   {				/* ku 37 */
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x9840,0x0000,0x9847,0x0000,0x98b7,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x99a2,0x0000,0x0000,0x9a00,0x99f3,
+     0x0000,0x0000,0x99f5,0x0000,0x0000,0x9abd,0x9b00,0x9b02,0x0000,0x9b34,
+     0x9b49,0x9b9f,0x0000,0x9ba3,0x9bcd,0x9b99,0x9b9d,0x0000,0x0000,0x9d39,
+     0x0000,0x9d44,0x0000,0x0000,0x9d35,0x0000,0x0000,0x9eaf,0x0000,0x512f,
+     0x0000,0x0000,0x9f8e,0x0000,0x569f,0x569b,0x569e,0x5696,0x5694,0x56a0,
+     0x0000,0x5b3b,0x0000,0x0000,0x5b3a,0x5dc1,0x5f4d,0x5f5d,0x61f3,0x0000,
+     0x0000,0x0000,0x0000,0x64f6,0x64e5,0x64ea,0x64e7,0x6505,0x0000,0x64f9,
+     0x0000,0x0000,0x0000,0x6aab,0x6aed,0x6ab2,0x6ab0,0x6ab5,0x6abe,0x6ac1,
+     0x6ac8,0x0000,0x6ac0,0x6abc
+   },
+   {				/* ku 38 */
+     0x6ab1,0x6ac4,0x6abf,0x0000,0x0000,0x7008,0x7003,0x6ffd,0x7010,0x7002,
+     0x7013,0x0000,0x71fa,0x7200,0x74b9,0x74bc,0x0000,0x765b,0x7651,0x764f,
+     0x76eb,0x77b8,0x0000,0x77b9,0x77c1,0x77c0,0x77be,0x790b,0x0000,0x7907,
+     0x790a,0x7908,0x0000,0x790d,0x7906,0x7915,0x79af,0x0000,0x0000,0x0000,
+     0x7af5,0x0000,0x0000,0x7c2e,0x0000,0x7c1b,0x0000,0x7c1a,0x7c24,0x0000,
+     0x0000,0x7ce6,0x7ce3,0x0000,0x0000,0x7e5d,0x7e4f,0x7e66,0x7e5b,0x7f47,
+     0x7fb4,0x0000,0x0000,0x0000,0x7ffa,0x802e,0x0000,0x0000,0x81ce,0x0000,
+     0x0000,0x8219,0x0000,0x0000,0x85cc,0x85b2,0x0000,0x85bb,0x85c1,0x0000,
+     0x0000,0x0000,0x87e9,0x87ee,0x87f0,0x87d6,0x880e,0x87da,0x8948,0x894a,
+     0x894e,0x894d,0x89b1,0x89b0
+   },
+   {				/* ku 39 */
+     0x89b3,0x0000,0x8b38,0x8b32,0x0000,0x8b2d,0x0000,0x8b34,0x0000,0x8b29,
+     0x8c74,0x0000,0x0000,0x8d03,0x0000,0x0000,0x8da9,0x8e58,0x0000,0x0000,
+     0x8ebf,0x8ec1,0x8f4a,0x8fac,0x0000,0x9089,0x913d,0x913c,0x91a9,0x93a0,
+     0x0000,0x9390,0x0000,0x9393,0x938b,0x93ad,0x93bb,0x93b8,0x0000,0x0000,
+     0x939c,0x95d8,0x95d7,0x0000,0x0000,0x0000,0x975d,0x97a9,0x97da,0x0000,
+     0x0000,0x0000,0x0000,0x9854,0x0000,0x9855,0x984b,0x0000,0x983f,0x98b9,
+     0x0000,0x0000,0x0000,0x0000,0x9938,0x9936,0x9940,0x0000,0x993b,0x9939,
+     0x99a4,0x0000,0x0000,0x9a08,0x9a0c,0x0000,0x9a10,0x0000,0x9b07,0x0000,
+     0x9bd2,0x0000,0x9bc2,0x9bbb,0x9bcc,0x9bcb,0x0000,0x0000,0x9d4d,0x9d63,
+     0x9d4e,0x0000,0x9d50,0x9d55
+   },
+   {				/* ku 3a */
+     0x0000,0x9d5e,0x0000,0x9e90,0x9eb2,0x9eb1,0x0000,0x9eca,0x9f02,0x9f27,
+     0x9f26,0x0000,0x56af,0x58e0,0x58dc,0x0000,0x5b39,0x0000,0x0000,0x5b7c,
+     0x5bf3,0x0000,0x0000,0x5c6b,0x5dc4,0x650b,0x6508,0x650a,0x0000,0x0000,
+     0x65dc,0x0000,0x0000,0x66e1,0x66df,0x6ace,0x6ad4,0x6ae3,0x6ad7,0x6ae2,
+     0x0000,0x0000,0x0000,0x0000,0x6ad8,0x6ad5,0x6ad2,0x0000,0x0000,0x701e,
+     0x702c,0x7025,0x6ff3,0x7204,0x7208,0x7215,0x0000,0x74c4,0x74c9,0x74c7,
+     0x74c8,0x76a9,0x77c6,0x77c5,0x7918,0x791a,0x7920,0x0000,0x7a66,0x7a64,
+     0x7a6a,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x7c35,0x7c34,0x0000,
+     0x0000,0x7e6c,0x0000,0x7e6e,0x7e71,0x0000,0x81d4,0x81d6,0x821a,0x8262,
+     0x8265,0x8276,0x85db,0x85d6
+   },
+   {				/* ku 3b */
+     0x0000,0x85e7,0x0000,0x0000,0x85f4,0x0000,0x87fd,0x87d5,0x8807,0x0000,
+     0x880f,0x87f8,0x0000,0x0000,0x8987,0x0000,0x89b5,0x89f5,0x0000,0x8b3f,
+     0x8b43,0x8b4c,0x0000,0x8d0b,0x8e6b,0x8e68,0x8e70,0x8e75,0x8e77,0x0000,
+     0x8ec3,0x0000,0x93e9,0x93ea,0x93cb,0x93c5,0x93c6,0x0000,0x93ed,0x93d3,
+     0x0000,0x93e5,0x0000,0x0000,0x93db,0x93eb,0x93e0,0x93c1,0x0000,0x0000,
+     0x95dd,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x97b2,0x97b4,0x97b1,0x97b5,0x97f2,0x0000,0x0000,0x0000,0x9856,0x0000,
+     0x0000,0x0000,0x9944,0x0000,0x9a26,0x9a1f,0x9a18,0x9a21,0x9a17,0x0000,
+     0x9b09,0x0000,0x0000,0x9bc5,0x9bdf,0x0000,0x9be3,0x0000,0x9be9,0x9bee,
+     0x0000,0x0000,0x9d66,0x9d7a
+   },
+   {				/* ku 3c */
+     0x0000,0x9d6e,0x9d91,0x9d83,0x9d76,0x9d7e,0x9d6d,0x0000,0x9e95,0x9ee3,
+     0x0000,0x0000,0x9f03,0x9f04,0x0000,0x9f17,0x0000,0x5136,0x0000,0x5336,
+     0x0000,0x5b42,0x0000,0x0000,0x5b44,0x5b46,0x5b7e,0x5dca,0x5dc8,0x5dcc,
+     0x5ef0,0x0000,0x6585,0x66e5,0x66e7,0x0000,0x0000,0x0000,0x6af4,0x0000,
+     0x6ae9,0x0000,0x0000,0x0000,0x0000,0x0000,0x703d,0x0000,0x7036,0x0000,
+     0x7216,0x0000,0x7212,0x720f,0x7217,0x7211,0x720b,0x0000,0x0000,0x74cd,
+     0x74d0,0x74cc,0x74ce,0x74d1,0x0000,0x7589,0x0000,0x7a6f,0x7c4b,0x7c44,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x7e7f,0x8b71,0x0000,0x802f,0x807a,
+     0x807b,0x807c,0x0000,0x0000,0x0000,0x85fc,0x8610,0x8602,0x0000,0x0000,
+     0x85ee,0x8603,0x0000,0x860d
+   },
+   {				/* ku 3d */
+     0x8613,0x8608,0x860f,0x8818,0x8812,0x0000,0x0000,0x8967,0x8965,0x89bb,
+     0x8b69,0x8b62,0x0000,0x8b6e,0x0000,0x8b61,0x0000,0x8b64,0x8b4d,0x8c51,
+     0x0000,0x0000,0x8e83,0x8ec6,0x0000,0x941f,0x0000,0x9404,0x9417,0x9408,
+     0x9405,0x0000,0x93f3,0x941e,0x9402,0x941a,0x941b,0x9427,0x941c,0x0000,
+     0x96b5,0x0000,0x0000,0x9733,0x0000,0x9734,0x9731,0x97b8,0x97ba,0x0000,
+     0x97fc,0x0000,0x0000,0x98c3,0x0000,0x994d,0x0000,0x9a2f,0x0000,0x0000,
+     0x0000,0x9ac9,0x0000,0x9ac8,0x9ac4,0x9b2a,0x9b38,0x9b50,0x0000,0x9c0a,
+     0x9bfb,0x9c04,0x9bfc,0x9bfe,0x0000,0x0000,0x0000,0x9c02,0x9bf6,0x9c1b,
+     0x9bf9,0x9c15,0x9c10,0x9bff,0x9c00,0x9c0c,0x0000,0x0000,0x9d95,0x9da5,
+     0x0000,0x0000,0x0000,0x0000
+   },
+   {				/* ku 3e */
+     0x9e98,0x9ec1,0x0000,0x9f5a,0x5164,0x56bb,0x0000,0x58e6,0x5b49,0x5bf7,
+     0x0000,0x0000,0x5dd0,0x0000,0x5fc2,0x0000,0x6511,0x0000,0x6aff,0x6afe,
+     0x6afd,0x0000,0x6b01,0x0000,0x0000,0x704b,0x704d,0x7047,0x74d3,0x7668,
+     0x7667,0x0000,0x0000,0x77d1,0x7930,0x7932,0x792e,0x0000,0x9f9d,0x7ac9,
+     0x7ac8,0x0000,0x7c56,0x7c51,0x0000,0x0000,0x0000,0x7e85,0x7e89,0x7e8e,
+     0x7e84,0x0000,0x826a,0x862b,0x862f,0x8628,0x0000,0x8616,0x8615,0x861d,
+     0x881a,0x0000,0x0000,0x0000,0x89bc,0x8b75,0x8b7c,0x0000,0x8d11,0x8d12,
+     0x8f5c,0x91bb,0x0000,0x93f4,0x0000,0x0000,0x942d,0x0000,0x0000,0x96e4,
+     0x9737,0x9736,0x9767,0x97be,0x97bd,0x97e2,0x9868,0x9866,0x98c8,0x98ca,
+     0x98c7,0x98dc,0x0000,0x994f
+   },
+   {				/* ku 3f */
+     0x99a9,0x9a3c,0x0000,0x9a3b,0x9ace,0x0000,0x9b14,0x9b53,0x0000,0x9c2e,
+     0x0000,0x9c1f,0x0000,0x0000,0x0000,0x0000,0x9db0,0x9dbd,0x0000,0x0000,
+     0x9dae,0x9dc4,0x9e7b,0x0000,0x0000,0x9e9e,0x0000,0x9f05,0x0000,0x9f69,
+     0x9fa1,0x56c7,0x571d,0x5b4a,0x5dd3,0x0000,0x5f72,0x6202,0x0000,0x6235,
+     0x6527,0x651e,0x651f,0x0000,0x0000,0x6b07,0x6b06,0x0000,0x0000,0x7054,
+     0x721c,0x7220,0x7af8,0x0000,0x7c5d,0x7c58,0x0000,0x7e92,0x7f4e,0x0000,
+     0x0000,0x0000,0x8827,0x0000,0x8b81,0x8b83,0x0000,0x8c44,0x0000,0x0000,
+     0x0000,0x0000,0x9442,0x944d,0x9454,0x944e,0x0000,0x9443,0x0000,0x0000,
+     0x973c,0x9740,0x97c0,0x0000,0x0000,0x0000,0x0000,0x995a,0x9a51,0x0000,
+     0x9add,0x0000,0x0000,0x9c38
+   },
+   {				/* ku 40 */
+     0x0000,0x9c45,0x9c3a,0x0000,0x9c35,0x0000,0x0000,0x0000,0x9ef1,0x0000,
+     0x9f93,0x529a,0x0000,0x0000,0x8641,0x5dd7,0x0000,0x6528,0x0000,0x0000,
+     0x0000,0x7053,0x7059,0x0000,0x7221,0x0000,0x766f,0x7937,0x79b5,0x7c62,
+     0x7c5e,0x7cf5,0x0000,0x0000,0x863d,0x0000,0x882d,0x8989,0x8b8d,0x8b87,
+     0x8b90,0x8d1a,0x8e99,0x0000,0x0000,0x0000,0x945f,0x0000,0x0000,0x9456,
+     0x9461,0x945b,0x945a,0x945c,0x9465,0x0000,0x9741,0x0000,0x0000,0x986e,
+     0x986c,0x986d,0x0000,0x99aa,0x9a5c,0x9a58,0x9ade,0x0000,0x9c4f,0x9c51,
+     0x0000,0x9c53,0x0000,0x0000,0x0000,0x9dfc,0x9f39,0x0000,0x513e,0x0000,
+     0x56d2,0x0000,0x5b4f,0x6b14,0x0000,0x7a72,0x7a73,0x0000,0x0000,0x0000,
+     0x8b91,0x0000,0x0000,0x91bf
+   },
+   {				/* ku 41 */
+     0x0000,0x946c,0x0000,0x0000,0x96e6,0x9745,0x0000,0x97c8,0x97e4,0x995d,
+     0x0000,0x9b21,0x0000,0x9b2c,0x9b57,0x0000,0x0000,0x9c5d,0x9c61,0x9c65,
+     0x9e08,0x0000,0x0000,0x0000,0x0000,0x0000,0x9f45,0x0000,0x0000,0x6205,
+     0x66ef,0x6b1b,0x6b1d,0x7225,0x7224,0x7c6d,0x0000,0x8642,0x8649,0x0000,
+     0x8978,0x898a,0x8b97,0x0000,0x8c9b,0x8d1c,0x0000,0x8ea2,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x9c6c,0x0000,0x9c6f,0x0000,
+     0x9e0e,0x0000,0x9f08,0x9f1d,0x9fa3,0x0000,0x0000,0x5f60,0x6b1c,0x0000,
+     0x0000,0x0000,0x7cf3,0x0000,0x8b9b,0x8ea7,0x91c4,0x0000,0x947a,0x0000,
+     0x0000,0x9a61,0x9a63,0x9ad7,0x9c76,0x0000,0x9fa5,0x0000,0x7067,0x0000,
+     0x72ab,0x864a,0x897d,0x8b9d
+   },
+   {				/* ku 42 */
+     0x8c53,0x8f65,0x947b,0x0000,0x98cd,0x98dd,0x0000,0x9b30,0x9e16,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x96e7,0x9e18,0x9ea2,0x0000,0x9f7c,0x0000,
+     0x7e9e,0x9484,0x0000,0x9e1c,0x0000,0x7c71,0x97ca,0x0000,0x0000,0x0000,
+     0x9ea3,0x0000,0x9c7b,0x9f97,0x0000,0x0000,0x9750,0x0000,0x0000,0x0000,
+     0x5727,0x5c13,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x5fc8,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x6765,0x0000,0x0000,0x52bd,0x0000,0x5b66,
+     0x0000,0x65f9,0x6788,0x6ce6,0x6ccb,0x0000,0x4fbd,0x5f8d,0x0000,0x6018,
+     0x6048,0x0000,0x6b29,0x70a6,0x0000,0x7706,0x0000,0x0000,0x0000,0x5a10,
+     0x5cfc,0x5cfe,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x70c9,0x0000,
+     0x0000,0x0000,0x0000,0x0000
+   },
+   {				/* ku 43 */
+     0x0000,0x0000,0x9579,0x0000,0x96ba,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x0000,0x0000,0x7b29,0x8128,0x0000,0x8a2e,0x0000,0x0000,0x0000,0x9ad9,
+     0x0000,0x582b,0x5845,0x0000,0x63fa,0x0000,0x0000,0x0000,0x6e86,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x5867,0x0000,0x5bdd,0x656e,0x0000,0x0000,
+     0x0000,0x8c87,0x0000,0x50d2,0x50df,0x0000,0x0000,0x0000,0x0000,0x69ba,
+     0x0000,0x6b9d,0x0000,0x8059,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x6f8a,0x0000,0x0000,0x7bc3,
+     0x7bc2,0x0000,0x0000,0x0000,0x0000,0x90f6,0x0000,0x9823,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x71cd,0x7499,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x9842,0x0000,0x0000,0x0000
+   },
+   {				/* ku 44 */
+     0x0000,0x7f84,0x0000,0x0000,0x0000,0x0000,0x0000,0x8d0e,0x0000,0x9861,
+     0x0000,0x0000,0x8b73,0x0000,0x9c27,0x0000,0x9458,0x77d6,0x9b2d,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x4f66,
+     0x4f68,0x4fe7,0x503f,0x0000,0x50a6,0x510f,0x523e,0x5324,0x5365,0x539b,
+     0x517f,0x54cb,0x5573,0x5571,0x556b,0x55f4,0x5622,0x5620,0x5692,0x56ba,
+     0x5691,0x56b0,0x5759,0x578a,0x580f,0x5812,0x5813,0x5847,0x589b,0x5900,
+     0x594d,0x5ad1,0x5ad3,0x5b67,0x5c57,0x5c77,0x5cd5,0x5d75,0x5d8e,0x5da5,
+     0x5db6,0x5dbf,0x5e65,0x5ecd,0x5eed,0x5f94,0x5f9a,0x5fba,0x6125,0x6150,
+     0x62a3,0x6360,0x6364,0x63b6
+   },
+   {				/* ku 45 */
+     0x6403,0x64b6,0x651a,0x7a25,0x5c21,0x66e2,0x6702,0x67a4,0x67ac,0x6810,
+     0x6806,0x685e,0x685a,0x692c,0x6929,0x6a2d,0x6a77,0x6a7a,0x6aca,0x6ae6,
+     0x6af5,0x6b0d,0x6b0e,0x6bdc,0x6bdd,0x6bf6,0x6c1e,0x6c63,0x6da5,0x6e0f,
+     0x6e8a,0x6e84,0x6e8b,0x6e7c,0x6f4c,0x6f48,0x6f49,0x6f9d,0x6f99,0x6ff8,
+     0x702e,0x702d,0x705c,0x79cc,0x70bf,0x70ea,0x70e5,0x7111,0x7112,0x713f,
+     0x7139,0x713b,0x713d,0x7177,0x7175,0x7176,0x7171,0x7196,0x7193,0x71b4,
+     0x71dd,0x71de,0x720e,0x5911,0x7218,0x7347,0x7348,0x73ef,0x7412,0x743b,
+     0x74a4,0x748d,0x74b4,0x7673,0x7677,0x76bc,0x7819,0x781b,0x783d,0x7853,
+     0x7854,0x7858,0x78b7,0x78d8,0x78ee,0x7922,0x794d,0x7986,0x7999,0x79a3,
+     0x79bc,0x7aa7,0x7b37,0x7b59
+   },
+   {				/* ku 46 */
+     0x7bd0,0x7c2f,0x7c32,0x7c42,0x7c4e,0x7c68,0x7ca9,0x7ced,0x7dd0,0x7e07,
+     0x7dd3,0x7e64,0x7f40,0x0000,0x8041,0x8063,0x80bb,0x6711,0x6725,0x8248,
+     0x8310,0x8362,0x8312,0x8421,0x841e,0x84e2,0x84de,0x84e1,0x8573,0x85d4,
+     0x85f5,0x8637,0x8645,0x8672,0x874a,0x87a9,0x87a5,0x87f5,0x8834,0x8850,
+     0x8887,0x8954,0x8984,0x8b03,0x8c52,0x8cd8,0x8d0c,0x8d18,0x8db0,0x8ebc,
+     0x8ed5,0x8faa,0x909c,0x0000,0x915c,0x922b,0x9221,0x9273,0x92f4,0x92f5,
+     0x933f,0x9342,0x9386,0x93be,0x93bc,0x93bd,0x93f1,0x93f2,0x93ef,0x9422,
+     0x9423,0x9424,0x9467,0x9466,0x9597,0x95ce,0x95e7,0x973b,0x974d,0x98e4,
+     0x9942,0x9b1d,0x9b98,0x0000,0x9d49,0x6449,0x5e71,0x5e85,0x61d3,0x990e,
+     0x8002,0x781e,0x0000,0x0000
+   },
+   {				/* ku 47 */
+     0x5528,0x5572,0x55ba,0x55f0,0x55ee,0x56b8,0x56b9,0x56c4,0x8053,0x92b0,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
+     0x0000,0x0000,0x0000,0x0000
+   }
+ };
diff -c -N c-client.pure/drivers c-client/drivers
*** c-client.pure/drivers	Thu Jan  1 01:00:00 1970
--- c-client/drivers	Sat Feb  5 14:44:02 2000
***************
*** 0 ****
--- 1,44 ----
+ #!/bin/sh
+ #
+ # Program:	Driver Linkage Generator
+ #
+ # Author:	Mark Crispin
+ #		Networks and Distributed Computing
+ #		Computing & Communications
+ #		University of Washington
+ #		Administration Building, AG-44
+ #		Seattle, WA  98195
+ #		Internet: MRC@CAC.Washington.EDU
+ #
+ # Date:		11 October 1989
+ # Last Edited:	11 October 1993
+ #
+ # Copyright 1993 by the University of Washington
+ #
+ #  Permission to use, copy, modify, and distribute this software and its
+ # documentation for any purpose and without fee is hereby granted, provided
+ # that the above copyright notice appears in all copies and that both the
+ # above copyright notice and this permission notice appear in supporting
+ # documentation, and that the name of the University of Washington not be
+ # used in advertising or publicity pertaining to distribution of the software
+ # without specific, written prior permission.  This software is made
+ # available "as is", and
+ # THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+ # WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+ # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+ # NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+ # INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+ # LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+ # (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+ # WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ 
+ 
+ # Erase old driver linkage
+ rm -f linkage.[ch]
+ 
+ # Now define the new list
+ for driver
+  do
+   echo "extern DRIVER "$driver"driver;" >> linkage.h
+   echo "  mail_link (&"$driver"driver);		/* link in the $driver driver */" | cat >> linkage.c
+ done
Binary files c-client.pure/dummy.o and c-client/dummy.o differ
Binary files c-client.pure/fdstring.o and c-client/fdstring.o differ
Binary files c-client.pure/flstring.o and c-client/flstring.o differ
Binary files c-client.pure/imap4r1.o and c-client/imap4r1.o differ
diff -c -N c-client.pure/link_nt.c c-client/link_nt.c
*** c-client.pure/link_nt.c	Thu Jan  1 01:00:00 1970
--- c-client/link_nt.c	Sat Feb  5 14:44:03 2000
***************
*** 0 ****
--- 1,11 ----
+   mail_link (&imapdriver);	/* link in the imap driver */
+   mail_link (&nntpdriver);	/* link in the nntp driver */
+   mail_link (&pop3driver);	/* link in the pop3 driver */
+   mail_link (&newsdriver);	/* link in the news driver */
+   mail_link (&mhdriver);	/* link in the MH driver */
+   mail_link (&mbxdriver);	/* link in the mbx driver */
+   mail_link (&mtxdriver);	/* link in the mtx driver */
+   mail_link (&tenexdriver);	/* link in the tenex driver */
+   mail_link (&unixdriver);	/* link in the unix driver */
+   mail_link (&dummydriver);	/* link in the dummy driver */
+   auth_link (&auth_log);		/* link in the log authenticator */
diff -c -N c-client.pure/link_nt.h c-client/link_nt.h
*** c-client.pure/link_nt.h	Thu Jan  1 01:00:00 1970
--- c-client/link_nt.h	Sat Feb  5 14:44:03 2000
***************
*** 0 ****
--- 1,11 ----
+ extern DRIVER imapdriver;
+ extern DRIVER nntpdriver;
+ extern DRIVER pop3driver;
+ extern DRIVER mhdriver;
+ extern DRIVER mbxdriver;
+ extern DRIVER mtxdriver;
+ extern DRIVER tenexdriver;
+ extern DRIVER unixdriver;
+ extern DRIVER dummydriver;
+ extern AUTHENTICATOR auth_log;
+ #define DEFAULTPROTO mbxproto
diff -c -N c-client.pure/linkage.c c-client/linkage.c
*** c-client.pure/linkage.c	Sat Feb  5 18:29:52 2000
--- c-client/linkage.c	Sat Feb  5 16:56:55 2000
***************
*** 12,18 ****
    mail_link (&newsdriver);		/* link in the news driver */
    mail_link (&philedriver);		/* link in the phile driver */
    mail_link (&dummydriver);		/* link in the dummy driver */
!   auth_link (&auth_md5);		/* link in the md5 authenticator */
!   auth_link (&auth_log);		/* link in the log authenticator */
    auth_link (&auth_md5);		/* link in the md5 authenticator */
    auth_link (&auth_log);		/* link in the log authenticator */
--- 12,17 ----
    mail_link (&newsdriver);		/* link in the news driver */
    mail_link (&philedriver);		/* link in the phile driver */
    mail_link (&dummydriver);		/* link in the dummy driver */
!   auth_link (&auth_ssl);		/* link in the ssl authenticator */
    auth_link (&auth_md5);		/* link in the md5 authenticator */
    auth_link (&auth_log);		/* link in the log authenticator */
diff -c -N c-client.pure/linkage.h c-client/linkage.h
*** c-client.pure/linkage.h	Sat Feb  5 18:29:56 2000
--- c-client/linkage.h	Sat Feb  5 16:56:55 2000
***************
*** 12,18 ****
  extern DRIVER newsdriver;
  extern DRIVER philedriver;
  extern DRIVER dummydriver;
! extern AUTHENTICATOR auth_md5;
! extern AUTHENTICATOR auth_log;
  extern AUTHENTICATOR auth_md5;
  extern AUTHENTICATOR auth_log;
--- 12,17 ----
  extern DRIVER newsdriver;
  extern DRIVER philedriver;
  extern DRIVER dummydriver;
! extern AUTHENTICATOR auth_ssl;
  extern AUTHENTICATOR auth_md5;
  extern AUTHENTICATOR auth_log;
Binary files c-client.pure/mail.o and c-client/mail.o differ
diff -c -N c-client.pure/makefile.nt c-client/makefile.nt
*** c-client.pure/makefile.nt	Thu Jan  1 01:00:00 1970
--- c-client/makefile.nt	Sat Feb  5 14:44:03 2000
***************
*** 0 ****
--- 1,114 ----
+ # Program:	Portable C client makefile -- NT version
+ #
+ # Author:	Mark Crispin
+ #		Networks and Distributed Computing
+ #		Computing & Communications
+ #		University of Washington
+ #		Administration Building, AG-44
+ #		Seattle, WA  98195
+ #		Internet: MRC@CAC.Washington.EDU
+ #
+ # Date:		11 May 1989
+ # Last Edited:	24 November 1998
+ #
+ # Copyright 1998 by the University of Washington
+ #
+ #  Permission to use, copy, modify, and distribute this software and its
+ # documentation for any purpose and without fee is hereby granted, provided
+ # that the above copyright notice appears in all copies and that both the
+ # above copyright notice and this permission notice appear in supporting
+ # documentation, and that the name of the University of Washington not be
+ # used in advertising or publicity pertaining to distribution of the software
+ # without specific, written prior permission.  This software is made
+ # available "as is", and
+ # THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+ # WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+ # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+ # NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+ # INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+ # LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+ # (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+ # WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ 
+ 
+ EXTRAAUTHENTICATORS=
+ EXTRADRIVERS = 
+ EXTRACFLAGS=
+ DEFAULTAUTHENTICATORS=md5 log
+ DRIVERS = imap nntp pop3 mbx mtx tenex unix
+ DEFAULTDRIVER = mbx
+ CFLAGS= /MT /W3 /Ox /DWIN32 -nologo $(EXTRACFLAGS)
+ CC = cl
+ CCLIENTLIB= cclient.lib
+ 
+ all:	$(CCLIENTLIB)
+ 
+ .c.obj:
+ 	$(CC) -c $(CFLAGS) $*.c
+ 
+ osdep.h: os_nt.h
+ 	copy os_nt.h osdep.h
+ 	drivers $(EXTRADRIVERS) $(DRIVERS) dummy
+ 	mkauths $(EXTRAAUTHENTICATORS) $(DEFAULTAUTHENTICATORS)
+ 	setproto $(DEFAULTDRIVER)
+ 
+ mail.obj: mail.h misc.h osdep.h mail.c
+ 
+ misc.obj: mail.h misc.h misc.c
+ 
+ fdstring.obj: mail.h misc.h osdep.h fdstring.h fdstring.c
+ 
+ flstring.obj: mail.h misc.h osdep.h flstring.h flstring.c
+ 
+ netmsg.obj: mail.h misc.h netmsg.h osdep.h netmsg.c
+ 
+ newsrc.obj: mail.h misc.h newsrc.h osdep.h newsrc.c
+ 
+ rfc822.obj: mail.h rfc822.h misc.h rfc822.c
+ 
+ smanager.obj: mail.h misc.h smanager.c
+ 
+ utf8.obj: mail.h misc.h osdep.h utf8.h
+ 
+ imap4r1.obj: mail.h imap4r1.h misc.h osdep.h imap4r1.c
+ 
+ nntp.obj: mail.h nntp.h smtp.h rfc822.h misc.h osdep.h nntp.c
+ 
+ pop3.obj: mail.h pop3.h misc.h osdep.h pop3.c
+ 
+ smtp.obj: mail.h smtp.h rfc822.h misc.h osdep.h smtp.c
+ 
+ os_nt.obj: mail.h osdep.h env_nt.h fs.h ftl.h nl.h tcp.h tcp_nt.h yunchan.h \
+ 	os_nt.c fs_nt.c ftl_nt.c nl_nt.c env_nt.c tcp_nt.c yunchan.c \
+ 	mailfile.h auth_md5.c auth_log.c
+ 
+ mbxnt.obj: mail.h mbxnt.h misc.h osdep.h mbxnt.c
+ 
+ mtxnt.obj: mail.h mtxnt.h misc.h osdep.h mtxnt.c
+ 
+ tenexnt.obj: mail.h tenexnt.h misc.h osdep.h tenexnt.c
+ 
+ unixnt.obj: mail.h unixnt.h pseudo.h misc.h osdep.h unixnt.c
+ 
+ dummynt.obj: mail.h dummy.h misc.h osdep.h dummynt.c
+ 
+ pseudo.obj: pseudo.h
+ 
+ $(CCLIENTLIB): mail.obj misc.obj fdstring.obj flstring.obj netmsg.obj \
+ 	newsrc.obj rfc822.obj smanager.obj utf8.obj \
+ 	imap4r1.obj nntp.obj pop3.obj smtp.obj os_nt.obj \
+ 	mbxnt.obj mtxnt.obj tenexnt.obj unixnt.obj dummynt.obj pseudo.obj
+ 	erase $(CCLIENTLIB)
+ 	LIB /NOLOGO /OUT:cclient.lib \
+ 	mail.obj misc.obj fdstring.obj flstring.obj netmsg.obj \
+ 	newsrc.obj rfc822.obj smanager.obj utf8.obj \
+ 	imap4r1.obj nntp.obj pop3.obj smtp.obj os_nt.obj \
+ 	mbxnt.obj mtxnt.obj tenexnt.obj unixnt.obj dummynt.obj pseudo.obj
+ 
+ clean:
+ 	del *.lib *.obj linkage.* osdep.* auths.c *.exe *.exp
+ 
+ # A monument to a hack of long ago and far away...
+ 
+ love:
+ 	@echo not war?
Binary files c-client.pure/mbox.o and c-client/mbox.o differ
Binary files c-client.pure/mbx.o and c-client/mbx.o differ
diff -c -N c-client.pure/mh.c c-client/mh.c
*** c-client.pure/mh.c	Sat Feb  5 18:29:53 2000
--- c-client/mh.c	Sat Feb  5 16:56:13 2000
***************
*** 1036,1038 ****
--- 1036,1046 ----
    tp[1] = mail_longdate (elt);	/* modification time */
    utime (file,tp);		/* set the times */
  }
+ 
+ /*MAHOGANY: added */
+ /* Retrieve the MH path
+  *  */
+ extern char *mh_getpath(void)
+ {
+ 	  return mh_path;
+ }
diff -c -N c-client.pure/mh.c~ c-client/mh.c~
*** c-client.pure/mh.c~	Thu Jan  1 01:00:00 1970
--- c-client/mh.c~	Sat Feb  5 14:45:52 2000
***************
*** 0 ****
--- 1,1038 ----
+ /*
+  * Program:	MH mail routines
+  *
+  * Author(s):	Mark Crispin
+  *		Networks and Distributed Computing
+  *		Computing & Communications
+  *		University of Washington
+  *		Administration Building, AG-44
+  *		Seattle, WA  98195
+  *		Internet: MRC@CAC.Washington.EDU
+  *
+  * Date:	23 February 1992
+  * Last Edited:	19 October 1999
+  *
+  * Copyright 1999 by the University of Washington
+  *
+  *  Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notice appears in all copies and that both the
+  * above copyright notice and this permission notice appear in supporting
+  * documentation, and that the name of the University of Washington not be
+  * used in advertising or publicity pertaining to distribution of the software
+  * without specific, written prior permission.  This software is made
+  * available "as is", and
+  * THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+  * WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+  * NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+  * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+  * (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+  * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  */
+ 
+ #include <stdio.h>
+ #include <ctype.h>
+ #include <errno.h>
+ extern int errno;		/* just in case */
+ #include "mail.h"
+ #include "osdep.h"
+ #include <pwd.h>
+ #include <sys/stat.h>
+ #include <sys/time.h>
+ #include "mh.h"
+ #include "misc.h"
+ #include "dummy.h"
+ 
+ /* MH mail routines */
+ 
+ 
+ /* Driver dispatch used by MAIL */
+ 
+ DRIVER mhdriver = {
+   "mh",				/* driver name */
+ 				/* driver flags */
+   DR_MAIL|DR_LOCAL|DR_NOFAST|DR_NAMESPACE|DR_NOSTICKY,
+   (DRIVER *) NIL,		/* next driver */
+   mh_valid,			/* mailbox is valid for us */
+   mh_parameters,		/* manipulate parameters */
+   mh_scan,			/* scan mailboxes */
+   mh_list,			/* find mailboxes */
+   mh_lsub,			/* find subscribed mailboxes */
+   mh_subscribe,			/* subscribe to mailbox */
+   mh_unsubscribe,		/* unsubscribe from mailbox */
+   mh_create,			/* create mailbox */
+   mh_delete,			/* delete mailbox */
+   mh_rename,			/* rename mailbox */
+   NIL,				/* status of mailbox */
+   mh_open,			/* open mailbox */
+   mh_close,			/* close mailbox */
+   mh_fast,			/* fetch message "fast" attributes */
+   NIL,				/* fetch message flags */
+   NIL,				/* fetch overview */
+   NIL,				/* fetch message envelopes */
+   mh_header,			/* fetch message header */
+   mh_text,			/* fetch message body */
+   NIL,				/* fetch partial message text */
+   NIL,				/* unique identifier */
+   NIL,				/* message number */
+   NIL,				/* modify flags */
+   NIL,				/* per-message modify flags */
+   NIL,				/* search for message based on criteria */
+   NIL,				/* sort messages */
+   NIL,				/* thread messages */
+   mh_ping,			/* ping mailbox to see if still alive */
+   mh_check,			/* check for new messages */
+   mh_expunge,			/* expunge deleted messages */
+   mh_copy,			/* copy messages to another mailbox */
+   mh_append,			/* append string message to mailbox */
+   NIL				/* garbage collect stream */
+ };
+ 
+ 				/* prototype stream */
+ MAILSTREAM mhproto = {&mhdriver};
+ 
+ 
+ /* MH mail validate mailbox
+  * Accepts: mailbox name
+  * Returns: our driver if name is valid, NIL otherwise
+  */
+ 
+ DRIVER *mh_valid (char *name)
+ {
+   char tmp[MAILTMPLEN];
+   return mh_isvalid (name,tmp,T) ? &mhdriver : NIL;
+ }
+ 
+ /* MH mail test for valid mailbox
+  * Accepts: mailbox name
+  *	    temporary buffer to use
+  *	    syntax only test flag
+  * Returns: T if valid, NIL otherwise
+  */
+ 
+ static char *mh_profile = NIL;	/* holds MH profile */
+ static char *mh_path = NIL;	/* holds MH path name */
+ static long mh_once = 0;	/* already through this code */
+ 
+ int mh_isvalid (char *name,char *tmp,long synonly)
+ {
+   struct stat sbuf;
+ 				/* name must be #MHINBOX or #mh/... */
+   if (strcmp (ucase (strcpy (tmp,name)),"#MHINBOX") &&
+       !(tmp[0] == '#' && tmp[1] == 'M' && tmp[2] == 'H' && tmp[3] == '/')) {
+     errno = EINVAL;		/* bogus name */
+     return NIL;
+   }
+   if (!mh_path) {		/* have MH path yet? */
+     char *s,*t,*v;
+     int fd;
+     if (mh_once++) return NIL;	/* only do this code once */
+     if (!mh_profile) {		/* have MH profile? */
+       sprintf (tmp,"%s/%s",myhomedir (),MHPROFILE);
+       mh_profile = cpystr (tmp);
+     }
+     if ((fd = open (tmp,O_RDONLY,NIL)) < 0) {
+       strcat (tmp," not found, mh format names disabled");
+       mm_log (tmp,WARN);
+       return NIL;
+     }
+     fstat (fd,&sbuf);		/* yes, get size and read file */
+     read (fd,(t = (char *) fs_get (sbuf.st_size + 1)),sbuf.st_size);
+     close (fd);			/* don't need the file any more */
+     t[sbuf.st_size] = '\0';	/* tie it off */
+ 				/* parse profile file */
+     for (s = strtok (t,"\r\n"); s && *s; s = strtok (NIL,"\r\n")) {
+ 				/* found space in line? */
+       if (v = strpbrk (s," \t")) {
+ 	*v++ = '\0';		/* tie off, is keyword "Path:"? */
+ 	if (!strcmp (lcase (s),"path:")) {
+ 				/* skip whitespace */
+ 	  while ((*v == ' ') || (*v == '\t')) ++v;
+ 	  if (*v == '/') s = v;	/* absolute path? */
+ 	  else sprintf (s = tmp,"%s/%s",myhomedir (),v);
+ 	  mh_path = cpystr (s);	/* copy name */
+ 	  break;		/* don't need to look at rest of file */
+ 	}
+       }
+     }
+     fs_give ((void **) &t);	/* flush profile text */
+     if (!mh_path) {		/* default path if not in the profile */
+       sprintf (tmp,"%s/%s",myhomedir (),MHPATH);
+       mh_path = cpystr (tmp);
+     }
+   }
+   if (synonly) return T;	/* all done if syntax only check */
+   errno = NIL;			/* zap error */
+ 				/* validate name as directory */
+   return ((stat (mh_file (tmp,name),&sbuf) == 0) &&
+ 	  (sbuf.st_mode & S_IFMT) == S_IFDIR);
+ }
+ 
+ /* MH manipulate driver parameters
+  * Accepts: function code
+  *	    function-dependent value
+  * Returns: function-dependent return value
+  */
+ 
+ void *mh_parameters (long function,void *value)
+ {
+   switch ((int) function) {
+   case SET_MHPROFILE:
+     if (mh_profile) fs_give ((void **) &mh_profile);
+     mh_profile = cpystr ((char *) value);
+     break;
+   case GET_MHPROFILE:
+     value = (void *) mh_profile;
+     break;
+   case SET_MHPATH:
+     if (mh_path) fs_give ((void **) &mh_path);
+     mh_path = cpystr ((char *) value);
+     break;
+   case GET_MHPATH:
+     value = (void *) mh_path;
+     break;
+   default:
+     value = NIL;		/* error case */
+     break;
+   }
+   return NIL;
+ }
+ 
+ /* MH scan mailboxes
+  * Accepts: mail stream
+  *	    reference
+  *	    pattern to search
+  *	    string to scan
+  */
+ 
+ void mh_scan (MAILSTREAM *stream,char *ref,char *pat,char *contents)
+ {
+   char tmp[MAILTMPLEN];
+   if (mh_canonicalize (tmp,ref,pat))
+     mm_log ("Scan not valid for mh mailboxes",ERROR);
+ }
+ 
+ 
+ /* MH list mailboxes
+  * Accepts: mail stream
+  *	    reference
+  *	    pattern to search
+  */
+ 
+ void mh_list (MAILSTREAM *stream,char *ref,char *pat)
+ {
+   char *s,test[MAILTMPLEN],file[MAILTMPLEN];
+   long i = 0;
+   if (!pat || !*pat) {		/* empty pattern? */
+     if (mh_canonicalize (test,ref,"*")) {
+ 				/* tie off name at root */
+       if (s = strchr (test,'/')) *++s = '\0';
+       else test[0] = '\0';
+       mm_list (stream,'/',test,LATT_NOSELECT);
+     }
+   }
+ 				/* get canonical form of name */
+   else if (mh_canonicalize (test,ref,pat)) {
+     if (test[3] == '/') {	/* looking down levels? */
+ 				/* yes, found any wildcards? */
+       if (s = strpbrk (test,"%*")) {
+ 				/* yes, copy name up to that point */
+ 	strncpy (file,test+4,i = s - (test+4));
+ 	file[i] = '\0';		/* tie off */
+       }
+       else strcpy (file,test+4);/* use just that name then */
+ 				/* find directory name */
+       if (s = strrchr (file,'/')) {
+ 	*s = '\0';		/* found, tie off at that point */
+ 	s = file;
+       }
+ 				/* do the work */
+       mh_list_work (stream,s,test,0);
+     }
+ 				/* always an INBOX */
+     if (pmatch ("#MHINBOX",ucase (test)))
+       mm_list (stream,NIL,"#MHINBOX",LATT_NOINFERIORS);
+   }
+ }
+ 
+ /* MH list subscribed mailboxes
+  * Accepts: mail stream
+  *	    reference
+  *	    pattern to search
+  */
+ 
+ void mh_lsub (MAILSTREAM *stream,char *ref,char *pat)
+ {
+   void *sdb = NIL;
+   char *s,test[MAILTMPLEN];
+ 				/* get canonical form of name */
+   if (mh_canonicalize (test,ref,pat) && (s = sm_read (&sdb))) {
+     do if (pmatch_full (s,test,'/')) mm_lsub (stream,'/',s,NIL);
+     while (s = sm_read (&sdb)); /* until no more subscriptions */
+   }
+ }
+ 
+ /* MH list mailboxes worker routine
+  * Accepts: mail stream
+  *	    directory name to search
+  *	    search pattern
+  *	    search level
+  */
+ 
+ void mh_list_work (MAILSTREAM *stream,char *dir,char *pat,long level)
+ {
+   DIR *dp;
+   struct direct *d;
+   struct stat sbuf;
+   char *cp,*np,curdir[MAILTMPLEN],name[MAILTMPLEN];
+ 				/* build MH name to search */
+   if (dir) sprintf (name,"#mh/%s/",dir);
+   else strcpy (name,"#mh/");
+ 				/* make directory name, punt if bogus */
+   if (!mh_file (curdir,name)) return;
+   cp = curdir + strlen (curdir);/* end of directory name */
+   np = name + strlen (name);	/* end of MH name */
+   if (dp = opendir (curdir)) {	/* open directory */
+     while (d = readdir (dp))	/* scan, ignore . and numeric names */
+       if ((d->d_name[0] != '.') && !mh_select (d)) {
+ 	strcpy (cp,d->d_name);	/* make directory name */
+ 	if (!stat (curdir,&sbuf) && ((sbuf.st_mode &= S_IFMT) == S_IFDIR)) {
+ 	  strcpy (np,d->d_name);/* make mh name of directory name */
+ 				/* yes, an MH name if full match */
+ 	  if (pmatch_full (name,pat,'/')) mm_list (stream,'/',name,NIL);
+ 				/* check if should recurse */
+ 	  if (dmatch (name,pat,'/') &&
+ 	      (level < (long) mail_parameters (NIL,GET_LISTMAXLEVEL,NIL)))
+ 	    mh_list_work (stream,name+4,pat,level+1);
+ 	}
+       }
+     closedir (dp);		/* all done, flush directory */
+   }
+ }
+ 
+ /* MH mail subscribe to mailbox
+  * Accepts: mail stream
+  *	    mailbox to add to subscription list
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long mh_subscribe (MAILSTREAM *stream,char *mailbox)
+ {
+   return sm_subscribe (mailbox);
+ }
+ 
+ 
+ /* MH mail unsubscribe to mailbox
+  * Accepts: mail stream
+  *	    mailbox to delete from subscription list
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long mh_unsubscribe (MAILSTREAM *stream,char *mailbox)
+ {
+   return sm_unsubscribe (mailbox);
+ }
+ 
+ /* MH mail create mailbox
+  * Accepts: mail stream
+  *	    mailbox name to create
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long mh_create (MAILSTREAM *stream,char *mailbox)
+ {
+   char *s,tmp[MAILTMPLEN];
+ 				/* assume error */
+   sprintf (tmp,"Can't create mailbox %.80s: invalid MH-format name",mailbox);
+   if (mailbox[0] == '#' && (mailbox[1] == 'm' || mailbox[1] == 'M') &&
+       (mailbox[2] == 'h' || mailbox[2] == 'H') && mailbox[3] == '/')
+ 				/* make sure valid name */
+     for (s = mailbox + 4; s && *s;) {
+       if (isdigit (*s)) s++;	/* digit, check this node further... */
+ 				/* all digit node, barf */
+       else if (*s == '/') s = NIL;
+ 				/* non-digit in node, skip to next node */
+       else if (s = strchr (s+1,'/')) s++;
+       else tmp[0] = NIL;	/* no more nodes, good name */
+     }
+   if (tmp[0]) {			/* was there an error in the name? */
+     mm_log (tmp,ERROR);		/* yes, log it */
+     return NIL;
+   }
+ 				/* must not already exist */
+   if (mh_isvalid (mailbox,tmp,NIL)) {
+     sprintf (tmp,"Can't create mailbox %.80s: mailbox already exists",mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   if (!mh_path) return NIL;	/* sorry */
+ 				/* try to make it */
+   if (!(mh_file (tmp,mailbox) && dummy_create_path (stream,strcat (tmp,"/")))){
+     sprintf (tmp,"Can't create mailbox %.80s: %s",mailbox,strerror (errno));
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   return T;			/* return success */
+ }
+ 
+ /* MH mail delete mailbox
+  *	    mailbox name to delete
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long mh_delete (MAILSTREAM *stream,char *mailbox)
+ {
+   DIR *dirp;
+   struct direct *d;
+   int i;
+   char tmp[MAILTMPLEN];
+   if (!(mailbox[0] == '#' && (mailbox[1] == 'm' || mailbox[1] == 'M') &&
+ 	(mailbox[2] == 'h' || mailbox[2] == 'H') && mailbox[3] == '/')) {
+     sprintf (tmp,"Can't delete mailbox %.80s: invalid MH-format name",mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+ 				/* is mailbox valid? */
+   if (!mh_isvalid (mailbox,tmp,NIL)){
+     sprintf (tmp,"Can't delete mailbox %.80s: no such mailbox",mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+ 				/* get name of directory */
+   i = strlen (mh_file (tmp,mailbox));
+   if (dirp = opendir (tmp)) {	/* open directory */
+     tmp[i++] = '/';		/* now apply trailing delimiter */
+     while (d = readdir (dirp))	/* massacre all numeric or comma files */
+       if (mh_select (d) || (*d->d_name == ',') ||
+ 	  !strcmp (d->d_name,MHSEQUENCE)) {
+ 	strcpy (tmp + i,d->d_name);
+ 	unlink (tmp);		/* sayonara */
+       }
+     closedir (dirp);		/* flush directory */
+   }
+ 				/* try to remove the directory */
+   if (rmdir (mh_file (tmp,mailbox))) {
+     sprintf (tmp,"Can't delete mailbox %.80s: %s",mailbox,strerror (errno));
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   return T;			/* return success */
+ }
+ 
+ /* MH mail rename mailbox
+  * Accepts: MH mail stream
+  *	    old mailbox name
+  *	    new mailbox name
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long mh_rename (MAILSTREAM *stream,char *old,char *newname)
+ {
+   char c,*s,tmp[MAILTMPLEN],tmp1[MAILTMPLEN];
+   struct stat sbuf;
+   if (!(old[0] == '#' && (old[1] == 'm' || old[1] == 'M') &&
+ 	(old[2] == 'h' || old[2] == 'H') && old[3] == '/'))
+     sprintf (tmp,"Can't delete mailbox %.80s: invalid MH-format name",old);
+ 				/* old mailbox name must be valid */
+   else if (!mh_isvalid (old,tmp,NIL))
+     sprintf (tmp,"Can't rename mailbox %.80s: no such mailbox",old);
+   else if (!(newname[0] == '#' && (newname[1] == 'm' || newname[1] == 'M') &&
+ 	(newname[2] == 'h' || newname[2] == 'H') && newname[3] == '/'))
+     sprintf (tmp,"Can't rename to mailbox %.80s: invalid MH-format name",
+ 	     newname);
+ 				/* new mailbox name must not be valid */
+   else if (mh_isvalid (newname,tmp,NIL))
+     sprintf (tmp,"Can't rename to mailbox %.80s: destination already exists",
+ 	     newname);
+ 				/* success if can rename the directory */
+   else {			/* found superior to destination name? */
+     if (s = strrchr (mh_file (tmp1,newname),'/')) {
+       c = *++s;			/* remember first character of inferior */
+       *s = '\0';		/* tie off to get just superior */
+ 				/* name doesn't exist, create it */
+       if ((stat (tmp1,&sbuf) || ((sbuf.st_mode & S_IFMT) != S_IFDIR)) &&
+ 	  !dummy_create (stream,tmp1)) return NIL;
+       *s = c;			/* restore full name */
+     }
+     if (!rename (mh_file (tmp,old),tmp1)) return T;
+     sprintf (tmp,"Can't rename mailbox %.80s to %.80s: %s",
+ 	     old,newname,strerror (errno));
+   }
+   mm_log (tmp,ERROR);		/* something failed */
+   return NIL;
+ }
+ 
+ /* MH mail open
+  * Accepts: stream to open
+  * Returns: stream on success, NIL on failure
+  */
+ 
+ MAILSTREAM *mh_open (MAILSTREAM *stream)
+ {
+   char tmp[MAILTMPLEN];
+   if (!stream) return &mhproto;	/* return prototype for OP_PROTOTYPE call */
+   if (stream->local) fatal ("mh recycle stream");
+   stream->local = fs_get (sizeof (MHLOCAL));
+ 				/* note if an INBOX or not */
+   stream->inbox = !strcmp (ucase (strcpy (tmp,stream->mailbox)),"#MHINBOX");
+   mh_file (tmp,stream->mailbox);/* get directory name */
+   LOCAL->dir = cpystr (tmp);	/* copy directory name for later */
+ 				/* make temporary buffer */
+   LOCAL->buf = (char *) fs_get ((LOCAL->buflen = MAXMESSAGESIZE) + 1);
+   LOCAL->scantime = 0;		/* not scanned yet */
+   LOCAL->cachedtexts = 0;	/* no cached texts */
+   stream->sequence++;		/* bump sequence number */
+ 				/* parse mailbox */
+   stream->nmsgs = stream->recent = 0;
+   if (!mh_ping (stream)) return NIL;
+   if (!(stream->nmsgs || stream->silent))
+     mm_log ("Mailbox is empty",(long) NIL);
+   return stream;		/* return stream to caller */
+ }
+ 
+ /* MH mail close
+  * Accepts: MAIL stream
+  *	    close options
+  */
+ 
+ void mh_close (MAILSTREAM *stream,long options)
+ {
+   if (LOCAL) {			/* only if a file is open */
+     int silent = stream->silent;
+     stream->silent = T;		/* note this stream is dying */
+     if (options & CL_EXPUNGE) mh_expunge (stream);
+     if (LOCAL->dir) fs_give ((void **) &LOCAL->dir);
+ 				/* free local scratch buffer */
+     if (LOCAL->buf) fs_give ((void **) &LOCAL->buf);
+ 				/* nuke the local data */
+     fs_give ((void **) &stream->local);
+     stream->dtb = NIL;		/* log out the DTB */
+     stream->silent = silent;	/* reset silent state */
+   }
+ }
+ 
+ 
+ /* MH mail fetch fast information
+  * Accepts: MAIL stream
+  *	    sequence
+  *	    option flags
+  */
+ 
+ void mh_fast (MAILSTREAM *stream,char *sequence,long flags)
+ {
+   unsigned long i,j;
+ 				/* ugly and slow */
+   if (stream && LOCAL && ((flags & FT_UID) ?
+ 			  mail_uid_sequence (stream,sequence) :
+ 			  mail_sequence (stream,sequence)))
+     for (i = 1; i <= stream->nmsgs; i++)
+       if (mail_elt (stream,i)->sequence) mh_header (stream,i,&j,NIL);
+ }
+ 
+ /* MH mail fetch message header
+  * Accepts: MAIL stream
+  *	    message # to fetch
+  *	    pointer to returned header text length
+  *	    option flags
+  * Returns: message header in RFC822 format
+  */
+ 
+ char *mh_header (MAILSTREAM *stream,unsigned long msgno,unsigned long *length,
+ 		 long flags)
+ {
+   unsigned long i,hdrsize;
+   int fd;
+   char *t;
+   struct stat sbuf;
+   struct tm *tm;
+   MESSAGECACHE *elt;
+   *length = 0;			/* default to empty */
+   if (flags & FT_UID) return "";/* UID call "impossible" */
+   elt = mail_elt (stream,msgno);/* get elt */
+   if (!elt->private.msg.header.text.data) {
+ 				/* purge cache if too big */
+     if (LOCAL->cachedtexts > max (stream->nmsgs * 4096,2097152)) {
+       mail_gc (stream,GC_TEXTS);/* just can't keep that much */
+       LOCAL->cachedtexts = 0;
+     }
+ 				/* build message file name */
+     sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->private.uid);
+     if ((fd = open (LOCAL->buf,O_RDONLY,NIL)) < 0) return "";
+     fstat (fd,&sbuf);		/* get size of message */
+ 				/* make plausible IMAPish date string */
+     tm = gmtime (&sbuf.st_mtime);
+     elt->day = tm->tm_mday; elt->month = tm->tm_mon + 1;
+     elt->year = tm->tm_year + 1900 - BASEYEAR;
+     elt->hours = tm->tm_hour; elt->minutes = tm->tm_min;
+     elt->seconds = tm->tm_sec;
+     elt->zhours = 0; elt->zminutes = 0;
+ 				/* is buffer big enough? */
+     if (sbuf.st_size > LOCAL->buflen) {
+       fs_give ((void **) &LOCAL->buf);
+       LOCAL->buf = (char *) fs_get ((LOCAL->buflen = sbuf.st_size) + 1);
+     }
+ 				/* slurp message */
+     read (fd,LOCAL->buf,sbuf.st_size);
+ 				/* tie off file */
+     LOCAL->buf[sbuf.st_size] = '\0';
+     close (fd);			/* flush message file */
+ 				/* find end of header */
+     for (i = 0,t = LOCAL->buf; *t && !(i && (*t == '\n')); i = (*t++ == '\n'));
+ 				/* number of header bytes */
+     hdrsize = (*t ? ++t : t) - LOCAL->buf;
+     elt->rfc822_size =		/* size of entire message in CRLF form */
+       (elt->private.msg.header.text.size =
+        strcrlfcpy ((char **) &elt->private.msg.header.text.data,&i,LOCAL->buf,
+ 		   hdrsize)) +
+ 	 (elt->private.msg.text.text.size =
+ 	  strcrlfcpy ((char **) &elt->private.msg.text.text.data,&i,t,
+ 		      sbuf.st_size - hdrsize));
+ 				/* add to cached size */
+     LOCAL->cachedtexts += elt->rfc822_size;
+   }
+   *length = elt->private.msg.header.text.size;
+   return (char *) elt->private.msg.header.text.data;
+ }
+ 
+ /* MH mail fetch message text (body only)
+  * Accepts: MAIL stream
+  *	    message # to fetch
+  *	    pointer to returned stringstruct
+  *	    option flags
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long mh_text (MAILSTREAM *stream,unsigned long msgno,STRING *bs,long flags)
+ {
+   unsigned long i;
+   MESSAGECACHE *elt;
+ 				/* UID call "impossible" */
+   if (flags & FT_UID) return NIL;
+   elt = mail_elt (stream,msgno);/* get elt */
+ 				/* snarf message if don't have it yet */
+   if (!elt->private.msg.text.text.data) {
+     mh_header (stream,msgno,&i,flags);
+     if (!elt->private.msg.text.text.data) return NIL;
+   }
+   if (!(flags & FT_PEEK)) {	/* mark as seen */
+     mail_elt (stream,msgno)->seen = T;
+     mm_flags (stream,msgno);
+   }
+   if (!elt->private.msg.text.text.data) return NIL;
+   INIT (bs,mail_string,elt->private.msg.text.text.data,
+ 	elt->private.msg.text.text.size);
+   return T;
+ }
+ 
+ /* MH mail ping mailbox
+  * Accepts: MAIL stream
+  * Returns: T if stream alive, else NIL
+  */
+ 
+ long mh_ping (MAILSTREAM *stream)
+ {
+   MAILSTREAM *sysibx = NIL;
+   MESSAGECACHE *elt,*selt;
+   struct stat sbuf;
+   char *s,tmp[MAILTMPLEN];
+   int fd;
+   unsigned long i,j,r,old;
+   long nmsgs = stream->nmsgs;
+   long recent = stream->recent;
+   int silent = stream->silent;
+   if (stat (LOCAL->dir,&sbuf)) { /* directory exists? */
+     if (stream->inbox) return T;
+     sprintf (tmp,"Can't open mailbox %.80s: no such mailbox",stream->mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   stream->silent = T;		/* don't pass up mm_exists() events yet */
+   if (sbuf.st_ctime != LOCAL->scantime) {
+     struct direct **names = NIL;
+     long nfiles = scandir (LOCAL->dir,&names,mh_select,mh_numsort);
+     if (nfiles < 0) nfiles = 0;	/* in case error */
+     old = stream->uid_last;
+ 				/* note scanned now */
+     LOCAL->scantime = sbuf.st_ctime;
+ 				/* scan directory */
+     for (i = 0; i < nfiles; ++i) {
+ 				/* if newly seen, add to list */
+       if ((j = atoi (names[i]->d_name)) > old) {
+ 	mail_exists (stream,++nmsgs);
+ 	stream->uid_last = (elt = mail_elt (stream,nmsgs))->private.uid = j;
+ 	elt->valid = T;		/* note valid flags */
+ 	if (old) {		/* other than the first pass? */
+ 	  elt->recent = T;	/* yup, mark as recent */
+ 	  recent++;		/* bump recent count */
+ 	}
+ 	else {			/* see if already read */
+ 	  sprintf (tmp,"%s/%s",LOCAL->dir,names[i]->d_name);
+ 	  stat (tmp,&sbuf);	/* get inode poop */
+ 	  if (sbuf.st_atime > sbuf.st_mtime) elt->seen = T;
+ 	}
+       }
+       fs_give ((void **) &names[i]);
+     }
+ 				/* free directory */
+     if (s = (void *) names) fs_give ((void **) &s);
+   }
+ 
+ 				/* if INBOX, snarf from system INBOX  */
+   if (stream->inbox && strcmp (sysinbox (),stream->mailbox)) {
+     old = stream->uid_last;
+     mm_critical (stream);	/* go critical */
+     stat (sysinbox (),&sbuf);	/* see if anything there */
+ 				/* can get sysinbox mailbox? */
+     if (sbuf.st_size && (sysibx = mail_open (sysibx,sysinbox (),OP_SILENT))
+ 	&& (!sysibx->rdonly) && (r = sysibx->nmsgs)) {
+       for (i = 1; i <= r; ++i) {/* for each message in sysinbox mailbox */
+ 				/* build file name we will use */
+ 	sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,++old);
+ 				/* snarf message from Berkeley mailbox */
+ 	selt = mail_elt (sysibx,i);
+ 	if (((fd = open (LOCAL->buf,O_WRONLY|O_CREAT|O_EXCL,
+ 			 S_IREAD|S_IWRITE)) >= 0) &&
+ 	    (s = mail_fetchheader_full (sysibx,i,NIL,&j,FT_INTERNAL)) &&
+ 	    (write (fd,s,j) == j) &&
+ 	    (s = mail_fetchtext_full (sysibx,i,&j,FT_INTERNAL|FT_PEEK)) &&
+ 	    (write (fd,s,j) == j) && !fsync (fd) && !close (fd)) {
+ 				/* swell the cache */
+ 	  mail_exists (stream,++nmsgs);
+ 	  stream->uid_last =	/* create new elt, note its file number */
+ 	    (elt = mail_elt (stream,nmsgs))->private.uid = old;
+ 	  recent++;		/* bump recent count */
+ 				/* set up initial flags and date */
+ 	  elt->valid = elt->recent = T;
+ 	  elt->seen = selt->seen;
+ 	  elt->deleted = selt->deleted;
+ 	  elt->flagged = selt->flagged;
+ 	  elt->answered = selt->answered;
+ 	  elt->draft = selt->draft;
+ 	  elt->day = selt->day;elt->month = selt->month;elt->year = selt->year;
+ 	  elt->hours = selt->hours;elt->minutes = selt->minutes;
+ 	  elt->seconds = selt->seconds;
+ 	  elt->zhours = selt->zhours; elt->zminutes = selt->zminutes;
+ 	  mh_setdate (LOCAL->buf,elt);
+ 	}
+ 
+ 	else {			/* failed to snarf */
+ 	  if (fd) {		/* did it ever get opened? */
+ 	    mm_log ("Message copy to MH mailbox failed",ERROR);
+ 	    close (fd);		/* close descriptor */
+ 	    unlink (LOCAL->buf);/* flush this file */
+ 	  }
+ 	  else {
+ 	    sprintf (tmp,"Can't add message: %s",strerror (errno));
+ 	    mm_log (tmp,ERROR);
+ 	  }
+ 	  stream->silent = silent;
+ 	  return NIL;		/* note that something is badly wrong */
+ 	}
+ 	sprintf (tmp,"%lu",i);	/* delete it from the sysinbox */
+ 	mail_flag (sysibx,tmp,"\\Deleted",ST_SET);
+       }
+       stat (LOCAL->dir,&sbuf);	/* update scan time */
+       LOCAL->scantime = sbuf.st_ctime;      
+       mail_expunge (sysibx);	/* now expunge all those messages */
+     }
+     if (sysibx) mail_close (sysibx);
+     mm_nocritical (stream);	/* release critical */
+   }
+   stream->silent = silent;	/* can pass up events now */
+   mail_exists (stream,nmsgs);	/* notify upper level of mailbox size */
+   mail_recent (stream,recent);
+   return T;			/* return that we are alive */
+ }
+ 
+ /* MH mail check mailbox
+  * Accepts: MAIL stream
+  */
+ 
+ void mh_check (MAILSTREAM *stream)
+ {
+   /* Perhaps in the future this will preserve flags */
+   if (mh_ping (stream)) mm_log ("Check completed",(long) NIL);
+ }
+ 
+ 
+ /* MH mail expunge mailbox
+  * Accepts: MAIL stream
+  */
+ 
+ void mh_expunge (MAILSTREAM *stream)
+ {
+   MESSAGECACHE *elt;
+   unsigned long i = 1;
+   unsigned long n = 0;
+   unsigned long recent = stream->recent;
+   mm_critical (stream);		/* go critical */
+   while (i <= stream->nmsgs) {	/* for each message */
+ 				/* if deleted, need to trash it */
+     if ((elt = mail_elt (stream,i))->deleted) {
+       sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->private.uid);
+       if (unlink (LOCAL->buf)) {/* try to delete the message */
+ 	sprintf (LOCAL->buf,"Expunge of message %lu failed, aborted: %s",i,
+ 		 strerror (errno));
+ 	mm_log (LOCAL->buf,(long) NIL);
+ 	break;
+       }
+ 				/* note uncached */
+       LOCAL->cachedtexts -= ((elt->private.msg.header.text.data ?
+ 			      elt->private.msg.header.text.size : 0) +
+ 			     (elt->private.msg.text.text.data ?
+ 			      elt->private.msg.text.text.size : 0));
+       mail_gc_msg (&elt->private.msg,GC_ENV | GC_TEXTS);
+       if (elt->recent) --recent;/* if recent, note one less recent message */
+       mail_expunged (stream,i);	/* notify upper levels */
+       n++;			/* count up one more expunged message */
+     }
+     else i++;			/* otherwise try next message */
+   }
+   if (n) {			/* output the news if any expunged */
+     sprintf (LOCAL->buf,"Expunged %lu messages",n);
+     mm_log (LOCAL->buf,(long) NIL);
+   }
+   else mm_log ("No messages deleted, so no update needed",(long) NIL);
+   mm_nocritical (stream);	/* release critical */
+ 				/* notify upper level of new mailbox size */
+   mail_exists (stream,stream->nmsgs);
+   mail_recent (stream,recent);
+ }
+ 
+ /* MH mail copy message(s)
+  * Accepts: MAIL stream
+  *	    sequence
+  *	    destination mailbox
+  *	    copy options
+  * Returns: T if copy successful, else NIL
+  */
+ 
+ long mh_copy (MAILSTREAM *stream,char *sequence,char *mailbox,long options)
+ {
+   STRING st;
+   MESSAGECACHE *elt;
+   struct stat sbuf;
+   int fd;
+   unsigned long i;
+   char flags[MAILTMPLEN],date[MAILTMPLEN];
+ 				/* copy the messages */
+   if ((options & CP_UID) ? mail_uid_sequence (stream,sequence) :
+       mail_sequence (stream,sequence))
+     for (i = 1; i <= stream->nmsgs; i++) 
+       if ((elt = mail_elt (stream,i))->sequence) {
+ 	sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->private.uid);
+ 	if ((fd = open (LOCAL->buf,O_RDONLY,NIL)) < 0) return NIL;
+ 	fstat (fd,&sbuf);	/* get size of message */
+ 	if (!elt->day) {	/* make plausible IMAPish date string */
+ 	  struct tm *tm = gmtime (&sbuf.st_mtime);
+ 	  elt->day = tm->tm_mday; elt->month = tm->tm_mon + 1;
+ 	  elt->year = tm->tm_year + 1900 - BASEYEAR;
+ 	  elt->hours = tm->tm_hour; elt->minutes = tm->tm_min;
+ 	  elt->seconds = tm->tm_sec;
+ 	  elt->zhours = 0; elt->zminutes = 0;
+ 	}
+ 				/* is buffer big enough? */
+ 	if (sbuf.st_size > LOCAL->buflen) {
+ 	  fs_give ((void **) &LOCAL->buf);
+ 	  LOCAL->buf = (char *) fs_get ((LOCAL->buflen = sbuf.st_size) + 1);
+ 	}
+ 				/* slurp message */
+ 	read (fd,LOCAL->buf,sbuf.st_size);
+ 				/* tie off file */
+ 	LOCAL->buf[sbuf.st_size] = '\0';
+ 	close (fd);		/* flush message file */
+ 	INIT (&st,mail_string,(void *) LOCAL->buf,sbuf.st_size);
+ 				/* init flag string */
+ 	flags[0] = flags[1] = '\0';
+ 	if (elt->seen) strcat (flags," \\Seen");
+ 	if (elt->deleted) strcat (flags," \\Deleted");
+ 	if (elt->flagged) strcat (flags," \\Flagged");
+ 	if (elt->answered) strcat (flags," \\Answered");
+ 	if (elt->draft) strcat (flags," \\Draft");
+ 	flags[0] = '(';		/* open list */
+ 	strcat (flags,")");	/* close list */
+ 	mail_date (date,elt);	/* generate internal date */
+ 	if (!mail_append_full (NIL,mailbox,flags,date,&st)) return NIL;
+ 	if (options & CP_MOVE) elt->deleted = T;
+       }
+   return T;			/* return success */
+ }
+ 
+ /* MH mail append message from stringstruct
+  * Accepts: MAIL stream
+  *	    destination mailbox
+  *	    stringstruct of messages to append
+  * Returns: T if append successful, else NIL
+  */
+ 
+ long mh_append (MAILSTREAM *stream,char *mailbox,char *flags,char *date,
+ 		STRING *message)
+ {
+   struct direct **names;
+   int fd;
+   char c,*s,tmp[MAILTMPLEN];
+   MESSAGECACHE elt;
+   long i,last,nfiles;
+   long size = 0;
+   long ret = LONGT;
+   unsigned long uf;
+   /* short f = */ mail_parse_flags (stream ? stream : &mhproto,flags,&uf);
+   if (date) {			/* want to preserve date? */
+ 				/* yes, parse date into an elt */
+     if (!mail_parse_date (&elt,date)) {
+       sprintf (tmp,"Bad date in append: %.80s",date);
+       mm_log (tmp,ERROR);
+       return NIL;
+     }
+   }
+ 				/* N.B.: can't use LOCAL->buf for tmp */
+ 				/* make sure valid mailbox */
+   if (!mh_isvalid (mailbox,tmp,NIL)) switch (errno) {
+   case ENOENT:			/* no such file? */
+     if ((mailbox[0] == '#') && ((mailbox[1] == 'M') || (mailbox[1] == 'm')) &&
+ 	((mailbox[2] == 'H') || (mailbox[2] == 'h')) &&
+ 	((mailbox[3] == 'I') || (mailbox[3] == 'i')) &&
+ 	((mailbox[4] == 'N') || (mailbox[4] == 'n')) &&
+ 	((mailbox[5] == 'B') || (mailbox[5] == 'b')) &&
+ 	((mailbox[6] == 'O') || (mailbox[6] == 'o')) &&
+ 	((mailbox[7] == 'X') || (mailbox[7] == 'x')) && !mailbox[8])
+       mh_create (NIL,"INBOX");
+     else {
+       mm_notify (stream,"[TRYCREATE] Must create mailbox before append",NIL);
+       return NIL;
+     }
+ 				/* falls through */
+   case 0:			/* merely empty file? */
+     break;
+   case EINVAL:
+     sprintf (tmp,"Invalid MH-format mailbox name: %.80s",mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   default:
+     sprintf (tmp,"Not a MH-format mailbox: %.80s",mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   mh_file (tmp,mailbox);	/* build file name we will use */
+   if ((nfiles = scandir (tmp,&names,mh_select,mh_numsort)) > 0) {
+ 				/* largest number */
+     last = atoi (names[nfiles-1]->d_name);    
+     for (i = 0; i < nfiles; ++i) /* free directory */
+       fs_give ((void **) &names[i]);
+   }
+   else last = 0;		/* no messages here yet */
+   if (s = (void *) names) fs_give ((void **) &s);
+ 
+   sprintf (tmp + strlen (tmp),"/%ld",++last);
+   if ((fd = open (tmp,O_WRONLY|O_CREAT|O_EXCL,S_IREAD|S_IWRITE)) < 0) {
+     sprintf (tmp,"Can't open append message: %s",strerror (errno));
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   i = SIZE (message);		/* get size of message */
+   s = (char *) fs_get (i + 1);	/* get space for the data */
+ 				/* copy the data w/o CR's */
+   while (i--) if ((c = SNX (message)) != '\015') s[size++] = c;
+   mm_critical (stream);		/* go critical */
+ 				/* write the data */
+   if ((write (fd,s,size) < 0) || fsync (fd)) {
+     unlink (tmp);		/* delete message */
+     sprintf (tmp,"Message append failed: %s",strerror (errno));
+     mm_log (tmp,ERROR);
+     ret = NIL;
+   }
+   close (fd);			/* close the file */
+ 				/* set the date for this message */
+   if (date) mh_setdate (tmp,&elt);
+ 
+   mm_nocritical (stream);	/* release critical */
+   fs_give ((void **) &s);	/* flush the buffer */
+   return ret;
+ }
+ 
+ /* Internal routines */
+ 
+ 
+ /* MH file name selection test
+  * Accepts: candidate directory entry
+  * Returns: T to use file name, NIL to skip it
+  */
+ 
+ int mh_select (struct direct *name)
+ {
+   char c;
+   char *s = name->d_name;
+   while (c = *s++) if (!isdigit (c)) return NIL;
+   return T;
+ }
+ 
+ 
+ /* MH file name comparision
+  * Accepts: first candidate directory entry
+  *	    second candidate directory entry
+  * Returns: negative if d1 < d2, 0 if d1 == d2, postive if d1 > d2
+  */
+ 
+ int mh_numsort (const void *d1,const void *d2)
+ {
+   return atoi ((*(struct direct **) d1)->d_name) -
+     atoi ((*(struct direct **) d2)->d_name);
+ }
+ 
+ 
+ /* MH mail build file name
+  * Accepts: destination string
+  *          source
+  * Returns: destination
+  */
+ 
+ char *mh_file (char *dst,char *name)
+ {
+   char *s,tmp[MAILTMPLEN];
+ 				/* build composite name */
+   sprintf (dst,"%s/%.900s",mh_path,
+ 	   strcmp (ucase (strcpy (tmp,name)),"#MHINBOX") ? name + 4 : "inbox");
+ 				/* tie off unnecessary trailing / */
+   if ((s = strrchr (dst,'/')) && !s[1] && (s[-1] == '/')) *s = '\0';
+   return dst;
+ }
+ 
+ 
+ /* MH canonicalize name
+  * Accepts: buffer to write name
+  *	    reference
+  *	    pattern
+  * Returns: T if success, NIL if failure
+  */
+ 
+ long mh_canonicalize (char *pattern,char *ref,char *pat)
+ {
+   char tmp[MAILTMPLEN];
+   if (ref && *ref) {		/* have a reference */
+     strcpy (pattern,ref);	/* copy reference to pattern */
+ 				/* # overrides mailbox field in reference */
+     if (*pat == '#') strcpy (pattern,pat);
+ 				/* pattern starts, reference ends, with / */
+     else if ((*pat == '/') && (pattern[strlen (pattern) - 1] == '/'))
+       strcat (pattern,pat + 1);	/* append, omitting one of the period */
+     else strcat (pattern,pat);	/* anything else is just appended */
+   }
+   else strcpy (pattern,pat);	/* just have basic name */
+   return (mh_isvalid (pattern,tmp,T));
+ }
+ 
+ /* Set date for message
+  * Accepts: file name
+  *	    elt containing date
+  */
+ 
+ void mh_setdate (char *file,MESSAGECACHE *elt)
+ {
+   time_t tp[2];
+   tp[0] = time (0);		/* atime is now */
+   tp[1] = mail_longdate (elt);	/* modification time */
+   utime (file,tp);		/* set the times */
+ }
Binary files c-client.pure/mh.o and c-client/mh.o differ
diff -c -N c-client.pure/mhnt.c c-client/mhnt.c
*** c-client.pure/mhnt.c	Thu Jan  1 01:00:00 1970
--- c-client/mhnt.c	Sat Feb  5 14:44:03 2000
***************
*** 0 ****
--- 1,1038 ----
+ /*
+  * Program:	MH mail routines
+  *
+  * Author(s):	Mark Crispin
+  *		Networks and Distributed Computing
+  *		Computing & Communications
+  *		University of Washington
+  *		Administration Building, AG-44
+  *		Seattle, WA  98195
+  *		Internet: MRC@CAC.Washington.EDU
+  *
+  * Modified by: Vadim Zeitlin
+  *		adopted mh.c for Win32
+  *
+  * Date:	23 February 1992
+  * Last Edited:	27 July 1999
+  *
+  * Copyright 1998 by the University of Washington
+  *
+  *  Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notice appears in all copies and that both the
+  * above copyright notice and this permission notice appear in supporting
+  * documentation, and that the name of the University of Washington not be
+  * used in advertising or publicity pertaining to distribution of the software
+  * without specific, written prior permission.  This software is made
+  * available "as is", and
+  * THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+  * WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+  * NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+  * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+  * (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+  * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  */
+ 
+ #include <stdio.h>
+ #include <ctype.h>
+ #include <errno.h>
+ extern int errno;		/* just in case */
+ #include "mail.h"
+ #include "osdep.h"
+ #include <sys/stat.h>
+ #include "mhnt.h"
+ #include "misc.h"
+ #include "dummy.h"
+ 
+ #include <fcntl.h>      /* _O_RDONLY and friends */
+ #include <direct.h>     /* _rmdir                */
+ #include <sys/utime.h>  /* for _utime (doh)      */
+ 
+ 
+ /* MH mail routines */
+ 
+ 
+ /* Driver dispatch used by MAIL */
+ 
+ DRIVER mhdriver = {
+   "mh",				/* driver name */
+ 				/* driver flags */
+   DR_MAIL|DR_LOCAL|DR_NOFAST|DR_NAMESPACE|DR_NOSTICKY,
+   (DRIVER *) NIL,		/* next driver */
+   mh_valid,			/* mailbox is valid for us */
+   mh_parameters,		/* manipulate parameters */
+   mh_scan,			/* scan mailboxes */
+   mh_list,			/* find mailboxes */
+   mh_lsub,			/* find subscribed mailboxes */
+   mh_subscribe,			/* subscribe to mailbox */
+   mh_unsubscribe,		/* unsubscribe from mailbox */
+   mh_create,			/* create mailbox */
+   mh_delete,			/* delete mailbox */
+   mh_rename,			/* rename mailbox */
+   NIL,				/* status of mailbox */
+   mh_open,			/* open mailbox */
+   mh_close,			/* close mailbox */
+   mh_fast,			/* fetch message "fast" attributes */
+   NIL,				/* fetch message flags */
+   NIL,				/* fetch overview */
+   NIL,				/* fetch message envelopes */
+   mh_header,			/* fetch message header */
+   mh_text,			/* fetch message body */
+   NIL,				/* fetch partial message text */
+   NIL,				/* unique identifier */
+   NIL,				/* message number */
+   NIL,				/* modify flags */
+   NIL,				/* per-message modify flags */
+   NIL,				/* search for message based on criteria */
+   NIL,				/* sort messages */
+   NIL,				/* thread messages */
+   mh_ping,			/* ping mailbox to see if still alive */
+   mh_check,			/* check for new messages */
+   mh_expunge,			/* expunge deleted messages */
+   mh_copy,			/* copy messages to another mailbox */
+   mh_append,			/* append string message to mailbox */
+   NIL				/* garbage collect stream */
+ };
+ 
+ 				/* prototype stream */
+ MAILSTREAM mhproto = {&mhdriver};
+ 
+ 
+ /* MH mail validate mailbox
+  * Accepts: mailbox name
+  * Returns: our driver if name is valid, NIL otherwise
+  */
+ 
+ DRIVER *mh_valid (char *name)
+ {
+   char tmp[MAILTMPLEN];
+   return mh_isvalid (name,tmp,T) ? &mhdriver : NIL;
+ }
+ 
+ /* MH mail test for valid mailbox
+  * Accepts: mailbox name
+  *	    temporary buffer to use
+  *	    syntax only test flag
+  * Returns: T if valid, NIL otherwise
+  */
+ 
+ static char *mh_profile = NIL;	/* holds MH profile */
+ static char *mh_path = NIL;	/* holds MH path name */
+ static long mh_once = 0;	/* already through this code */
+ 
+ int mh_isvalid (char *name,char *tmp,long synonly)
+ {
+   struct stat sbuf;
+ 				/* name must be #MHINBOX or #mh/... */
+   if (strcmp (ucase (strcpy (tmp,name)),"#MHINBOX") &&
+       !(tmp[0] == '#' && tmp[1] == 'M' && tmp[2] == 'H' && tmp[3] == '/')) {
+     errno = EINVAL;		/* bogus name */
+     return NIL;
+   }
+   if (!mh_path) {		/* have MH path yet? */
+     char *s,*t,*v;
+     int fd;
+     if (mh_once++) return NIL;	/* only do this code once */
+     if (!mh_profile) {		/* have MH profile? */
+       sprintf (tmp,"%s/%s",myhomedir (),MHPROFILE);
+       mh_profile = cpystr (tmp);
+     }
+     if ((fd = open (tmp,_O_RDONLY,NIL)) < 0) {
+       strcat (tmp," not found, mh format names disabled");
+       mm_log (tmp,WARN);
+       return NIL;
+     }
+     fstat (fd,&sbuf);		/* yes, get size and read file */
+     read (fd,(t = (char *) fs_get (sbuf.st_size + 1)),sbuf.st_size);
+     close (fd);			/* don't need the file any more */
+     t[sbuf.st_size] = '\0';	/* tie it off */
+ 				/* parse profile file */
+     for (s = strtok (t,"\r\n"); s && *s; s = strtok (NIL,"\r\n")) {
+ 				/* found space in line? */
+       if (v = strpbrk (s," \t")) {
+ 	*v++ = '\0';		/* tie off, is keyword "Path:"? */
+ 	if (!strcmp (lcase (s),"path:")) {
+ 				/* skip whitespace */
+ 	  while ((*v == ' ') || (*v == '\t')) ++v;
+ 	  if (*v == '/') s = v;	/* absolute path? */
+ 	  else sprintf (s = tmp,"%s/%s",myhomedir (),v);
+ 	  mh_path = cpystr (s);	/* copy name */
+ 	  break;		/* don't need to look at rest of file */
+ 	}
+       }
+     }
+     fs_give ((void **) &t);	/* flush profile text */
+     if (!mh_path) {		/* default path if not in the profile */
+       sprintf (tmp,"%s/%s",myhomedir (),MHPATH);
+       mh_path = cpystr (tmp);
+     }
+   }
+   if (synonly) return T;	/* all done if syntax only check */
+   errno = NIL;			/* zap error */
+ 				/* validate name as directory */
+   return ((stat (mh_file (tmp,name),&sbuf) == 0) &&
+ 	  (sbuf.st_mode & S_IFMT) == S_IFDIR);
+ }
+ 
+ /* MH manipulate driver parameters
+  * Accepts: function code
+  *	    function-dependent value
+  * Returns: function-dependent return value
+  */
+ 
+ void *mh_parameters (long function,void *value)
+ {
+   switch ((int) function) {
+   case SET_MHPROFILE:
+     if (mh_profile) fs_give ((void **) &mh_profile);
+     mh_profile = cpystr ((char *) value);
+     break;
+   case GET_MHPROFILE:
+     value = (void *) mh_profile;
+     break;
+   case SET_MHPATH:
+     if (mh_path) fs_give ((void **) &mh_path);
+     mh_path = cpystr ((char *) value);
+     break;
+   case GET_MHPATH:
+     value = (void *) mh_path;
+     break;
+   default:
+     value = NIL;		/* error case */
+     break;
+   }
+   return NIL;
+ }
+ 
+ /* MH scan mailboxes
+  * Accepts: mail stream
+  *	    reference
+  *	    pattern to search
+  *	    string to scan
+  */
+ 
+ void mh_scan (MAILSTREAM *stream,char *ref,char *pat,char *contents)
+ {
+   char tmp[MAILTMPLEN];
+   if (mh_canonicalize (tmp,ref,pat))
+     mm_log ("Scan not valid for mh mailboxes",ERROR);
+ }
+ 
+ 
+ /* MH list mailboxes
+  * Accepts: mail stream
+  *	    reference
+  *	    pattern to search
+  */
+ 
+ void mh_list (MAILSTREAM *stream,char *ref,char *pat)
+ {
+   char *s,test[MAILTMPLEN],file[MAILTMPLEN];
+   long i = 0;
+   if (!pat || !*pat) {		/* empty pattern? */
+     if (mh_canonicalize (test,ref,"*")) {
+ 				/* tie off name at root */
+       if (s = strchr (test,'/')) *++s = '\0';
+       else test[0] = '\0';
+       mm_list (stream,'/',test,LATT_NOSELECT);
+     }
+   }
+ 				/* get canonical form of name */
+   else if (mh_canonicalize (test,ref,pat)) {
+     if (test[3] == '/') {	/* looking down levels? */
+ 				/* yes, found any wildcards? */
+       if (s = strpbrk (test,"%*")) {
+ 				/* yes, copy name up to that point */
+ 	strncpy (file,test+4,i = s - (test+4));
+ 	file[i] = '\0';		/* tie off */
+       }
+       else strcpy (file,test+4);/* use just that name then */
+ 				/* find directory name */
+       if (s = strrchr (file,'/')) {
+ 	*s = '\0';		/* found, tie off at that point */
+ 	s = file;
+       }
+ 				/* do the work */
+       mh_list_work (stream,s,test,0);
+     }
+ 				/* always an INBOX */
+     if (pmatch ("#MHINBOX",ucase (test)))
+       mm_list (stream,NIL,"#MHINBOX",LATT_NOINFERIORS);
+   }
+ }
+ 
+ /* MH list subscribed mailboxes
+  * Accepts: mail stream
+  *	    reference
+  *	    pattern to search
+  */
+ 
+ void mh_lsub (MAILSTREAM *stream,char *ref,char *pat)
+ {
+   void *sdb = NIL;
+   char *s,test[MAILTMPLEN];
+ 				/* get canonical form of name */
+   if (mh_canonicalize (test,ref,pat) && (s = sm_read (&sdb))) {
+     do if (pmatch_full (s,test,'/')) mm_lsub (stream,'/',s,NIL);
+     while (s = sm_read (&sdb)); /* until no more subscriptions */
+   }
+ }
+ 
+ /* MH list mailboxes worker routine
+  * Accepts: mail stream
+  *	    directory name to search
+  *	    search pattern
+  *	    search level
+  */
+ 
+ void mh_list_work (MAILSTREAM *stream,char *dir,char *pat,long level)
+ {
+   long hDir;
+   struct _finddata_t fileinfo;
+   char *cp,*np,curdir[MAILTMPLEN],name[MAILTMPLEN], *filemask;
+ 				/* build MH name to search */
+   if (dir) sprintf (name,"#mh/%s/",dir);
+   else strcpy (name,"#mh/");
+ 				/* make directory name, punt if bogus */
+   if (!mh_file (curdir,name)) return;
+   cp = curdir + strlen (curdir);/* end of directory name */
+   np = name + strlen (name);	/* end of MH name */
+   filemask = (char *)fs_get((strlen(curdir) + 5) * sizeof(char));
+   strcpy(filemask, curdir);
+   strcat(filemask, "/*.*");
+   hDir = _findfirst(filemask, &fileinfo);/* open directory */
+   fs_give((void **)&filemask);
+   if (hDir != -1) {
+     do				/* scan directory */
+       if (fileinfo.name[0] != '.') {/* build file name */
+ 	strcpy (cp,fileinfo.name);  /* make directory name */
+ 	if (fileinfo.attrib & _A_SUBDIR) {
+ 	  strcpy (np,fileinfo.name);/* make mh name of directory name */
+ 				/* yes, an MH name if full match */
+ 	  if (pmatch_full (name,pat,'/')) mm_list (stream,'/',name,NIL);
+ 				/* check if should recurse */
+ 	  if (dmatch (name,pat,'/') &&
+ 	      (level < (long) mail_parameters (NIL,GET_LISTMAXLEVEL,NIL)))
+ 	    mh_list_work (stream,name+4,pat,level+1);
+ 	}
+       }
+     while (_findnext(hDir, &fileinfo) == 0);
+     _findclose (hDir);		/* all done, flush directory */
+   }
+ }
+ 
+ /* MH mail subscribe to mailbox
+  * Accepts: mail stream
+  *	    mailbox to add to subscription list
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long mh_subscribe (MAILSTREAM *stream,char *mailbox)
+ {
+   return sm_subscribe (mailbox);
+ }
+ 
+ 
+ /* MH mail unsubscribe to mailbox
+  * Accepts: mail stream
+  *	    mailbox to delete from subscription list
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long mh_unsubscribe (MAILSTREAM *stream,char *mailbox)
+ {
+   return sm_unsubscribe (mailbox);
+ }
+ 
+ /* MH mail create mailbox
+  * Accepts: mail stream
+  *	    mailbox name to create
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long mh_create (MAILSTREAM *stream,char *mailbox)
+ {
+   char tmp[MAILTMPLEN];
+   if (!(mailbox[0] == '#' && (mailbox[1] == 'm' || mailbox[1] == 'M') &&
+ 	(mailbox[2] == 'h' || mailbox[2] == 'H') && mailbox[3] == '/')) {
+     sprintf (tmp,"Can't create mailbox %.80s: invalid MH-format name",mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+ 				/* must not already exist */
+   if (mh_isvalid (mailbox,tmp,NIL)) {
+     sprintf (tmp,"Can't create mailbox %.80s: mailbox already exists",mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   if (!mh_path) return NIL;	/* sorry */
+   sprintf (tmp,"%s/%.900s/",mh_path,mailbox + 4);
+ 				/* try to make it */
+   if (!dummy_create_path (stream,tmp)) {
+     sprintf (tmp,"Can't create mailbox %.80s: %s",mailbox,strerror (errno));
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   return T;			/* return success */
+ }
+ 
+ /* MH mail delete mailbox
+  *	    mailbox name to delete
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long mh_delete (MAILSTREAM *stream,char *mailbox)
+ {
+   long hDir;
+   struct _finddata_t fileinfo;
+   int i;
+   char tmp[MAILTMPLEN], *filemask;
+   if (!(mailbox[0] == '#' && (mailbox[1] == 'm' || mailbox[1] == 'M') &&
+ 	(mailbox[2] == 'h' || mailbox[2] == 'H') && mailbox[3] == '/')) {
+     sprintf (tmp,"Can't delete mailbox %.80s: invalid MH-format name",mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+ 				/* is mailbox valid? */
+   if (!mh_isvalid (mailbox,tmp,NIL)){
+     sprintf (tmp,"Can't delete mailbox %.80s: no such mailbox",mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+ 				/* get name of directory */
+   i = strlen (mh_file (tmp,mailbox));
+   filemask = (char *)fs_get((strlen(tmp) + 5) * sizeof(char));
+   strcpy(filemask, tmp);
+   strcat(filemask, "/*.*");
+   hDir = _findfirst(filemask, &fileinfo);/* open directory */
+   fs_give((void **)&filemask);
+   if (hDir != -1) {
+     tmp[i++] = '/';		/* now apply trailing delimiter */
+     do
+       if (mh_select (&fileinfo) || (*fileinfo.name == ',') ||
+ 	  !strcmp (fileinfo.name,MHSEQUENCE)) {
+ 	strcpy (tmp + i,fileinfo.name);
+ 	unlink (tmp);		/* sayonara */
+       }
+     while (_findnext(hDir, &fileinfo) == 0);
+     _findclose (hDir);		/* all done, flush directory */
+   }
+ 				/* try to remove the directory */
+   if (_rmdir (mh_file (tmp,mailbox))) {
+     sprintf (tmp,"Can't delete mailbox %.80s: %s",mailbox,strerror (errno));
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   return T;			/* return success */
+ }
+ 
+ /* MH mail rename mailbox
+  * Accepts: MH mail stream
+  *	    old mailbox name
+  *	    new mailbox name
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long mh_rename (MAILSTREAM *stream,char *old,char *newname)
+ {
+   char c,*s,tmp[MAILTMPLEN],tmp1[MAILTMPLEN];
+   struct stat sbuf;
+   if (!(old[0] == '#' && (old[1] == 'm' || old[1] == 'M') &&
+ 	(old[2] == 'h' || old[2] == 'H') && old[3] == '/'))
+     sprintf (tmp,"Can't delete mailbox %.80s: invalid MH-format name",old);
+ 				/* old mailbox name must be valid */
+   else if (!mh_isvalid (old,tmp,NIL))
+     sprintf (tmp,"Can't rename mailbox %.80s: no such mailbox",old);
+   else if (!(newname[0] == '#' && (newname[1] == 'm' || newname[1] == 'M') &&
+ 	(newname[2] == 'h' || newname[2] == 'H') && newname[3] == '/'))
+     sprintf (tmp,"Can't rename to mailbox %.80s: invalid MH-format name",
+ 	     newname);
+ 				/* new mailbox name must not be valid */
+   else if (mh_isvalid (newname,tmp,NIL))
+     sprintf (tmp,"Can't rename to mailbox %.80s: destination already exists",
+ 	     newname);
+ 				/* success if can rename the directory */
+   else {			/* found superior to destination name? */
+     if (s = strrchr (mh_file (tmp1,newname),'/')) {
+       c = *++s;			/* remember first character of inferior */
+       *s = '\0';		/* tie off to get just superior */
+ 				/* name doesn't exist, create it */
+       if ((stat (tmp1,&sbuf) || ((sbuf.st_mode & S_IFMT) != S_IFDIR)) &&
+ 	  !dummy_create (stream,tmp1)) return NIL;
+       *s = c;			/* restore full name */
+     }
+     if (!rename (mh_file (tmp,old),tmp1)) return T;
+     sprintf (tmp,"Can't rename mailbox %.80s to %.80s: %s",
+ 	     old,newname,strerror (errno));
+   }
+   mm_log (tmp,ERROR);		/* something failed */
+   return NIL;
+ }
+ 
+ /* MH mail open
+  * Accepts: stream to open
+  * Returns: stream on success, NIL on failure
+  */
+ 
+ MAILSTREAM *mh_open (MAILSTREAM *stream)
+ {
+   char tmp[MAILTMPLEN];
+   if (!stream) return &mhproto;	/* return prototype for OP_PROTOTYPE call */
+   if (stream->local) fatal ("mh recycle stream");
+   stream->local = fs_get (sizeof (MHLOCAL));
+ 				/* note if an INBOX or not */
+   LOCAL->inbox = !strcmp (ucase (strcpy (tmp,stream->mailbox)),"#MHINBOX");
+   mh_file (tmp,stream->mailbox);/* get directory name */
+   LOCAL->dir = cpystr (tmp);	/* copy directory name for later */
+ 				/* make temporary buffer */
+   LOCAL->buf = (char *) fs_get ((LOCAL->buflen = MAXMESSAGESIZE) + 1);
+   LOCAL->scantime = 0;		/* not scanned yet */
+   stream->sequence++;		/* bump sequence number */
+ 				/* parse mailbox */
+   stream->nmsgs = stream->recent = 0;
+   if (!mh_ping (stream)) return NIL;
+   if (!(stream->nmsgs || stream->silent))
+     mm_log ("Mailbox is empty",(long) NIL);
+   return stream;		/* return stream to caller */
+ }
+ 
+ /* MH mail close
+  * Accepts: MAIL stream
+  *	    close options
+  */
+ 
+ void mh_close (MAILSTREAM *stream,long options)
+ {
+   if (LOCAL) {			/* only if a file is open */
+     int silent = stream->silent;
+     stream->silent = T;		/* note this stream is dying */
+     if (options & CL_EXPUNGE) mh_expunge (stream);
+     if (LOCAL->dir) fs_give ((void **) &LOCAL->dir);
+ 				/* free local scratch buffer */
+     if (LOCAL->buf) fs_give ((void **) &LOCAL->buf);
+ 				/* nuke the local data */
+     fs_give ((void **) &stream->local);
+     stream->dtb = NIL;		/* log out the DTB */
+     stream->silent = silent;	/* reset silent state */
+   }
+ }
+ 
+ 
+ /* MH mail fetch fast information
+  * Accepts: MAIL stream
+  *	    sequence
+  *	    option flags
+  */
+ 
+ void mh_fast (MAILSTREAM *stream,char *sequence,long flags)
+ {
+   unsigned long i,j;
+ 				/* ugly and slow */
+   if (stream && LOCAL && ((flags & FT_UID) ?
+ 			  mail_uid_sequence (stream,sequence) :
+ 			  mail_sequence (stream,sequence)))
+     for (i = 1; i <= stream->nmsgs; i++)
+       if (mail_elt (stream,i)->sequence) mh_header (stream,i,&j,NIL);
+ }
+ 
+ /* MH mail fetch message header
+  * Accepts: MAIL stream
+  *	    message # to fetch
+  *	    pointer to returned header text length
+  *	    option flags
+  * Returns: message header in RFC822 format
+  */
+ 
+ char *mh_header (MAILSTREAM *stream,unsigned long msgno,unsigned long *length,
+ 		 long flags)
+ {
+   unsigned long i,hdrsize;
+   int fd;
+   char *t;
+   struct stat sbuf;
+   struct tm *tm;
+   MESSAGECACHE *elt;
+   *length = 0;			/* default to empty */
+   if (flags & FT_UID) return "";/* UID call "impossible" */
+   elt = mail_elt (stream,msgno);/* get elt */
+   if (!elt->ccprivate.msg.header.text.data) {
+ 				/* build message file name */
+     sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->ccprivate.uid);
+     if ((fd = open (LOCAL->buf,_O_RDONLY,NIL)) < 0) return "";
+     fstat (fd,&sbuf);		/* get size of message */
+ 				/* make plausible IMAPish date string */
+     tm = gmtime (&sbuf.st_mtime);
+     elt->day = tm->tm_mday; elt->month = tm->tm_mon + 1;
+     elt->year = tm->tm_year + 1900 - BASEYEAR;
+     elt->hours = tm->tm_hour; elt->minutes = tm->tm_min;
+     elt->seconds = tm->tm_sec;
+     elt->zhours = 0; elt->zminutes = 0;
+ 				/* is buffer big enough? */
+     if (sbuf.st_size > (long)LOCAL->buflen) {
+       fs_give ((void **) &LOCAL->buf);
+       LOCAL->buf = (char *) fs_get ((LOCAL->buflen = sbuf.st_size) + 1);
+     }
+ 				/* slurp message */
+     read (fd,LOCAL->buf,sbuf.st_size);
+ 				/* tie off file */
+     LOCAL->buf[sbuf.st_size] = '\0';
+     close (fd);			/* flush message file */
+ 				/* find end of header */
+     for (i = 0,t = LOCAL->buf; *t && !(i && (*t == '\n')); i = (*t++ == '\n'));
+ 				/* number of header bytes */
+     hdrsize = (*t ? ++t : t) - LOCAL->buf;
+     elt->rfc822_size =		/* size of entire message in CRLF form */
+       (elt->ccprivate.msg.header.text.size =
+        strcrlfcpy ((char **) &elt->ccprivate.msg.header.text.data,&i,LOCAL->buf,
+ 		   hdrsize)) +
+ 	 (elt->ccprivate.msg.text.text.size =
+ 	  strcrlfcpy ((char **) &elt->ccprivate.msg.text.text.data,&i,t,
+ 		      sbuf.st_size - hdrsize));
+   }
+   *length = elt->ccprivate.msg.header.text.size;
+   return (char *) elt->ccprivate.msg.header.text.data;
+ }
+ 
+ /* MH mail fetch message text (body only)
+  * Accepts: MAIL stream
+  *	    message # to fetch
+  *	    pointer to returned stringstruct
+  *	    option flags
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long mh_text (MAILSTREAM *stream,unsigned long msgno,STRING *bs,long flags)
+ {
+   unsigned long i;
+   MESSAGECACHE *elt;
+ 				/* UID call "impossible" */
+   if (flags & FT_UID) return NIL;
+   elt = mail_elt (stream,msgno);/* get elt */
+ 				/* snarf message if don't have it yet */
+   if (!elt->ccprivate.msg.text.text.data) {
+     mh_header (stream,msgno,&i,flags);
+     if (!elt->ccprivate.msg.text.text.data) return NIL;
+   }
+   if (!(flags & FT_PEEK)) {	/* mark as seen */
+     mail_elt (stream,msgno)->seen = T;
+     mm_flags (stream,msgno);
+   }
+   if (!elt->ccprivate.msg.text.text.data) return NIL;
+   INIT (bs,mail_string,elt->ccprivate.msg.text.text.data,
+ 	elt->ccprivate.msg.text.text.size);
+   return T;
+ }
+ 
+ /* MH mail ping mailbox
+  * Accepts: MAIL stream
+  * Returns: T if stream alive, else NIL
+  */
+ 
+ long mh_ping (MAILSTREAM *stream)
+ {
+   MAILSTREAM *sysibx = NIL;
+   MESSAGECACHE *elt,*selt;
+   struct stat sbuf;
+   char *s,tmp[MAILTMPLEN];
+   int fd;
+   unsigned long i,j,r,old;
+   long nmsgs = stream->nmsgs;
+   long recent = stream->recent;
+   int silent = stream->silent;
+   if (stat (LOCAL->dir,&sbuf)) { /* directory exists? */
+     if (LOCAL->inbox) return T;
+     sprintf (tmp,"Can't open mailbox %.80s: no such mailbox",stream->mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   stream->silent = T;		/* don't pass up mm_exists() events yet */
+   if (sbuf.st_ctime != LOCAL->scantime) {
+     struct _finddata_t **names = NIL;
+     long nfiles = scandir (LOCAL->dir,&names,mh_select,mh_numsort);
+     if (nfiles < 0) nfiles = 0;	/* in case error */
+     old = stream->uid_last;
+ 				/* note scanned now */
+     LOCAL->scantime = sbuf.st_ctime;
+ 				/* scan directory */
+     for (i = 0; (long)i < nfiles; ++i) {
+ 				/* if newly seen, add to list */
+       if ((j = atoi (names[i]->name)) > old) {
+ 	mail_exists (stream,++nmsgs);
+ 	stream->uid_last = (elt = mail_elt (stream,nmsgs))->ccprivate.uid = j;
+ 	elt->valid = T;		/* note valid flags */
+ 	if (old) {		/* other than the first pass? */
+ 	  elt->recent = T;	/* yup, mark as recent */
+ 	  recent++;		/* bump recent count */
+ 	}
+ 	else {			/* see if already read */
+ 	  sprintf (tmp,"%s/%s",LOCAL->dir,names[i]->name);
+ 	  stat (tmp,&sbuf);	/* get inode poop */
+ 	  if (sbuf.st_atime > sbuf.st_mtime) elt->seen = T;
+ 	}
+       }
+       fs_give ((void **) &names[i]);
+     }
+ 				/* free directory */
+     if (names) fs_give ((void **) &names);
+   }
+ 
+ 				/* if INBOX, snarf from system INBOX  */
+   if (LOCAL->inbox && strcmp (sysinbox (),stream->mailbox)) {
+     old = stream->uid_last;
+     mm_critical (stream);	/* go critical */
+     stat (sysinbox (),&sbuf);	/* see if anything there */
+ 				/* can get sysinbox mailbox? */
+     if (sbuf.st_size && (sysibx = mail_open (sysibx,sysinbox (),OP_SILENT))
+ 	&& (!sysibx->rdonly) && (r = sysibx->nmsgs)) {
+       for (i = 1; i <= r; ++i) {/* for each message in sysinbox mailbox */
+ 				/* build file name we will use */
+ 	sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,++old);
+ 				/* snarf message from Berkeley mailbox */
+ 	selt = mail_elt (sysibx,i);
+ 	if (((fd = open (LOCAL->buf,_O_WRONLY|_O_CREAT|_O_EXCL,
+ 			 S_IREAD|S_IWRITE)) >= 0) &&
+ 	    (s = mail_fetchheader_full (sysibx,i,NIL,&j,FT_INTERNAL)) &&
+ 	    (write (fd,s,j) == (long)j) &&
+ 	    (s = mail_fetchtext_full (sysibx,i,&j,FT_INTERNAL|FT_PEEK)) &&
+ 	    (write (fd,s,j) == (long)j) && !fsync (fd) && !close (fd)) {
+ 				/* swell the cache */
+ 	  mail_exists (stream,++nmsgs);
+ 	  stream->uid_last =	/* create new elt, note its file number */
+ 	    (elt = mail_elt (stream,nmsgs))->ccprivate.uid = old;
+ 	  recent++;		/* bump recent count */
+ 				/* set up initial flags and date */
+ 	  elt->valid = elt->recent = T;
+ 	  elt->seen = selt->seen;
+ 	  elt->deleted = selt->deleted;
+ 	  elt->flagged = selt->flagged;
+ 	  elt->answered = selt->answered;
+ 	  elt->draft = selt->draft;
+ 	  elt->day = selt->day;elt->month = selt->month;elt->year = selt->year;
+ 	  elt->hours = selt->hours;elt->minutes = selt->minutes;
+ 	  elt->seconds = selt->seconds;
+ 	  elt->zhours = selt->zhours; elt->zminutes = selt->zminutes;
+ 	  mh_setdate (LOCAL->buf,elt);
+ 	}
+ 
+ 	else {			/* failed to snarf */
+ 	  if (fd) {		/* did it ever get opened? */
+ 	    mm_log ("Message copy to MH mailbox failed",ERROR);
+ 	    close (fd);		/* close descriptor */
+ 	    unlink (LOCAL->buf);/* flush this file */
+ 	  }
+ 	  else {
+ 	    sprintf (tmp,"Can't add message: %s",strerror (errno));
+ 	    mm_log (tmp,ERROR);
+ 	  }
+ 	  stream->silent = silent;
+ 	  return NIL;		/* note that something is badly wrong */
+ 	}
+ 	sprintf (tmp,"%lu",i);	/* delete it from the sysinbox */
+ 	mail_flag (sysibx,tmp,"\\Deleted",ST_SET);
+       }
+       stat (LOCAL->dir,&sbuf);	/* update scan time */
+       LOCAL->scantime = sbuf.st_ctime;      
+       mail_expunge (sysibx);	/* now expunge all those messages */
+     }
+     if (sysibx) mail_close (sysibx);
+     mm_nocritical (stream);	/* release critical */
+   }
+   stream->silent = silent;	/* can pass up events now */
+   mail_exists (stream,nmsgs);	/* notify upper level of mailbox size */
+   mail_recent (stream,recent);
+   return T;			/* return that we are alive */
+ }
+ 
+ /* MH mail check mailbox
+  * Accepts: MAIL stream
+  */
+ 
+ void mh_check (MAILSTREAM *stream)
+ {
+   /* Perhaps in the future this will preserve flags */
+   if (mh_ping (stream)) mm_log ("Check completed",(long) NIL);
+ }
+ 
+ 
+ /* MH mail expunge mailbox
+  * Accepts: MAIL stream
+  */
+ 
+ void mh_expunge (MAILSTREAM *stream)
+ {
+   MESSAGECACHE *elt;
+   unsigned long i = 1;
+   unsigned long n = 0;
+   unsigned long recent = stream->recent;
+   mm_critical (stream);		/* go critical */
+   while (i <= stream->nmsgs) {	/* for each message */
+ 				/* if deleted, need to trash it */
+     if ((elt = mail_elt (stream,i))->deleted) {
+       sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->ccprivate.uid);
+       if (unlink (LOCAL->buf)) {/* try to delete the message */
+ 	sprintf (LOCAL->buf,"Expunge of message %ld failed, aborted: %s",i,
+ 		 strerror (errno));
+ 	mm_log (LOCAL->buf,(long) NIL);
+ 	break;
+       }
+       mail_gc_msg (&elt->ccprivate.msg,GC_ENV | GC_TEXTS);
+       if (elt->recent) --recent;/* if recent, note one less recent message */
+       mail_expunged (stream,i);	/* notify upper levels */
+       n++;			/* count up one more expunged message */
+     }
+     else i++;			/* otherwise try next message */
+   }
+   if (n) {			/* output the news if any expunged */
+     sprintf (LOCAL->buf,"Expunged %ld messages",n);
+     mm_log (LOCAL->buf,(long) NIL);
+   }
+   else mm_log ("No messages deleted, so no update needed",(long) NIL);
+   mm_nocritical (stream);	/* release critical */
+ 				/* notify upper level of new mailbox size */
+   mail_exists (stream,stream->nmsgs);
+   mail_recent (stream,recent);
+ }
+ 
+ /* MH mail copy message(s)
+  * Accepts: MAIL stream
+  *	    sequence
+  *	    destination mailbox
+  *	    copy options
+  * Returns: T if copy successful, else NIL
+  */
+ 
+ long mh_copy (MAILSTREAM *stream,char *sequence,char *mailbox,long options)
+ {
+   STRING st;
+   MESSAGECACHE *elt;
+   struct stat sbuf;
+   int fd;
+   unsigned long i;
+   char flags[MAILTMPLEN],date[MAILTMPLEN];
+ 				/* copy the messages */
+   if ((options & CP_UID) ? mail_uid_sequence (stream,sequence) :
+       mail_sequence (stream,sequence))
+     for (i = 1; i <= stream->nmsgs; i++) 
+       if ((elt = mail_elt (stream,i))->sequence) {
+ 	sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->ccprivate.uid);
+ 	if ((fd = open (LOCAL->buf,_O_RDONLY,NIL)) < 0) return NIL;
+ 	fstat (fd,&sbuf);	/* get size of message */
+ 	if (!elt->day) {	/* make plausible IMAPish date string */
+ 	  struct tm *tm = gmtime (&sbuf.st_mtime);
+ 	  elt->day = tm->tm_mday; elt->month = tm->tm_mon + 1;
+ 	  elt->year = tm->tm_year + 1900 - BASEYEAR;
+ 	  elt->hours = tm->tm_hour; elt->minutes = tm->tm_min;
+ 	  elt->seconds = tm->tm_sec;
+ 	  elt->zhours = 0; elt->zminutes = 0;
+ 	}
+ 				/* is buffer big enough? */
+ 	if (sbuf.st_size > (long)LOCAL->buflen) {
+ 	  fs_give ((void **) &LOCAL->buf);
+ 	  LOCAL->buf = (char *) fs_get ((LOCAL->buflen = sbuf.st_size) + 1);
+ 	}
+ 				/* slurp message */
+ 	read (fd,LOCAL->buf,sbuf.st_size);
+ 				/* tie off file */
+ 	LOCAL->buf[sbuf.st_size] = '\0';
+ 	close (fd);		/* flush message file */
+ 	INIT (&st,mail_string,(void *) LOCAL->buf,sbuf.st_size);
+ 	flags[0] = '\0';	/* init flag string */
+ 	if (elt->seen) strcat (flags," \\Seen");
+ 	if (elt->deleted) strcat (flags," \\Deleted");
+ 	if (elt->flagged) strcat (flags," \\Flagged");
+ 	if (elt->answered) strcat (flags," \\Answered");
+ 	if (elt->draft) strcat (flags," \\Draft");
+ 	flags[0] = '(';		/* open list */
+ 	strcat (flags,")");	/* close list */
+ 	mail_date (date,elt);	/* generate internal date */
+ 	if (!mail_append_full (stream,mailbox,flags,date,&st)) return NIL;
+ 	if (options & CP_MOVE) elt->deleted = T;
+       }
+   return T;			/* return success */
+ }
+ 
+ /* MH mail append message from stringstruct
+  * Accepts: MAIL stream
+  *	    destination mailbox
+  *	    stringstruct of messages to append
+  * Returns: T if append successful, else NIL
+  */
+ 
+ long mh_append (MAILSTREAM *stream,char *mailbox,char *flags,char *date,
+ 		STRING *message)
+ {
+   struct _finddata_t **names;
+   int fd;
+   char c,*s,tmp[MAILTMPLEN];
+   MESSAGECACHE elt;
+   long i,last,nfiles;
+   long size = 0;
+   long ret = LONGT;
+   unsigned long uf;
+   short f = (short)mail_parse_flags (stream ? stream : &mhproto,flags,&uf);
+   if (date) {			/* want to preserve date? */
+ 				/* yes, parse date into an elt */
+     if (!mail_parse_date (&elt,date)) {
+       sprintf (tmp,"Bad date in append: %.80s",date);
+       mm_log (tmp,ERROR);
+       return NIL;
+     }
+   }
+ 				/* N.B.: can't use LOCAL->buf for tmp */
+ 				/* make sure valid mailbox */
+   if (!mh_isvalid (mailbox,tmp,NIL)) switch (errno) {
+   case ENOENT:			/* no such file? */
+     if ((mailbox[0] == '#') && ((mailbox[1] == 'M') || (mailbox[1] == 'm')) &&
+ 	((mailbox[2] == 'H') || (mailbox[2] == 'h')) &&
+ 	((mailbox[3] == 'I') || (mailbox[3] == 'i')) &&
+ 	((mailbox[4] == 'N') || (mailbox[4] == 'n')) &&
+ 	((mailbox[5] == 'B') || (mailbox[5] == 'b')) &&
+ 	((mailbox[6] == 'O') || (mailbox[6] == 'o')) &&
+ 	((mailbox[7] == 'X') || (mailbox[7] == 'x')) && !mailbox[8])
+       mh_create (NIL,"INBOX");
+     else {
+       mm_notify (stream,"[TRYCREATE] Must create mailbox before append",NIL);
+       return NIL;
+     }
+ 				/* falls through */
+   case 0:			/* merely empty file? */
+     break;
+   case EINVAL:
+     sprintf (tmp,"Invalid MH-format mailbox name: %.80s",mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   default:
+     sprintf (tmp,"Not a MH-format mailbox: %.80s",mailbox);
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   mh_file (tmp,mailbox);	/* build file name we will use */
+   if ((nfiles = scandir (tmp,&names,mh_select,mh_numsort)) > 0) {
+ 				/* largest number */
+     last = atoi (names[nfiles-1]->name);    
+     for (i = 0; i < nfiles; ++i) /* free directory */
+       fs_give ((void **) &names[i]);
+   }
+   else last = 0;		/* no messages here yet */
+   if (names) fs_give ((void **) &names);
+ 
+   sprintf (tmp + strlen (tmp),"/%lu",++last);
+   if ((fd = open (tmp,_O_WRONLY|_O_CREAT|_O_EXCL,S_IREAD|S_IWRITE)) < 0) {
+     sprintf (tmp,"Can't open append message: %s",strerror (errno));
+     mm_log (tmp,ERROR);
+     return NIL;
+   }
+   i = SIZE (message);		/* get size of message */
+   s = (char *) fs_get (i + 1);	/* get space for the data */
+ 				/* copy the data w/o CR's */
+   while (i--) if ((c = SNX (message)) != '\015') s[size++] = c;
+   mm_critical (stream);		/* go critical */
+ 				/* write the data */
+   if ((write (fd,s,size) < 0) || fsync (fd)) {
+     unlink (tmp);		/* delete message */
+     sprintf (tmp,"Message append failed: %s",strerror (errno));
+     mm_log (tmp,ERROR);
+     ret = NIL;
+   }
+   close (fd);			/* close the file */
+ 				/* set the date for this message */
+   if (date) mh_setdate (tmp,&elt);
+ 
+   mm_nocritical (stream);	/* release critical */
+   fs_give ((void **) &s);	/* flush the buffer */
+   return ret;
+ }
+ 
+ /* Internal routines */
+ 
+ 
+ /* MH file name selection test
+  * Accepts: candidate directory entry
+  * Returns: T to use file name, NIL to skip it
+  */
+ 
+ int mh_select (struct _finddata_t *fileinfo)
+ {
+   char c;
+   char *s = fileinfo->name;
+   while (c = *s++) if (!isdigit (c)) return NIL;
+   return T;
+ }
+ 
+ 
+ /* MH file name comparision
+  * Accepts: first candidate directory entry
+  *	    second candidate directory entry
+  * Returns: negative if d1 < d2, 0 if d1 == d2, postive if d1 > d2
+  */
+ 
+ int mh_numsort (const void *d1,const void *d2)
+ {
+   return atoi ((*(struct _finddata_t **) d1)->name) -
+     atoi ((*(struct _finddata_t **) d2)->name);
+ }
+ 
+ 
+ /* MH mail build file name
+  * Accepts: destination string
+  *          source
+  * Returns: destination
+  */
+ 
+ char *mh_file (char *dst,char *name)
+ {
+   char tmp[MAILTMPLEN];
+ 				/* build composite name */
+   sprintf (dst,"%s/%.900s",mh_path,
+ 	   strcmp (ucase (strcpy (tmp,name)),"#MHINBOX") ? name + 4 : "inbox");
+   return dst;
+ }
+ 
+ 
+ /* MH canonicalize name
+  * Accepts: buffer to write name
+  *	    reference
+  *	    pattern
+  * Returns: T if success, NIL if failure
+  */
+ 
+ long mh_canonicalize (char *pattern,char *ref,char *pat)
+ {
+   char tmp[MAILTMPLEN];
+   if (ref && *ref) {		/* have a reference */
+     strcpy (pattern,ref);	/* copy reference to pattern */
+ 				/* # overrides mailbox field in reference */
+     if (*pat == '#') strcpy (pattern,pat);
+ 				/* pattern starts, reference ends, with / */
+     else if ((*pat == '/') && (pattern[strlen (pattern) - 1] == '/'))
+       strcat (pattern,pat + 1);	/* append, omitting one of the period */
+     else strcat (pattern,pat);	/* anything else is just appended */
+   }
+   else strcpy (pattern,pat);	/* just have basic name */
+   return (mh_isvalid (pattern,tmp,T));
+ }
+ 
+ /* Set date for message
+  * Accepts: file name
+  *	    elt containing date
+  */
+ 
+ void mh_setdate (char *file,MESSAGECACHE *elt)
+ {
+   struct _utimbuf times;
+   times.actime = time (0);		/* atime is now */
+   times.modtime = mail_longdate (elt);	/* modification time */
+   _utime (file,&times);		/* set the times */
+ }
+ 
+ /* Retrieve the MH path
+  */
+ extern char *mh_getpath(void)
+ {
+   return mh_path;
+ }
+ 
+ /* vi: set ts=8 sta noet list sw=2: */
diff -c -N c-client.pure/mhnt.h c-client/mhnt.h
*** c-client.pure/mhnt.h	Thu Jan  1 01:00:00 1970
--- c-client/mhnt.h	Sat Feb  5 14:44:03 2000
***************
*** 0 ****
--- 1,92 ----
+ /*
+  * Program:	MH mail routines
+  *
+  * Author(s):	Mark Crispin
+  *		Networks and Distributed Computing
+  *		Computing & Communications
+  *		University of Washington
+  *		Administration Building, AG-44
+  *		Seattle, WA  98195
+  *		Internet: MRC@CAC.Washington.EDU
+  *
+  * Date:	23 February 1992
+  * Last Edited:	27 July 1998
+  *
+  * Copyright 1998 by the University of Washington
+  *
+  *  Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notice appears in all copies and that both the
+  * above copyright notice and this permission notice appear in supporting
+  * documentation, and that the name of the University of Washington not be
+  * used in advertising or publicity pertaining to distribution of the software
+  * without specific, written prior permission.  This software is made
+  * available "as is", and
+  * THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+  * WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+  * NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+  * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+  * (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+  * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  */
+ 
+ /* Build parameters */
+ 
+ #define MHPROFILE ".mh_profile"
+ #define MHSEQUENCE ".mh_sequence"
+ #define MHPATH "Mail"
+ 
+ 
+ /* MH I/O stream local data */
+ 	
+ typedef struct mh_local {
+   unsigned int inbox : 1;	/* if it's an INBOX or not */
+   char *dir;			/* spool directory name */
+   char *buf;			/* temporary buffer */
+   unsigned long buflen;		/* current size of temporary buffer */
+   time_t scantime;		/* last time directory scanned */
+ } MHLOCAL;
+ 
+ 
+ /* Convenient access to local data */
+ 
+ #define LOCAL ((MHLOCAL *) stream->local)
+ 
+ /* Function prototypes */
+ 
+ DRIVER *mh_valid (char *name);
+ int mh_isvalid (char *name,char *tmp,long synonly);
+ void *mh_parameters (long function,void *value);
+ void mh_scan (MAILSTREAM *stream,char *ref,char *pat,char *contents);
+ void mh_list (MAILSTREAM *stream,char *ref,char *pat);
+ void mh_lsub (MAILSTREAM *stream,char *ref,char *pat);
+ void mh_list_work (MAILSTREAM *stream,char *dir,char *pat,long level);
+ long mh_subscribe (MAILSTREAM *stream,char *mailbox);
+ long mh_unsubscribe (MAILSTREAM *stream,char *mailbox);
+ long mh_create (MAILSTREAM *stream,char *mailbox);
+ long mh_delete (MAILSTREAM *stream,char *mailbox);
+ long mh_rename (MAILSTREAM *stream,char *old,char *newname);
+ MAILSTREAM *mh_open (MAILSTREAM *stream);
+ void mh_close (MAILSTREAM *stream,long options);
+ void mh_fast (MAILSTREAM *stream,char *sequence,long flags);
+ char *mh_header (MAILSTREAM *stream,unsigned long msgno,unsigned long *length,
+ 		 long flags);
+ long mh_text (MAILSTREAM *stream,unsigned long msgno,STRING *bs,long flags);
+ long mh_ping (MAILSTREAM *stream);
+ void mh_check (MAILSTREAM *stream);
+ void mh_expunge (MAILSTREAM *stream);
+ long mh_copy (MAILSTREAM *stream,char *sequence,char *mailbox,
+ 	      long options);
+ long mh_append (MAILSTREAM *stream,char *mailbox,char *flags,char *date,
+ 		STRING *message);
+ 
+ int mh_select (struct _finddata_t *fileinfo);
+ int mh_numsort (const void *d1,const void *d2);
+ char *mh_file (char *dst,char *name);
+ long mh_canonicalize (char *pattern,char *ref,char *pat);
+ void mh_setdate (char *file,MESSAGECACHE *elt);
+ 
+ /* vi: set ts=8 sta noet list: */
Binary files c-client.pure/misc.o and c-client/misc.o differ
diff -c -N c-client.pure/mkauths c-client/mkauths
*** c-client.pure/mkauths	Thu Jan  1 01:00:00 1970
--- c-client/mkauths	Sat Feb  5 14:44:02 2000
***************
*** 0 ****
--- 1,48 ----
+ #!/bin/sh
+ #
+ # Program:	Authenticator Linkage Generator
+ #
+ # Author:	Mark Crispin
+ #		Networks and Distributed Computing
+ #		Computing & Communications
+ #		University of Washington
+ #		Administration Building, AG-44
+ #		Seattle, WA  98195
+ #		Internet: MRC@CAC.Washington.EDU
+ #
+ # Date:		5 December 1995
+ # Last Edited:	15 October 1998
+ #
+ # Copyright 1998 by the University of Washington
+ #
+ #  Permission to use, copy, modify, and distribute this software and its
+ # documentation for any purpose and without fee is hereby granted, provided
+ # that the above copyright notice appears in all copies and that both the
+ # above copyright notice and this permission notice appear in supporting
+ # documentation, and that the name of the University of Washington not be
+ # used in advertising or publicity pertaining to distribution of the software
+ # without specific, written prior permission.  This software is made
+ # available "as is", and
+ # THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+ # WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+ # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+ # NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+ # INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+ # LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+ # (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+ # WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ 
+ # Erase old authenticators list
+ rm -f auths.c
+ touch auths.c
+ 
+ # Now define the new list
+ for authenticator
+  do
+   if [ -f Makefile."$authenticator" ]; then
+     make -f Makefile."$authenticator" `cat EXTRASPECIALS`
+   fi
+   echo "extern AUTHENTICATOR auth_"$authenticator";" >> linkage.h
+   echo "  auth_link (&auth_"$authenticator");		/* link in the $authenticator authenticator */" | cat >> linkage.c
+   echo "#include \"auth_"$authenticator".c\"" >> auths.c
+ done
Binary files c-client.pure/mmdf.o and c-client/mmdf.o differ
Binary files c-client.pure/mtx.o and c-client/mtx.o differ
Binary files c-client.pure/mx.o and c-client/mx.o differ
Binary files c-client.pure/netmsg.o and c-client/netmsg.o differ
Binary files c-client.pure/news.o and c-client/news.o differ
diff -c -N c-client.pure/newsnt.c c-client/newsnt.c
*** c-client.pure/newsnt.c	Thu Jan  1 01:00:00 1970
--- c-client/newsnt.c	Sat Feb  5 14:44:03 2000
***************
*** 0 ****
--- 1,614 ----
+ /*
+  * Program:	News routines
+  *
+  * Author:	Mark Crispin
+  *		Networks and Distributed Computing
+  *		Computing & Communications
+  *		University of Washington
+  *		Administration Building, AG-44
+  *		Seattle, WA  98195
+  *		Internet: MRC@CAC.Washington.EDU
+  *
+  * Modified by: Vadim Zeitlin
+  *		adopted news.c for Win32
+  *
+  * Date:	4 September 1991
+  * Last Edited:	4 December 1998
+  *
+  * Copyright 1998 by the University of Washington
+  *
+  *  Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notice appears in all copies and that both the
+  * above copyright notice and this permission notice appear in supporting
+  * documentation, and that the name of the University of Washington not be
+  * used in advertising or publicity pertaining to distribution of the software
+  * without specific, written prior permission.  This software is made
+  * available "as is", and
+  * THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+  * WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+  * NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+  * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+  * (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+  * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  */
+ 
+ #include <stdio.h>
+ #include <ctype.h>
+ #include <errno.h>
+ extern int errno;		/* just in case */
+ #include "mail.h"
+ #include "osdep.h"
+ #include <sys/stat.h>
+ #include "newsnt.h"
+ #include "misc.h"
+ #include "newsrc.h"
+ 
+ #include <fcntl.h>		/* _O_RDONLY and friends */
+ 
+ #define O_RDONLY  _O_RDONLY
+ 
+ 
+ /* News routines */
+ 
+ 
+ /* Driver dispatch used by MAIL */
+ 
+ DRIVER newsdriver = {
+   "news",			/* driver name */
+ 				/* driver flags */
+   DR_NEWS|DR_READONLY|DR_NOFAST|DR_NAMESPACE,
+   (DRIVER *) NIL,		/* next driver */
+   news_valid,			/* mailbox is valid for us */
+   news_parameters,		/* manipulate parameters */
+   news_scan,			/* scan mailboxes */
+   news_list,			/* find mailboxes */
+   news_lsub,			/* find subscribed mailboxes */
+   news_subscribe,		/* subscribe to mailbox */
+   news_unsubscribe,		/* unsubscribe from mailbox */
+   news_create,			/* create mailbox */
+   news_delete,			/* delete mailbox */
+   news_rename,			/* rename mailbox */
+   NIL,				/* status of mailbox */
+   news_open,			/* open mailbox */
+   news_close,			/* close mailbox */
+   news_fast,			/* fetch message "fast" attributes */
+   news_flags,			/* fetch message flags */
+   NIL,				/* fetch overview */
+   NIL,				/* fetch message envelopes */
+   news_header,			/* fetch message header */
+   news_text,			/* fetch message body */
+   NIL,				/* fetch partial message text */
+   NIL,				/* unique identifier */
+   NIL,				/* message number */
+   NIL,				/* modify flags */
+   news_flagmsg,			/* per-message modify flags */
+   NIL,				/* search for message based on criteria */
+   NIL,				/* sort messages */
+   NIL,				/* thread messages */
+   news_ping,			/* ping mailbox to see if still alive */
+   news_check,			/* check for new messages */
+   news_expunge,			/* expunge deleted messages */
+   news_copy,			/* copy messages to another mailbox */
+   news_append,			/* append string message to mailbox */
+   NIL				/* garbage collect stream */
+ };
+ 
+ 				/* prototype stream */
+ MAILSTREAM newsproto = {&newsdriver};
+ 
+ /* News validate mailbox
+  * Accepts: mailbox name
+  * Returns: our driver if name is valid, NIL otherwise
+  */
+ 
+ DRIVER *news_valid (char *name)
+ {
+   struct stat sbuf;
+   if ((name[0] == '#') && (name[1] == 'n') && (name[2] == 'e') &&
+       (name[3] == 'w') && (name[4] == 's') && (name[5] == '.') &&
+       !strchr (name,'/') &&
+       !stat ((char *) mail_parameters (NIL,GET_NEWSSPOOL,NIL),&sbuf))
+ 	return &newsdriver;
+   return NIL;			/* return status */
+ }
+ 
+ /* News manipulate driver parameters
+  * Accepts: function code
+  *	    function-dependent value
+  * Returns: function-dependent return value
+  */
+ 
+ void *news_parameters (long function,void *value)
+ {
+   return NIL;
+ }
+ 
+ 
+ /* News scan mailboxes
+  * Accepts: mail stream
+  *	    reference
+  *	    pattern to search
+  *	    string to scan
+  */
+ 
+ void news_scan (MAILSTREAM *stream,char *ref,char *pat,char *contents)
+ {
+   char tmp[MAILTMPLEN];
+   if (news_canonicalize (ref,pat,tmp))
+     mm_log ("Scan not valid for news mailboxes",ERROR);
+ }
+ 
+ /* News find list of newsgroups
+  * Accepts: mail stream
+  *	    reference
+  *	    pattern to search
+  */
+ 
+ void news_list (MAILSTREAM *stream,char *ref,char *pat)
+ {
+   int fd;
+   int i;
+   char *s,*t,*u,*lcl,pattern[MAILTMPLEN],name[MAILTMPLEN];
+   struct stat sbuf;
+   if (!pat || !*pat) {		/* empty pattern? */
+     if (news_canonicalize (ref,"*",pattern)) {
+ 				/* tie off name at root */
+       if (s = strchr (pattern,'.')) *++s = '\0';
+       else pattern[0] = '\0';
+       mm_list (stream,'.',pattern,LATT_NOSELECT);
+     }
+   }
+   if (news_canonicalize (ref,pat,pattern) &&
+       !stat ((char *) mail_parameters (NIL,GET_NEWSSPOOL,NIL),&sbuf) &&
+       ((fd = open ((char *) mail_parameters (NIL,GET_NEWSACTIVE,NIL),O_RDONLY,
+ 		   NIL)) >= 0)) {
+     fstat (fd,&sbuf);		/* get file size and read data */
+     read (fd,s = (char *) fs_get (sbuf.st_size + 1),sbuf.st_size);
+     close (fd);			/* close file */
+     s[sbuf.st_size] = '\0';	/* tie off string */
+ 				/* point after prefix */
+     lcl = strcpy (name,"#news.") + 6;
+     i = strlen (pattern);	/* length of pattern */
+     if (pattern[--i] != '%') i = 0;
+     if (t = strtok (s,"\n")) do if (u = strchr (t,' ')) {
+       *u = '\0';		/* tie off at end of name */
+       strcpy (lcl,t);		/* make full form of name */
+       if (pmatch_full (name,pattern,'.')) mm_list (stream,'.',name,NIL);
+       else if (i && (u = strchr (name + i,'.'))) {
+ 	*u = '\0';		/* tie off at delimiter, see if matches */
+ 	if (pmatch_full (name,pattern,'.'))
+ 	  mm_list (stream,'.',name,LATT_NOSELECT);
+       }
+     } while (t = strtok (NIL,"\n"));
+     fs_give ((void **) &s);
+   }
+ }
+ 
+ /* News find list of subscribed newsgroups
+  * Accepts: mail stream
+  *	    reference
+  *	    pattern to search
+  */
+ 
+ void news_lsub (MAILSTREAM *stream,char *ref,char *pat)
+ {
+   char pattern[MAILTMPLEN];
+ 				/* return data from newsrc */
+   if (news_canonicalize (ref,pat,pattern)) newsrc_lsub (stream,pattern);
+ }
+ 
+ 
+ /* News canonicalize newsgroup name
+  * Accepts: reference
+  *	    pattern
+  *	    returned single pattern
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long news_canonicalize (char *ref,char *pat,char *pattern)
+ {
+   if (ref && *ref) {		/* have a reference */
+     strcpy (pattern,ref);	/* copy reference to pattern */
+ 				/* # overrides mailbox field in reference */
+     if (*pat == '#') strcpy (pattern,pat);
+ 				/* pattern starts, reference ends, with . */
+     else if ((*pat == '.') && (pattern[strlen (pattern) - 1] == '.'))
+       strcat (pattern,pat + 1);	/* append, omitting one of the period */
+     else strcat (pattern,pat);	/* anything else is just appended */
+   }
+   else strcpy (pattern,pat);	/* just have basic name */
+   return ((pattern[0] == '#') && (pattern[1] == 'n') && (pattern[2] == 'e') &&
+ 	  (pattern[3] == 'w') && (pattern[4] == 's') && (pattern[5] == '.') &&
+ 	  !strchr (pattern,'/')) ? T : NIL;
+ }
+ 
+ /* News subscribe to mailbox
+  * Accepts: mail stream
+  *	    mailbox to add to subscription list
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long news_subscribe (MAILSTREAM *stream,char *mailbox)
+ {
+   return news_valid (mailbox) ? newsrc_update (stream,mailbox+6,':') : NIL;
+ }
+ 
+ 
+ /* NEWS unsubscribe to mailbox
+  * Accepts: mail stream
+  *	    mailbox to delete from subscription list
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long news_unsubscribe (MAILSTREAM *stream,char *mailbox)
+ {
+   return news_valid (mailbox) ? newsrc_update (stream,mailbox+6,'!') : NIL;
+ }
+ 
+ /* News create mailbox
+  * Accepts: mail stream
+  *	    mailbox name to create
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long news_create (MAILSTREAM *stream,char *mailbox)
+ {
+   return NIL;			/* never valid for News */
+ }
+ 
+ 
+ /* News delete mailbox
+  *	    mailbox name to delete
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long news_delete (MAILSTREAM *stream,char *mailbox)
+ {
+   return NIL;			/* never valid for News */
+ }
+ 
+ 
+ /* News rename mailbox
+  * Accepts: mail stream
+  *	    old mailbox name
+  *	    new mailbox name
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long news_rename (MAILSTREAM *stream,char *old,char *newname)
+ {
+   return NIL;			/* never valid for News */
+ }
+ 
+ /* News status of mailbox default handler
+  * Accepts: mail stream
+  *	    mailbox name
+  *	    status flags
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long news_status (MAILSTREAM *stream,char *mbx,long flags)
+ {
+   MAILSTATUS status;
+   unsigned long i;
+   MAILSTREAM *tstream = NIL;
+ 				/* make temporary stream (unless this mbx) */
+   if ((!stream || strcmp (stream->mailbox,mbx)) &&
+       !(stream = tstream = mail_open (NIL,mbx,OP_READONLY|OP_SILENT)))
+     return NIL;
+   status.flags = flags;		/* return status values */
+   status.messages = stream->nmsgs;
+   status.recent = stream->recent;
+   if (flags & SA_UNSEEN)	/* must search to get unseen messages */
+     for (i = 1,status.unseen = 0; i <= stream->nmsgs; i++)
+       if (!mail_elt (stream,i)->deleted) status.unseen++;
+   status.uidnext = stream->uid_last + 1;
+   status.uidvalidity = stream->uid_validity;
+ 				/* pass status to main program */
+   mm_status (stream,mbx,&status);
+   if (tstream) mail_close (tstream);
+   return T;			/* success */
+ }
+ 
+ /* News open
+  * Accepts: stream to open
+  * Returns: stream on success, NIL on failure
+  */
+ 
+ MAILSTREAM *news_open (MAILSTREAM *stream)
+ {
+   long i,nmsgs;
+   char c = NIL,*s,tmp[MAILTMPLEN];
+   struct _finddata_t **names = NIL;
+   				/* return prototype for OP_PROTOTYPE call */
+   if (!stream) return &newsproto;
+   if (stream->local) fatal ("news recycle stream");
+ 				/* build directory name */
+   sprintf (s = tmp,"%s/%s",(char *) mail_parameters (NIL,GET_NEWSSPOOL,NIL),
+ 	   stream->mailbox + 6);
+   while (s = strchr (s,'.')) *s = '/';
+ 				/* scan directory */
+   if ((nmsgs = scandir (tmp,&names,news_select,news_numsort)) >= 0) {
+     mail_exists (stream,nmsgs);	/* notify upper level that messages exist */
+     stream->local = fs_get (sizeof (NEWSLOCAL));
+     LOCAL->dirty = NIL;		/* no update to .newsrc needed yet */
+     LOCAL->dir = cpystr (tmp);	/* copy directory name for later */
+ 				/* make temporary buffer */
+     LOCAL->buf = (char *) fs_get ((LOCAL->buflen = MAXMESSAGESIZE) + 1);
+     LOCAL->name = cpystr (stream->mailbox + 6);
+     for (i = 0; i < nmsgs; ++i) {
+       stream->uid_last = mail_elt (stream,i+1)->ccprivate.uid =
+ 	atoi (names[i]->name);
+       fs_give ((void **) &names[i]);
+     }
+     fs_give ((void **) &names);	/* free directory */
+     stream->sequence++;		/* bump sequence number */
+     stream->rdonly = stream->perm_deleted = T;
+ 				/* UIDs are always valid */
+     stream->uid_validity = 0xbeefface;
+ 				/* read .newsrc entries */
+     mail_recent (stream,newsrc_read (LOCAL->name,stream));
+ 				/* notify if empty newsgroup */
+     if (!(stream->nmsgs || stream->silent)) {
+       sprintf (tmp,"Newsgroup %s is empty",LOCAL->name);
+       mm_log (tmp,WARN);
+     }
+   }
+   else mm_log ("Unable to scan newsgroup spool directory",ERROR);
+   return LOCAL ? stream : NIL;	/* if stream is alive, return to caller */
+ }
+ 
+ /* News file name selection test
+  * Accepts: candidate directory entry
+  * Returns: T to use file name, NIL to skip it
+  */
+ 
+ int news_select (struct _finddata_t *fileinfo)
+ {
+   char c;
+   char *s = fileinfo->name;
+   while (c = *s++) if (!isdigit (c)) return NIL;
+   return T;
+ }
+ 
+ 
+ /* News file name comparision
+  * Accepts: first candidate directory entry
+  *	    second candidate directory entry
+  * Returns: negative if d1 < d2, 0 if d1 == d2, postive if d1 > d2
+  */
+ 
+ int news_numsort (const void *d1,const void *d2)
+ {
+   return atoi ((*(struct _finddata_t **) d1)->name) -
+     atoi ((*(struct _finddata_t **) d2)->name);
+ }
+ 
+ 
+ /* News close
+  * Accepts: MAIL stream
+  *	    option flags
+  */
+ 
+ void news_close (MAILSTREAM *stream,long options)
+ {
+   if (LOCAL) {			/* only if a file is open */
+     news_check (stream);	/* dump final checkpoint */
+     if (LOCAL->dir) fs_give ((void **) &LOCAL->dir);
+ 				/* free local scratch buffer */
+     if (LOCAL->buf) fs_give ((void **) &LOCAL->buf);
+     if (LOCAL->name) fs_give ((void **) &LOCAL->name);
+ 				/* nuke the local data */
+     fs_give ((void **) &stream->local);
+     stream->dtb = NIL;		/* log out the DTB */
+   }
+ }
+ 
+ /* News fetch fast information
+  * Accepts: MAIL stream
+  *	    sequence
+  *	    option flags
+  */
+ 
+ void news_fast (MAILSTREAM *stream,char *sequence,long flags)
+ {
+   unsigned long i,j;
+ 				/* ugly and slow */
+   if (stream && LOCAL && ((flags & FT_UID) ?
+ 			  mail_uid_sequence (stream,sequence) :
+ 			  mail_sequence (stream,sequence)))
+     for (i = 1; i <= stream->nmsgs; i++)
+       if (mail_elt (stream,i)->sequence) news_header (stream,i,&j,NIL);
+ }
+ 
+ 
+ /* News fetch flags
+  * Accepts: MAIL stream
+  *	    sequence
+  *	    option flags
+  */
+ 
+ void news_flags (MAILSTREAM *stream,char *sequence,long flags)
+ {
+   unsigned long i;
+   if ((flags & FT_UID) ?	/* validate all elts */
+       mail_uid_sequence (stream,sequence) : mail_sequence (stream,sequence))
+     for (i = 1; i <= stream->nmsgs; i++) mail_elt (stream,i)->valid = T;
+ }
+ 
+ /* News fetch message header
+  * Accepts: MAIL stream
+  *	    message # to fetch
+  *	    pointer to returned header text length
+  *	    option flags
+  * Returns: message header in RFC822 format
+  */
+ 
+ char *news_header (MAILSTREAM *stream,unsigned long msgno,
+ 		   unsigned long *length,long flags)
+ {
+   unsigned long i,hdrsize;
+   int fd;
+   char *t;
+   struct stat sbuf;
+   struct tm *tm;
+   MESSAGECACHE *elt;
+   *length = 0;			/* default to empty */
+   if (flags & FT_UID) return "";/* UID call "impossible" */
+ 				/* get elt */
+   (elt = mail_elt (stream,msgno))->valid = T;
+   if (!elt->ccprivate.msg.header.text.data) {
+ 				/* build message file name */
+     sprintf (LOCAL->buf,"%s/%lu",LOCAL->dir,elt->ccprivate.uid);
+     if ((fd = open (LOCAL->buf,O_RDONLY,NIL)) < 0) return "";
+     fstat (fd,&sbuf);		/* get size of message */
+ 				/* make plausible IMAPish date string */
+     tm = gmtime (&sbuf.st_mtime);
+     elt->day = tm->tm_mday; elt->month = tm->tm_mon + 1;
+     elt->year = tm->tm_year + 1900 - BASEYEAR;
+     elt->hours = tm->tm_hour; elt->minutes = tm->tm_min;
+     elt->seconds = tm->tm_sec;
+     elt->zhours = 0; elt->zminutes = 0;
+ 				/* is buffer big enough? */
+     if ((unsigned)sbuf.st_size > LOCAL->buflen) {
+       fs_give ((void **) &LOCAL->buf);
+       LOCAL->buf = (char *) fs_get ((LOCAL->buflen = sbuf.st_size) + 1);
+     }
+ 				/* slurp message */
+     read (fd,LOCAL->buf,sbuf.st_size);
+ 				/* tie off file */
+     LOCAL->buf[sbuf.st_size] = '\0';
+     close (fd);			/* flush message file */
+ 				/* find end of header */
+     for (i = 0,t = LOCAL->buf; *t && !(i && (*t == '\n')); i = (*t++ == '\n'));
+ 				/* number of header bytes */
+     hdrsize = (*t ? ++t : t) - LOCAL->buf;
+     elt->rfc822_size =		/* size of entire message in CRLF form */
+       (elt->ccprivate.msg.header.text.size =
+        strcrlfcpy ((char **) &elt->ccprivate.msg.header.text.data,&i,LOCAL->buf,
+ 		   hdrsize)) +
+ 	 (elt->ccprivate.msg.text.text.size =
+ 	  strcrlfcpy ((char **) &elt->ccprivate.msg.text.text.data,&i,t,
+ 		      sbuf.st_size - hdrsize));
+   }
+   *length = elt->ccprivate.msg.header.text.size;
+   return (char *) elt->ccprivate.msg.header.text.data;
+ }
+ 
+ /* News fetch message text (body only)
+  * Accepts: MAIL stream
+  *	    message # to fetch
+  *	    pointer to returned stringstruct
+  *	    option flags
+  * Returns: T on success, NIL on failure
+  */
+ 
+ long news_text (MAILSTREAM *stream,unsigned long msgno,STRING *bs,long flags)
+ {
+   unsigned long i;
+   MESSAGECACHE *elt;
+ 				/* UID call "impossible" */
+   if (flags & FT_UID) return NIL;
+   elt = mail_elt (stream,msgno);/* get elt */
+ 				/* snarf message if don't have it yet */
+   if (!elt->ccprivate.msg.text.text.data) {
+     news_header (stream,msgno,&i,flags);
+     if (!elt->ccprivate.msg.text.text.data) return NIL;
+   }
+   if (!(flags & FT_PEEK)) {	/* mark as seen */
+     mail_elt (stream,msgno)->seen = T;
+     mm_flags (stream,msgno);
+   }
+   if (!elt->ccprivate.msg.text.text.data) return NIL;
+   INIT (bs,mail_string,elt->ccprivate.msg.text.text.data,
+ 	elt->ccprivate.msg.text.text.size);
+   return T;
+ }
+ 
+ /* News per-message modify flag
+  * Accepts: MAIL stream
+  *	    message cache element
+  */
+ 
+ void news_flagmsg (MAILSTREAM *stream,MESSAGECACHE *elt)
+ {
+   if (!LOCAL->dirty) {		/* only bother checking if not dirty yet */
+     if (elt->valid) {		/* if done, see if deleted changed */
+       if (elt->sequence != elt->deleted) LOCAL->dirty = T;
+       elt->sequence = T;	/* leave the sequence set */
+     }
+ 				/* note current setting of deleted flag */
+     else elt->sequence = elt->deleted;
+   }
+ }
+ 
+ 
+ /* News ping mailbox
+  * Accepts: MAIL stream
+  * Returns: T if stream alive, else NIL
+  */
+ 
+ long news_ping (MAILSTREAM *stream)
+ {
+   return T;			/* always alive */
+ }
+ 
+ 
+ /* News check mailbox
+  * Accepts: MAIL stream
+  */
+ 
+ void news_check (MAILSTREAM *stream)
+ {
+ 				/* never do if no updates */
+   if (LOCAL->dirty) newsrc_write (LOCAL->name,stream);
+   LOCAL->dirty = NIL;
+ }
+ 
+ 
+ /* News expunge mailbox
+  * Accepts: MAIL stream
+  */
+ 
+ void news_expunge (MAILSTREAM *stream)
+ {
+   if (!stream->silent) mm_log ("Expunge ignored on news",NIL);
+ }
+ 
+ /* News copy message(s)
+  * Accepts: MAIL stream
+  *	    sequence
+  *	    destination mailbox
+  *	    option flags
+  * Returns: T if copy successful, else NIL
+  */
+ 
+ long news_copy (MAILSTREAM *stream,char *sequence,char *mailbox,long options)
+ {
+   mailproxycopy_t pc =
+     (mailproxycopy_t) mail_parameters (stream,GET_MAILPROXYCOPY,NIL);
+   if (pc) return (*pc) (stream,sequence,mailbox,options);
+   mm_log ("Copy not valid for News",ERROR);
+   return NIL;
+ }
+ 
+ 
+ /* News append message from stringstruct
+  * Accepts: MAIL stream
+  *	    destination mailbox
+  *	    stringstruct of messages to append
+  * Returns: T if append successful, else NIL
+  */
+ 
+ long news_append (MAILSTREAM *stream,char *mailbox,char *flags,char *date,
+ 		  STRING *message)
+ {
+   mm_log ("Append not valid for News",ERROR);
+   return NIL;
+ }
+ 
+ /* vi: set ts=8 sta noet list sw=2: */
diff -c -N c-client.pure/newsnt.h c-client/newsnt.h
*** c-client.pure/newsnt.h	Thu Jan  1 01:00:00 1970
--- c-client/newsnt.h	Sat Feb  5 14:44:03 2000
***************
*** 0 ****
--- 1,84 ----
+ /*
+  * Program:	Netnews mail routines
+  *
+  * Author:	Mark Crispin
+  *		Networks and Distributed Computing
+  *		Computing & Communications
+  *		University of Washington
+  *		Administration Building, AG-44
+  *		Seattle, WA  98195
+  *		Internet: MRC@CAC.Washington.EDU
+  *
+  * Modified by: Vadim Zeitlin
+  *		adopted news.h for Win32
+  *
+  * Date:	4 September 1991
+  * Last Edited:	18 January 2000
+  *
+  * Copyright 1998 by the University of Washington
+  *
+  *  Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notice appears in all copies and that both the
+  * above copyright notice and this permission notice appear in supporting
+  * documentation, and that the name of the University of Washington not be
+  * used in advertising or publicity pertaining to distribution of the software
+  * without specific, written prior permission.  This software is made
+  * available "as is", and
+  * THE UNIVERSITY OF WASHINGTON DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED,
+  * WITH REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED
+  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND IN
+  * NO EVENT SHALL THE UNIVERSITY OF WASHINGTON BE LIABLE FOR ANY SPECIAL,
+  * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, TORT
+  * (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF OR IN CONNECTION
+  * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  */
+ 
+ /* NEWS I/O stream local data */
+ 	
+ typedef struct news_local {
+   unsigned int dirty : 1;	/* disk copy of .newsrc needs updating */
+   char *dir;			/* spool directory name */
+   char *name;			/* local mailbox name */
+   char *buf;			/* scratch buffer */
+   unsigned long buflen;		/* current size of scratch buffer */
+ } NEWSLOCAL;
+ 
+ 
+ /* Convenient access to local data */
+ 
+ #define LOCAL ((NEWSLOCAL *) stream->local)
+ 
+ /* Function prototypes */
+ 
+ DRIVER *news_valid (char *name);
+ DRIVER *news_isvalid (char *name,char *mbx);
+ void *news_parameters (long function,void *value);
+ void news_scan (MAILSTREAM *stream,char *ref,char *pat,char *contents);
+ void news_list (MAILSTREAM *stream,char *ref,char *pat);
+ void news_lsub (MAILSTREAM *stream,char *ref,char *pat);
+ long news_canonicalize (char *ref,char *pat,char *pattern);
+ long news_subscribe (MAILSTREAM *stream,char *mailbox);
+ long news_unsubscribe (MAILSTREAM *stream,char *mailbox);
+ long news_create (MAILSTREAM *stream,char *mailbox);
+ long news_delete (MAILSTREAM *stream,char *mailbox);
+ long news_rename (MAILSTREAM *stream,char *old,char *newname);
+ long news_status (MAILSTREAM *stream,char *mbx,long flags);
+ MAILSTREAM *news_open (MAILSTREAM *stream);
+ int news_select (struct _finddata_t *fileinfo);
+ int news_numsort (const void *d1,const void *d2);
+ void news_close (MAILSTREAM *stream,long options);
+ void news_fast (MAILSTREAM *stream,char *sequence,long flags);
+ void news_flags (MAILSTREAM *stream,char *sequence,long flags);
+ char *news_header (MAILSTREAM *stream,unsigned long msgno,
+ 		   unsigned long *length,long flags);
+ long news_text (MAILSTREAM *stream,unsigned long msgno,STRING *bs,long flags);
+ void news_flagmsg (MAILSTREAM *stream,MESSAGECACHE *elt);
+ long news_ping (MAILSTREAM *stream);
+ void news_check (MAILSTREAM *stream);
+ void news_expunge (MAILSTREAM *stream);
+ long news_copy (MAILSTREAM *stream,char *sequence,char *mailbox,long options);
+ long news_append (MAILSTREAM *stream,char *mailbox,char *flags,char *date,
+ 		  STRING *message);
Binary files c-client.pure/newsrc.o and c-client/newsrc.o differ
Binary files c-client.pure/nntp.o and c-client/nntp.o differ
Binary files c-client.pure/osdep.o and c-client/osdep.o differ
Binary files c-client.pure/phile.o and c-client/phile.o differ
diff -c -N c-client.pure/pop3.c c-client/pop3.c
*** c-client.pure/pop3.c	Sat Feb  5 18:29:54 2000
--- c-client/pop3.c	Sat Feb  5 16:44:17 2000
***************
*** 594,600 ****
    if ((flags & FT_UID) && !(msgno = mail_msgno (stream,msgno))) return NIL;
  				/* have header text? */
    if (!(elt = mail_elt (stream,msgno))->private.msg.header.text.data) {
!     elt->private.msg.header.text.size = pop3_cache (stream,elt);
  				/* read the header */
      fread (elt->private.msg.header.text.data = (unsigned char *)
  	   fs_get ((size_t) elt->private.msg.header.text.size + 1),
--- 594,600 ----
    if ((flags & FT_UID) && !(msgno = mail_msgno (stream,msgno))) return NIL;
  				/* have header text? */
    if (!(elt = mail_elt (stream,msgno))->private.msg.header.text.data) {
!     elt->private.msg.header.text.size = pop3_cache_header (stream,elt);
  				/* read the header */
      fread (elt->private.msg.header.text.data = (unsigned char *)
  	   fs_get ((size_t) elt->private.msg.header.text.size + 1),
***************
*** 640,646 ****
  unsigned long pop3_cache (MAILSTREAM *stream,MESSAGECACHE *elt)
  {
  				/* already cached? */
!   if (LOCAL->msgno != elt->msgno) {
  				/* no, close current file */
      if (LOCAL->txt) fclose (LOCAL->txt);
      LOCAL->txt = NIL;
--- 640,646 ----
  unsigned long pop3_cache (MAILSTREAM *stream,MESSAGECACHE *elt)
  {
  				/* already cached? */
!   if (LOCAL->msgno != elt->msgno || elt->rfc822_size == 1) {
  				/* no, close current file */
      if (LOCAL->txt) fclose (LOCAL->txt);
      LOCAL->txt = NIL;
***************
*** 650,655 ****
--- 650,686 ----
  				/* load the cache */
        LOCAL->txt = netmsg_slurp (LOCAL->netstream,&elt->rfc822_size,
  				 &LOCAL->hdrsize);
+     }
+     else elt->deleted = T;
+   }
+   return LOCAL->hdrsize;
+ }
+ 
+ /* POP3 cache message header only
+  * Accepts: mail stream
+  *	    message number
+  * Returns: header size
+  */
+ 
+ unsigned long pop3_cache_header (MAILSTREAM *stream,MESSAGECACHE *elt)
+ {
+ 				/* already cached? */
+   if (LOCAL->msgno != elt->msgno) {
+     char tmp[MAILTMPLEN];
+ 				/* no, close current file */
+     if (LOCAL->txt) fclose (LOCAL->txt);
+     LOCAL->txt = NIL;
+     LOCAL->msgno = LOCAL->hdrsize = 0;
+     sprintf (tmp,"%lu 0",mail_uid (stream,elt->msgno));
+     if (pop3_send (stream,"TOP",tmp)) {
+       LOCAL->msgno = elt->msgno;/* set as current message number */
+ 				/* load the cache */
+       LOCAL->txt = netmsg_slurp (LOCAL->netstream,&elt->rfc822_size,
+ 				 &LOCAL->hdrsize);
+       elt->rfc822_size = 1;
+       /* because we don't really know, but we want mail_fetch_structure
+ 	 to think that it has enough info without calling dtb->text */
+       printf("rfc822_size = %d\n", elt->rfc822_size);
      }
      else elt->deleted = T;
    }
diff -c -N c-client.pure/pop3.h c-client/pop3.h
*** c-client.pure/pop3.h	Sat Feb  5 18:29:58 2000
--- c-client/pop3.h	Sat Feb  5 16:44:17 2000
***************
*** 80,85 ****
--- 80,86 ----
  		   long flags);
  long pop3_text (MAILSTREAM *stream,unsigned long msgno,STRING *bs,long flags);
  unsigned long pop3_cache (MAILSTREAM *stream,MESSAGECACHE *elt);
+ unsigned long pop3_cache_header (MAILSTREAM *stream,MESSAGECACHE *elt);
  long pop3_ping (MAILSTREAM *stream);
  void pop3_check (MAILSTREAM *stream);
  void pop3_expunge (MAILSTREAM *stream);
Binary files c-client.pure/pop3.o and c-client/pop3.o differ
Binary files c-client.pure/pseudo.o and c-client/pseudo.o differ
diff -c -N c-client.pure/rfc822.c c-client/rfc822.c
*** c-client.pure/rfc822.c	Sat Feb  5 18:29:54 2000
--- c-client/rfc822.c	Sat Feb  5 15:42:29 2000
***************
*** 109,114 ****
--- 109,137 ----
   *	    message body
   */
  
+ /*MAHOGANY: BEGIN OF PATCH: added the next block */
+ static char **rfc822_extraheaders_names = NULL;
+ static char **rfc822_extraheaders_values = NULL;
+ 
+ void rfc822_setextraheaders(char **names, char **values)
+ {
+    rfc822_extraheaders_names = names;
+    rfc822_extraheaders_values = values;
+ }
+ 
+ void rfc822_extraheaders_lines (char **header,ENVELOPE *env)
+ {
+    char **names = rfc822_extraheaders_names;
+    char **values = rfc822_extraheaders_values;
+    while(names && *names && values && *values)
+       sprintf ((*header += strlen (*header)),"%s%s: %s\015\012",
+                env->remail ? "ReSent-" : "",
+                *(names++),
+                *(values++)
+          );
+ }
+ /*MAHOGANY: END OF PATCH */
+ 
  void rfc822_header (char *header,ENVELOPE *env,BODY *body)
  {
    if (env->remail) {		/* if remailing */
***************
*** 135,140 ****
--- 158,167 ----
    rfc822_header_line (&header,"Message-ID",env,env->message_id);
    rfc822_header_line (&header,"Followup-to",env,env->followup_to);
    rfc822_header_line (&header,"References",env,env->references);
+ 
+ /*MAHOGANY: added this call:*/
+   rfc822_extraheaders_lines (&header,env);
+   
    if (body && !env->remail) {	/* not if remail or no body structure */
      strcat (header,"MIME-Version: 1.0\015\012");
      rfc822_write_body_header (&header,body);
***************
*** 204,215 ****
--- 231,253 ----
  	if (adr->next && adr->next->mailbox) strcat (dest,", ");
        }
      }
+ 
+ /*MAHOGANY: commented out the following bit as it caused problems:*/
+ #if 0
+     /* commented out: */
      else if (adr->mailbox) {	/* start of group? */
  				/* yes, write group name */
        rfc822_cat (dest,adr->mailbox,rspecials);
        strcat (dest,": ");	/* write group identifier */
        n++;			/* in a group */
      }
+ #else
+     /* my replacement (KB): */
+     else if (adr->mailbox) {	/* start of group? */
+ 				/* yes, write group name */
+       rfc822_cat (dest,adr->mailbox,rspecials);
+     }
+ #endif
      else if (n) {		/* must be end of group (but be paranoid) */
        strcat (dest,";");
  				/* no longer in that group */
***************
*** 246,251 ****
--- 284,292 ----
        strcat (dest,"@");	/* host delimiter */
        strcat (dest,adr->host);	/* write host name */
      }
+   }
+   else if(adr && adr->mailbox) {
+     rfc822_cat (dest,adr->mailbox,wspecials);
    }
  }
  
diff -c -N c-client.pure/rfc822.c.orig c-client/rfc822.c.orig
*** c-client.pure/rfc822.c.orig	Thu Jan  1 01:00:00 1970
--- c-client/rfc822.c.orig	Sat Feb  5 14:44:02 2000
***************
*** 0 ****
--- 1,1779 ----
+ /*
+  * Program:	RFC-822 routines (originally from SMTP)
+  *
+  * Author:	Mark Crispin
+  *		Networks and Distributed Computing
+  *		Computing & Communications
+  *		University of Washington
+  *		Administration Building, AG-44
+  *		Seattle, WA  98195
+  *		Internet: MRC@CAC.Washington.EDU
+  *
+  * Date:	27 July 1988
+  * Last Edited:	24 June 1998
+  *
+  * Sponsorship:	The original version of this work was developed in the
+  *		Symbolic Systems Resources Group of the Knowledge Systems
+  *		Laboratory at Stanford University in 1987-88, and was funded
+  *		by the Biomedical Research Technology Program of the National
+  *		Institutes of Health under grant number RR-00785.
+  *
+  * Original version Copyright 1988 by The Leland Stanford Junior University
+  * Copyright 1998 by the University of Washington
+  *
+  *  Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notices appear in all copies and that both the
+  * above copyright notices and this permission notice appear in supporting
+  * documentation, and that the name of the University of Washington or The
+  * Leland Stanford Junior University not be used in advertising or publicity
+  * pertaining to distribution of the software without specific, written prior
+  * permission.  This software is made available "as is", and
+  * THE UNIVERSITY OF WASHINGTON AND THE LELAND STANFORD JUNIOR UNIVERSITY
+  * DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD TO THIS SOFTWARE,
+  * INCLUDING WITHOUT LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+  * FITNESS FOR A PARTICULAR PURPOSE, AND IN NO EVENT SHALL THE UNIVERSITY OF
+  * WASHINGTON OR THE LELAND STANFORD JUNIOR UNIVERSITY BE LIABLE FOR ANY
+  * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+  * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+  * CONTRACT, TORT (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF
+  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  */
+ 
+ 
+ #include <ctype.h>
+ #include <stdio.h>
+ #include <time.h>
+ #include "mail.h"
+ #include "osdep.h"
+ #include "rfc822.h"
+ #include "misc.h"
+ 
+ /* RFC-822 static data */
+ 
+ 
+ char *errhst = ERRHOST;		/* syntax error host string */
+ 
+ 
+ /* Body formats constant strings, must match definitions in mail.h */
+ 
+ char *body_types[TYPEMAX+1] = {
+   "TEXT", "MULTIPART", "MESSAGE", "APPLICATION", "AUDIO", "IMAGE", "VIDEO",
+   "MODEL", "X-UNKNOWN"
+ };
+ 
+ 
+ char *body_encodings[ENCMAX+1] = {
+   "7BIT", "8BIT", "BINARY", "BASE64", "QUOTED-PRINTABLE", "X-UNKNOWN"
+ };
+ 
+ 
+ /* Token delimiting special characters */
+ 
+ 				/* full RFC-822 specials */
+ const char *rspecials =  "()<>@,;:\\\"[].";
+ 				/* body token specials */
+ const char *tspecials = " ()<>@,;:\\\"[]./?=";
+ 
+ 
+ /* Once upon a time, CSnet had a mailer which assigned special semantics to
+  * dot in e-mail addresses.  For the sake of that mailer, dot was added to
+  * the RFC-822 definition of `specials', even though it had numerous bad side
+  * effects:
+  *   1)	It broke mailbox names on systems which had dots in user names, such as
+  *	Multics and TOPS-20.  RFC-822's syntax rules require that `Admin . MRC'
+  *	be considered equivalent to `Admin.MRC'.  Fortunately, few people ever
+  *	tried this in practice.
+  *   2) It required that all personal names with an initial be quoted, a widely
+  *	detested user interface misfeature.
+  *   3)	It made the parsing of host names be non-atomic for no good reason.
+  * To work around these problems, the following alternate specials lists are
+  * defined.  hspecials and wspecials are used in lieu of rspecials, and
+  * ptspecials are used in lieu of tspecials.  These alternate specials lists
+  * make the parser work a lot better in the real world.  It ain't politically
+  * correct, but it lets the users get their job done!
+  */
+ 
+ 				/* parse-word specials */
+ const char *wspecials = " ()<>@,;:\\\"[]";
+ 				/* parse-token specials for parsing */
+ const char *ptspecials = " ()<>@,;:\\\"[]/?=";
+ 
+ /* RFC822 writing routines */
+ 
+ 
+ /* Write RFC822 header from message structure
+  * Accepts: scratch buffer to write into
+  *	    message envelope
+  *	    message body
+  */
+ 
+ void rfc822_header (char *header,ENVELOPE *env,BODY *body)
+ {
+   if (env->remail) {		/* if remailing */
+     long i = strlen (env->remail);
+     strcpy (header,env->remail);/* start with remail header */
+ 				/* flush extra blank line */
+     if (i > 4 && header[i-4] == '\015') header[i-2] = '\0';
+   }
+   else *header = '\0';		/* else initialize header to null */
+   rfc822_header_line (&header,"Newsgroups",env,env->newsgroups);
+   rfc822_header_line (&header,"Date",env,env->date);
+   rfc822_address_line (&header,"From",env,env->from);
+   rfc822_address_line (&header,"Sender",env,env->sender);
+   rfc822_address_line (&header,"Reply-To",env,env->reply_to);
+   rfc822_header_line (&header,"Subject",env,env->subject);
+   if (env->bcc && !(env->to || env->cc))
+     strcat (header,"To: undisclosed recipients: ;\015\012");
+   rfc822_address_line (&header,"To",env,env->to);
+   rfc822_address_line (&header,"cc",env,env->cc);
+ /* bcc's are never written...
+  * rfc822_address_line (&header,"bcc",env,env->bcc);
+  */
+   rfc822_header_line (&header,"In-Reply-To",env,env->in_reply_to);
+   rfc822_header_line (&header,"Message-ID",env,env->message_id);
+   rfc822_header_line (&header,"Followup-to",env,env->followup_to);
+   rfc822_header_line (&header,"References",env,env->references);
+   if (body && !env->remail) {	/* not if remail or no body structure */
+     strcat (header,"MIME-Version: 1.0\015\012");
+     rfc822_write_body_header (&header,body);
+   }
+   strcat (header,"\015\012");	/* write terminating blank line */
+ }
+ 
+ /* Write RFC822 address from header line
+  * Accepts: pointer to destination string pointer
+  *	    pointer to header type
+  *	    message to interpret
+  *	    address to interpret
+  */
+ 
+ void rfc822_address_line (char **header,char *type,ENVELOPE *env,ADDRESS *adr)
+ {
+   char *s = (*header += strlen (*header));
+   if (adr) {			/* do nothing if no addresses */
+     if (env && env->remail) strcat (s,"ReSent-");
+     strcat (s,type);		/* write header name */
+     strcat (s,": ");
+     s = rfc822_write_address_full (s + strlen (s),adr,*header);
+ 				/* tie off header line */
+     *s++ = '\015'; *s++ = '\012'; *s = '\0';
+     *header = s;		/* set return value */
+   }
+ }
+ 
+ 
+ /* Write RFC822 text from header line
+  * Accepts: pointer to destination string pointer
+  *	    pointer to header type
+  *	    message to interpret
+  *	    pointer to text
+  */
+ 
+ void rfc822_header_line (char **header,char *type,ENVELOPE *env,char *text)
+ {
+   if (text) sprintf ((*header += strlen (*header)),"%s%s: %s\015\012",
+ 		     env->remail ? "ReSent-" : "",type,text);
+ }
+ 
+ /* Write RFC822 address list
+  * Accepts: pointer to destination string
+  *	    address to interpret
+  *	    header base if pretty-printing
+  * Returns: end of destination string
+  */
+ 
+ 				/* RFC822 continuation, must start with CRLF */
+ #define RFC822CONT "\015\012    "
+ 
+ char *rfc822_write_address_full (char *dest,ADDRESS *adr,char *base)
+ {
+   long i,n;
+   for (n = 0; adr; adr = adr->next) {
+     if (adr->host) {		/* ordinary address? */
+       if (!(base && n)) {	/* only write if exact form or not in group */
+ 				/* simple case? */
+ 	if (!(adr->personal || adr->adl)) rfc822_address (dest,adr);
+ 	else {			/* no, must use phrase <route-addr> form */
+ 	  if (adr->personal) rfc822_cat (dest,adr->personal,rspecials);
+ 	  strcat (dest," <");	/* write address delimiter */
+ 	  rfc822_address (dest,adr);
+ 	  strcat (dest,">");	/* closing delimiter */
+ 	}
+ 	if (adr->next && adr->next->mailbox) strcat (dest,", ");
+       }
+     }
+     else if (adr->mailbox) {	/* start of group? */
+ 				/* yes, write group name */
+       rfc822_cat (dest,adr->mailbox,rspecials);
+       strcat (dest,": ");	/* write group identifier */
+       n++;			/* in a group */
+     }
+     else if (n) {		/* must be end of group (but be paranoid) */
+       strcat (dest,";");
+       n--;			/* no longer in that group */
+     }
+     i = strlen (dest);		/* length of what we just wrote */
+ 				/* write continuation if doesn't fit */
+     if (base && (dest > (base + 4)) && ((dest + i) > (base + 78))) {
+       memmove (dest + sizeof (RFC822CONT) - 1,dest,i + 1);
+       memcpy (dest,RFC822CONT,sizeof (RFC822CONT) - 1);
+       base = dest + 2;		/* new base */
+       dest += i + sizeof (RFC822CONT) - 1;
+     }
+     else dest += i;		/* new end of string */
+   }
+   return dest;			/* return end of string */
+ }
+ 
+ /* Write RFC822 route-address to string
+  * Accepts: pointer to destination string
+  *	    address to interpret
+  */
+ 
+ void rfc822_address (char *dest,ADDRESS *adr)
+ {
+   if (adr && adr->host) {	/* no-op if no address */
+     if (adr->adl) {		/* have an A-D-L? */
+       strcat (dest,adr->adl);
+       strcat (dest,":");
+     }
+ 				/* write mailbox name */
+     rfc822_cat (dest,adr->mailbox,wspecials);
+     if (*adr->host != '@') {	/* unless null host (HIGHLY discouraged!) */
+       strcat (dest,"@");	/* host delimiter */
+       strcat (dest,adr->host);	/* write host name */
+     }
+   }
+ }
+ 
+ 
+ /* Concatenate RFC822 string
+  * Accepts: pointer to destination string
+  *	    pointer to string to concatenate
+  *	    list of special characters
+  */
+ 
+ void rfc822_cat (char *dest,char *src,const char *specials)
+ {
+   char *s;
+   if (strpbrk (src,specials)) {	/* any specials present? */
+     strcat (dest,"\"");		/* opening quote */
+ 				/* truly bizarre characters in there? */
+     while (s = strpbrk (src,"\\\"")) {
+       strncat (dest,src,s-src);	/* yes, output leader */
+       strcat (dest,"\\");	/* quoting */
+       strncat (dest,s,1);	/* output the bizarre character */
+       src = ++s;		/* continue after the bizarre character */
+     }
+     if (*src) strcat (dest,src);/* output non-bizarre string */
+     strcat (dest,"\"");		/* closing quote */
+   }
+   else strcat (dest,src);	/* otherwise it's the easy case */
+ }
+ 
+ /* Write body content header
+  * Accepts: pointer to destination string pointer
+  *	    pointer to body to interpret
+  */
+ 
+ void rfc822_write_body_header (char **dst,BODY *body)
+ {
+   char *s;
+   STRINGLIST *stl;
+   PARAMETER *param = body->parameter;
+   sprintf (*dst += strlen (*dst),"Content-Type: %s",body_types[body->type]);
+   s = body->subtype ? body->subtype : rfc822_default_subtype (body->type);
+   sprintf (*dst += strlen (*dst),"/%s",s);
+   if (param) do {
+     sprintf (*dst += strlen (*dst),"; %s=",param->attribute);
+     rfc822_cat (*dst,param->value,tspecials);
+   } while (param = param->next);
+   else if (body->type == TYPETEXT) strcat (*dst,"; CHARSET=US-ASCII");
+   strcpy (*dst += strlen (*dst),"\015\012");
+   if (body->encoding)		/* note: encoding 7BIT never output! */
+     sprintf (*dst += strlen (*dst),"Content-Transfer-Encoding: %s\015\012",
+ 	     body_encodings[body->encoding]);
+   if (body->id) sprintf (*dst += strlen (*dst),"Content-ID: %s\015\012",
+ 			 body->id);
+   if (body->description)
+     sprintf (*dst += strlen (*dst),"Content-Description: %s\015\012",
+ 	     body->description);
+   if (body->md5)
+     sprintf (*dst += strlen (*dst),"Content-MD5: %s\015\012",body->md5);
+   if (stl = body->language) {
+     strcpy (*dst += strlen (*dst),"Content-Language: ");
+     do {
+       rfc822_cat (*dst,(char *) stl->text.data,tspecials);
+       if (stl = stl->next) strcat (*dst += strlen (*dst),", ");
+     }
+     while (stl);
+     strcpy (*dst += strlen (*dst),"\015\012");
+   }
+   if (body->disposition.type) {
+     sprintf (*dst += strlen (*dst),"Content-Disposition: %s",
+ 	     body->disposition.type);
+     if (param = body->disposition.parameter) do {
+       sprintf (*dst += strlen (*dst),"; %s=",param->attribute);
+       rfc822_cat (*dst,param->value,tspecials);
+     } while (param = param->next);
+     strcpy (*dst += strlen (*dst),"\015\012");
+   }
+ }
+ 
+ 
+ /* Subtype defaulting (a no-no, but regretably necessary...)
+  * Accepts: type code
+  * Returns: default subtype name
+  */
+ 
+ char *rfc822_default_subtype (unsigned short type)
+ {
+   switch (type) {
+   case TYPETEXT:		/* default is TEXT/PLAIN */
+     return "PLAIN";
+   case TYPEMULTIPART:		/* default is MULTIPART/MIXED */
+     return "MIXED";
+   case TYPEMESSAGE:		/* default is MESSAGE/RFC822 */
+     return "RFC822";
+   case TYPEAPPLICATION:		/* default is APPLICATION/OCTET-STREAM */
+     return "OCTET-STREAM";
+   case TYPEAUDIO:		/* default is AUDIO/BASIC */
+     return "BASIC";
+   default:			/* others have no default subtype */
+     return "UNKNOWN";
+   }
+ }
+ 
+ /* RFC822 parsing routines */
+ 
+ 
+ /* Parse an RFC822 message
+  * Accepts: pointer to return envelope
+  *	    pointer to return body
+  *	    pointer to header
+  *	    header byte count
+  *	    pointer to body stringstruct
+  *	    pointer to local host name
+  *	    source driver flags
+  */
+ 
+ void rfc822_parse_msg (ENVELOPE **en,BODY **bdy,char *s,unsigned long i,
+ 		       STRING *bs,char *host,unsigned long flags)
+ {
+   char c,*t,*d;
+   char *tmp = (char *) fs_get ((size_t) i + 100);
+   ENVELOPE *env = (*en = mail_newenvelope ());
+   BODY *body = bdy ? (*bdy = mail_newbody ()) : NIL;
+   long MIMEp = -1;		/* flag that MIME semantics are in effect */
+   long PathP = NIL;		/* flag that a Path: was seen */
+   while (i && *s != '\n') {	/* until end of header */
+     t = tmp;			/* initialize buffer pointer */
+     c = ' ';			/* and previous character */
+     while (i && c) {		/* collect text until logical end of line */
+       switch (c = *s++) {	/* slurp a character */
+       case '\015':		/* return, possible end of logical line */
+ 	if (*s == '\n') break;	/* ignore if LF follows */
+       case '\012':		/* LF, possible end of logical line */
+ 				/* tie off unless next line starts with WS */
+ 	if (*s != ' ' && *s != '\t') *t++ = c = '\0';
+ 	break;
+       case '\t':		/* tab */
+ 	*t++ = ' ';		/* coerce to space */
+ 	break;
+       default:			/* all other characters */
+ 	*t++ = c;		/* insert the character into the line */
+ 	break;
+       }
+       if (!--i) *t++ = '\0';	/* see if end of header */
+     }
+ 
+ 				/* find header item type */
+     if (t = d = strchr (tmp,':')) {
+       *d++ = '\0';		/* tie off header item, point at its data */
+       while (*d == ' ') d++;	/* flush whitespace */
+       while ((tmp < t--) && (*t == ' ')) *t = '\0';
+       switch (*ucase (tmp)) {	/* dispatch based on first character */
+       case '>':			/* possible >From: */
+ 	if (!strcmp (tmp+1,"FROM")) rfc822_parse_adrlist (&env->from,d,host);
+ 	break;
+       case 'B':			/* possible bcc: */
+ 	if (!strcmp (tmp+1,"CC")) rfc822_parse_adrlist (&env->bcc,d,host);
+ 	break;
+       case 'C':			/* possible cc: or Content-<mumble>*/
+ 	if (!strcmp (tmp+1,"C")) rfc822_parse_adrlist (&env->cc,d,host);
+ 	else if ((tmp[1] == 'O') && (tmp[2] == 'N') && (tmp[3] == 'T') &&
+ 		 (tmp[4] == 'E') && (tmp[5] == 'N') && (tmp[6] == 'T') &&
+ 		 (tmp[7] == '-') && body)
+ 	  switch (MIMEp) {
+ 	  case -1:		/* unknown if MIME or not */
+ 	    if (MIMEp = search ((unsigned char *) s-1,i,
+ 				(unsigned char *)"\012MIME-Version",
+ 				(long) 13))
+ 	  case T:		/* definitely MIME */
+ 	      rfc822_parse_content_header (body,tmp+8,d);
+ 	  }
+ 	break;
+       case 'D':			/* possible Date: */
+ 	if (!env->date && !strcmp (tmp+1,"ATE")) env->date = cpystr (d);
+ 	break;
+       case 'F':			/* possible From: */
+ 	if (!strcmp (tmp+1,"ROM")) rfc822_parse_adrlist (&env->from,d,host);
+ 	else if (!strcmp (tmp+1,"OLLOWUP-TO")) {
+ 	  t = env->followup_to = (char *) fs_get (1 + strlen (d));
+ 	  while (c = *d++) if (c != ' ') *t++ = c;
+ 	  *t++ = '\0';
+ 	}
+ 	break;
+       case 'I':			/* possible In-Reply-To: */
+ 	if (!env->in_reply_to && !strcmp (tmp+1,"N-REPLY-TO"))
+ 	  env->in_reply_to = cpystr (d);
+ 	break;
+       case 'M':			/* possible Message-ID: or MIME-Version: */
+ 	if (!env->message_id && !strcmp (tmp+1,"ESSAGE-ID"))
+ 	  env->message_id = cpystr (d);
+ 	else if (!strcmp (tmp+1,"IME-VERSION")) {
+ 				/* tie off at end of phrase */
+ 	  if (t = rfc822_parse_phrase (d)) *t = '\0';
+ 	  rfc822_skipws (&d);	/* skip whitespace */
+ 				/* known version? */
+ 	  if (strcmp (d,"1.0") && strcmp (d,"RFC-XXXX"))
+ 	    mm_log ("Warning: message has unknown MIME version",PARSE);
+ 	  MIMEp = T;		/* note that we are MIME */
+ 	}
+ 	break;
+ 
+       case 'N':			/* possible Newsgroups: */
+ 	if (!env->newsgroups && !strcmp (tmp+1,"EWSGROUPS")) {
+ 	  t = env->newsgroups = (char *) fs_get (1 + strlen (d));
+ 	  while (c = *d++) if (c != ' ') *t++ = c;
+ 	  *t++ = '\0';
+ 	}
+ 	break;
+       case 'P':			/* possible Path: */
+ 	if (!strcmp (tmp+1,"ATH")) PathP = T;
+ 	break;
+       case 'R':			/* possible Reply-To: */
+ 	if (!strcmp (tmp+1,"EPLY-TO"))
+ 	  rfc822_parse_adrlist (&env->reply_to,d,host);
+ 	else if (!env->references && !strcmp (tmp+1,"EFERENCES"))
+ 	  env->references = cpystr (d);
+ 	break;
+       case 'S':			/* possible Subject: or Sender: */
+ 	if (!env->subject && !strcmp (tmp+1,"UBJECT"))
+ 	  env->subject = cpystr (d);
+ 	else if (!strcmp (tmp+1,"ENDER"))
+ 	  rfc822_parse_adrlist (&env->sender,d,host);
+ 	break;
+       case 'T':			/* possible To: */
+ 	if (!strcmp (tmp+1,"O")) rfc822_parse_adrlist (&env->to,d,host);
+ 	break;
+       default:
+ 	break;
+       }
+     }
+   }
+ 
+   /* We require a Path: header and/or a Message-ID belonging to a known
+    * winning mail program, in order to believe Newsgroups:.  This is because
+    * of the unfortunate existance of certain cretins who believe that it
+    * is reasonable to transmit messages via SMTP with a "Newsgroups" header
+    * that were not actually posted to any of the named newsgroups.
+    * The authors of other high-quality email/news software are encouraged to
+    * use similar methods to indentify messages as coming from their software,
+    * and having done so, to tell us so they too can be blessed in this list.
+    *
+    * May 1998 update: as was predicted back in March 1995 when this kludge was
+    * first added, mail/news unifying programs are now the norm.  However, the
+    * encouragement in the previous paragraph didn't take, and there's no good
+    * way to determine bogons accurately.  Consequently, we no longer remove the
+    * newsgroup information from the envelope on the bogon test; we just light
+    * a bogon bit and let the main program worry about what to do.
+    */
+   if (env->newsgroups && !PathP && env->message_id &&
+       strncmp (env->message_id,"<Pine.",6) &&
+       strncmp (env->message_id,"<MS-C.",6) &&
+       strncmp (env->message_id,"<MailManager.",13) &&
+       strncmp (env->message_id,"<EasyMail.",11) &&
+       strncmp (env->message_id,"<ML-",4)) env->ngbogus = T;
+   fs_give ((void **) &tmp);	/* done with scratch buffer */
+ 				/* default Sender: and Reply-To: to From: */
+   if (!env->sender) env->sender = rfc822_cpy_adr (env->from);
+   if (!env->reply_to) env->reply_to = rfc822_cpy_adr (env->from);
+ 				/* now parse the body */
+   if (body) rfc822_parse_content (body,bs,host,flags);
+ }
+ 
+ /* Parse a message body content
+  * Accepts: pointer to body structure
+  *	    body string
+  *	    pointer to local host name
+  *	    source driver flags
+  */
+ 
+ void rfc822_parse_content (BODY *body,STRING *bs,char *h,unsigned long flags)
+ {
+   char c,c1,*s,*s1;
+   int f;
+   unsigned long i,j,k,m;
+   PARAMETER *param;
+   PART *part = NIL;
+   if (!body->subtype)		/* default subtype if still unknown */
+     body->subtype = cpystr (rfc822_default_subtype (body->type));
+ 				/* note offset and sizes */
+   body->contents.offset = GETPOS (bs);
+ 				/* note internal body size in all cases */
+   body->size.bytes = body->contents.text.size = i = SIZE (bs);
+   if (!(flags & DR_CRLF)) body->size.bytes = strcrlflen (bs);
+   switch (body->type) {		/* see if anything else special to do */
+   case TYPETEXT:		/* text content */
+     if (!body->parameter) {	/* default parameters */
+       body->parameter = mail_newbody_parameter ();
+       body->parameter->attribute = cpystr ("CHARSET");
+       body->parameter->value = cpystr ("US-ASCII");
+     }
+ 				/* count number of lines */
+     while (i--) if ((SNX (bs)) == '\n') body->size.lines++;
+     break;
+ 
+   case TYPEMESSAGE:		/* encapsulated message */
+     body->nested.msg = mail_newmsg ();
+ 				/* encapsulated RFC-822 message? */
+     if (!strcmp (body->subtype,"RFC822")) {
+       switch (body->encoding) {	/* make sure valid encoding */
+       case ENC7BIT:		/* these are valid nested encodings */
+       case ENC8BIT:
+       case ENCBINARY:
+ 	break;
+       default:
+ 	mm_log ("Ignoring nested encoding of message contents",PARSE);
+       }
+ 				/* hunt for blank line */
+       for (c = '\012',j = 0; (i > j) && ((c != '\012') || (CHR(bs) != '\012'));
+ 	   j++) if ((c1 = SNX (bs)) != '\015') c = c1;
+       if (i > j) {		/* unless no more text */
+ 	c1 = SNX (bs);		/* body starts here */
+ 	j++;			/* advance count */
+       }
+ 				/* note body text offset and header size */
+       body->nested.msg->header.text.size = j;
+       body->nested.msg->text.text.size = body->contents.text.size - j;
+       body->nested.msg->text.offset = GETPOS (bs);
+       body->nested.msg->full.offset = body->nested.msg->header.offset =
+ 	body->contents.offset;
+       body->nested.msg->full.text.size = body->contents.text.size;
+ 				/* copy header string */
+       SETPOS (bs,body->contents.offset);
+       s = (char *) fs_get ((size_t) j + 1);
+       for (s1 = s,k = j; k--; *s1++ = SNX (bs));
+       s[j] = '\0';		/* tie off string (not really necessary) */
+ 				/* now parse the body */
+       rfc822_parse_msg (&body->nested.msg->env,&body->nested.msg->body,s,j,bs,
+ 			h,flags);
+       fs_give ((void **) &s);	/* free header string */
+ 				/* restore position */
+       SETPOS (bs,body->contents.offset);
+     }
+ 				/* count number of lines */
+     while (i--) if (SNX (bs) == '\n') body->size.lines++;
+     break;
+   case TYPEMULTIPART:		/* multiple parts */
+     switch (body->encoding) {	/* make sure valid encoding */
+     case ENC7BIT:		/* these are valid nested encodings */
+     case ENC8BIT:
+     case ENCBINARY:
+       break;
+     default:
+       mm_log ("Ignoring nested encoding of multipart contents",PARSE);
+     }
+ 				/* remember if digest */
+     f = !strcmp (body->subtype,"DIGEST");
+ 				/* find cookie */
+     for (s1 = NIL,param = body->parameter; param && !s1; param = param->next)
+       if (!strcmp (param->attribute,"BOUNDARY")) s1 = param->value;
+     if (!(s1 && *s1)) s1 = "-";	/* yucky default */
+     j = strlen (s1);		/* length of cookie and header */
+     c = '\012';			/* initially at beginning of line */
+ 
+     while (i > j) {		/* examine data */
+       if (m = GETPOS (bs)) m--;	/* get position in front of character */
+       switch (c) {		/* examine each line */
+       case '\015':		/* handle CRLF form */
+ 	if (CHR (bs) == '\012'){/* following LF? */
+ 	  c = SNX (bs); i--;	/* yes, slurp it */
+ 	}
+       case '\012':		/* at start of a line, start with -- ? */
+ 	if (i-- && ((c = SNX (bs)) == '-') && i-- && ((c = SNX (bs)) == '-')) {
+ 				/* see if cookie matches */
+ 	  for (k = j,s = s1; i-- && *s++ == (c = SNX (bs)) && --k;);
+ 	  if (k) break;		/* strings didn't match if non-zero */
+ 				/* look at what follows cookie */
+ 	  if (i && i--) switch (c = SNX (bs)) {
+ 	  case '-':		/* at end if two dashes */
+ 	    if ((i && i--) && ((c = SNX (bs)) == '-') &&
+ 		((i && i--) ? (((c = SNX (bs)) == '\015') || (c=='\012')):T)) {
+ 				/* if have a final part calculate its size */
+ 	      if (part) part->body.mime.text.size =
+ 		(m > part->body.mime.offset) ? (m - part->body.mime.offset) :0;
+ 	      part = NIL; i = 1; /* terminate scan */
+ 	    }
+ 	    break;
+ 	  case '\015':		/* handle CRLF form */
+ 	    if (i && CHR (bs) == '\012') {
+ 	      c = SNX (bs); i--;/* yes, slurp it */
+ 	    }
+ 	  case '\012':		/* new line */
+ 	    if (part) {		/* calculate size of previous */
+ 	      part->body.mime.text.size =
+ 		(m > part->body.mime.offset) ? (m-part->body.mime.offset) : 0;
+ 				/* instantiate next */
+ 	      part = part->next = mail_newbody_part ();
+ 	    }			/* otherwise start new list */
+ 	    else part = body->nested.part = mail_newbody_part ();
+ 				/* digest has a different default */
+ 	    if (f) part->body.type = TYPEMESSAGE;
+ 				/* note offset from main body */
+ 	    part->body.mime.offset = GETPOS (bs);
+ 	    break;
+ 	  default:		/* whatever it was it wasn't valid */
+ 	    break;
+ 	  }
+ 	}
+ 	break;
+       default:			/* not at a line */
+ 	c = SNX (bs); i--;	/* get next character */
+ 	break;
+       }
+     }
+ 
+ 				/* calculate size of any final part */
+     if (part) part->body.mime.text.size = i +
+       ((GETPOS(bs) > part->body.mime.offset) ?
+        (GETPOS(bs) - part->body.mime.offset) : 0);
+ 				/* make a scratch buffer */
+     s1 = (char *) fs_get ((size_t) (k = MAILTMPLEN));
+ 				/* parse non-empty body parts */
+     for (part = body->nested.part; part; part = part->next) {
+       if (i = part->body.mime.text.size) {
+ 				/* move to that part of the body */
+ 	SETPOS (bs,part->body.mime.offset);
+ 				/* until end of header */
+ 	while (i && ((c = CHR (bs)) != '\015') && (c != '\012')) {
+ 				/* collect text until logical end of line */
+ 	  for (j = 0,c = ' '; c; ) {
+ 				/* make sure buffer big enough */
+ 	    if (j > (k - 10)) fs_resize ((void *) &s1,k += MAILTMPLEN);
+ 	    switch (c1 = SNX (bs)) {
+ 	    case '\015':	/* return */
+ 	      if (i && (CHR (bs) == '\012')) {
+ 		c1 = SNX (bs);	/* eat any LF following */
+ 		i--;
+ 	      }
+ 	    case '\012':	/* newline, possible end of logical line */
+ 				/* tie off unless continuation */
+ 	      if (!i || ((CHR (bs) != ' ') && (CHR (bs) != '\t')))
+ 		s1[j] = c = '\0';
+ 	      break;
+ 	    case '\t':		/* tab */
+ 	    case ' ':		/* insert whitespace if not already there */
+ 	      if (c != ' ') s1[j++] = c = ' ';
+ 	      break;
+ 	    default:		/* all other characters */
+ 	      s1[j++] = c = c1;	/* insert the character into the line */
+ 	      break;
+ 	    }
+ 				/* end of data ties off the header */
+ 	    if (!--i) s1[j++] = c = '\0';
+ 	  }
+ 
+ 				/* find header item type */
+ 	  if (((s1[0] == 'C') || (s1[0] == 'c')) &&
+ 	      ((s1[1] == 'O') || (s1[1] == 'o')) &&
+ 	      ((s1[2] == 'N') || (s1[2] == 'n')) &&
+ 	      ((s1[3] == 'T') || (s1[3] == 't')) &&
+ 	      ((s1[4] == 'E') || (s1[4] == 'e')) &&
+ 	      ((s1[5] == 'N') || (s1[5] == 'n')) &&
+ 	      ((s1[6] == 'T') || (s1[6] == 't')) &&
+ 	      (s1[7] == '-') && (s = strchr (s1+8,':'))) {
+ 				/* tie off and flush whitespace */
+ 	    for (*s++ = '\0'; *s == ' '; s++);
+ 				/* parse the header */
+ 	    rfc822_parse_content_header (&part->body,ucase (s1+8),s);
+ 	  }
+ 	}
+ 				/* skip header trailing (CR)LF */
+ 	if (i && (CHR (bs) =='\015')) {i--; c1 = SNX (bs);}
+ 	if (i && (CHR (bs) =='\012')) {i--; c1 = SNX (bs);}
+ 	j = bs->size;		/* save upper level size */
+ 				/* set offset for next level, fake size to i */
+ 	bs->size = GETPOS (bs) + i;
+ 	part->body.mime.text.size -= i;
+ 				/* now parse it */
+ 	rfc822_parse_content (&part->body,bs,h,flags);
+ 	bs->size = j;		/* restore current level size */
+       }
+       else part->body.subtype =	/* default subtype if necessary */
+ 	cpystr (rfc822_default_subtype (part->body.type));
+     }
+     fs_give ((void **) &s1);	/* finished with scratch buffer */
+     break;
+   default:			/* nothing special to do in any other case */
+     break;
+   }
+ }
+ 
+ /* Parse RFC822 body content header
+  * Accepts: body to write to
+  *	    possible content name
+  *	    remainder of header
+  */
+ 
+ void rfc822_parse_content_header (BODY *body,char *name,char *s)
+ {
+   char c,*t;
+   long i;
+   STRINGLIST *stl;
+ 				/* flush whitespace */
+   if (t = strchr (name,' ')) *t = '\0';
+   switch (*name) {		/* see what kind of content */
+   case 'I':			/* possible Content-ID */
+     if (!(strcmp (name+1,"D") || body->id)) body->id = cpystr (s);
+     break;
+   case 'D':			/* possible Content-Description */
+     if (!(strcmp (name+1,"ESCRIPTION") || body->description))
+       body->description = cpystr (s);
+     if (!(strcmp (name+1,"ISPOSITION") || body->disposition.type)) {
+ 				/* get type word */
+       if (!(name = rfc822_parse_word (s,ptspecials))) break;
+       c = *name;		/* remember delimiter */
+       *name = '\0';		/* tie off type */
+       body->disposition.type = ucase (cpystr (s));
+       *name = c;		/* restore delimiter */
+       rfc822_skipws (&name);	/* skip whitespace */
+       rfc822_parse_parameter (&body->disposition.parameter,name);
+     }
+     break;
+   case 'L':			/* possible Content-Language */
+     if (!(strcmp (name+1,"ANGUAGE") || body->language)) {
+       stl = NIL;		/* process languages */
+       while (s && (name = rfc822_parse_word (s,ptspecials))) {
+ 	c = *name;		/* save delimiter */
+ 	*name = '\0';		/* tie off subtype */
+ 	if (stl) stl = stl->next = mail_newstringlist ();
+ 	else stl = body->language = mail_newstringlist ();
+ 	stl->text.data = (unsigned char *) ucase (cpystr (s));
+ 	stl->text.size = strlen ((char *) stl->text.data);
+ 	*name = c;		/* restore delimiter */
+ 	rfc822_skipws (&name);	/* skip whitespace */
+ 	if (*name == ',') {	/* any more languages? */
+ 	  s = ++name;		/* advance to it them */
+ 	  rfc822_skipws (&s);
+ 	}
+ 	else s = NIL;		/* bogus or end of list */
+       }
+     }
+     break;
+   case 'M':			/* possible Content-MD5 */
+     if (!(strcmp (name+1,"D5") || body->md5)) body->md5 = cpystr (s);
+     break;
+ 
+   case 'T':			/* possible Content-Type/Transfer-Encoding */
+     if (!(strcmp (name+1,"YPE") || body->subtype || body->parameter)) {
+ 				/* get type word */
+       if (!(name = rfc822_parse_word (s,ptspecials))) break;
+       c = *name;		/* remember delimiter */
+       *name = '\0';		/* tie off type */
+       ucase (s);		/* search for body type */
+       for (i=0; (i<=TYPEMAX) && body_types[i] && strcmp(s,body_types[i]); i++);
+       if (i > TYPEMAX) body->type = TYPEOTHER;
+       else {			/* if empty slot, assign it to this type */
+ 	if (!body_types[i]) body_types[i] = cpystr (s);
+ 	body->type = (unsigned short) i;
+       }
+       *name = c;		/* restore delimiter */
+       rfc822_skipws (&name);	/* skip whitespace */
+       if ((*name == '/') &&	/* subtype? */
+ 	  (name = rfc822_parse_word ((s = ++name),ptspecials))) {
+ 	c = *name;		/* save delimiter */
+ 	*name = '\0';		/* tie off subtype */
+ 	rfc822_skipws (&s);	/* copy subtype */
+ 	if (s) body->subtype = ucase (cpystr (s));
+ 	*name = c;		/* restore delimiter */
+ 	rfc822_skipws (&name);	/* skip whitespace */
+       }
+       else {			/* no subtype */
+ 	if (!name) {		/* did the fool have a subtype delimiter? */
+ 	  name = s;		/* barf, restore pointer */
+ 	  rfc822_skipws (&name);/* skip leading whitespace */
+ 	}
+       }
+       rfc822_parse_parameter (&body->parameter,name);
+     }
+     else if (!strcmp (name+1,"RANSFER-ENCODING")) {
+ 				/* flush out any confusing whitespace */
+       if (t = strchr (ucase (s),' ')) *t = '\0';
+ 				/* search for body encoding */
+       for (i = 0; (i <= ENCMAX) && body_encodings[i] &&
+ 	   strcmp (s,body_encodings[i]); i++);
+       if (i > ENCMAX) body->type = ENCOTHER;
+       else {			/* if empty slot, assign it to this type */
+ 	if (!body_encodings[i]) body_encodings[i] = cpystr (s);
+ 	body->encoding = (unsigned short) i;
+       }
+     }
+     break;
+   default:			/* otherwise unknown */
+     break;
+   }
+ }
+ 
+ /* Parse RFC822 body parameter list
+  * Accepts: parameter list to write to
+  *	    text of list
+  */
+ 
+ void rfc822_parse_parameter (PARAMETER **par,char *text)
+ {
+   char c,*s,tmp[MAILTMPLEN];
+   PARAMETER *param = NIL;
+ 				/* parameter list? */
+   while (text && (*text == ';') &&
+ 	 (text = rfc822_parse_word ((s = ++text),ptspecials))) {
+     c = *text;			/* remember delimiter */
+     *text = '\0';		/* tie off attribute name */
+     rfc822_skipws (&s);		/* skip leading attribute whitespace */
+     if (!*s) *text = c;		/* must have an attribute name */
+     else {			/* instantiate a new parameter */
+       if (*par) param = param->next = mail_newbody_parameter ();
+       else param = *par = mail_newbody_parameter ();
+       param->attribute = ucase (cpystr (s));
+       *text = c;		/* restore delimiter */
+       rfc822_skipws (&text);	/* skip whitespace before equal sign */
+       if ((*text != '=') ||	/* missing value is a no-no too */
+ 	  !(text = rfc822_parse_word ((s = ++text),ptspecials)))
+ 	param->value = cpystr ("UNKNOWN_PARAMETER_VALUE");
+       else {			/* good, have equals sign */
+ 	c = *text;		/* remember delimiter */
+ 	*text = '\0';		/* tie off value */
+ 	rfc822_skipws (&s);	/* skip leading value whitespace */
+ 	if (*s) param->value = rfc822_cpy (s);
+ 	*text = c;		/* restore delimiter */
+ 	rfc822_skipws (&text);
+       }
+     }
+   }
+   if (!text) {			/* must be end of poop */
+     if (param && param->attribute)
+       sprintf (tmp,"Missing parameter value: %.80s",param->attribute);
+     else strcpy (tmp,"Missing parameter");
+     mm_log (tmp,PARSE);
+   }
+   else if (*text) {		/* must be end of poop */
+     sprintf (tmp,"Unexpected characters at end of parameters: %.80s",text);
+     mm_log (tmp,PARSE);
+   }
+ }
+ 
+ /* Parse RFC822 address list
+  * Accepts: address list to write to
+  *	    input string
+  *	    default host name
+  */
+ 
+ void rfc822_parse_adrlist (ADDRESS **lst,char *string,char *host)
+ {
+   char c,*s,tmp[MAILTMPLEN];
+   ADDRESS *last = *lst;
+   ADDRESS *adr;
+   if (!string) return;		/* no string */
+   rfc822_skipws (&string);	/* skip leading WS */
+   if (!*string) return;		/* empty string */
+ 				/* run to tail of list */
+   if (last) while (last->next) last = last->next;
+   while (string) {		/* loop until string exhausted */
+ 				/* got an address? */
+     if (adr = rfc822_parse_address (lst,last,&string,host)) {
+       last = adr;		/* new tail address */
+       if (string) {		/* analyze what follows */
+ 	rfc822_skipws (&string);
+ 	switch (c = *string) {
+ 	case ',':		/* comma? */
+ 	  ++string;		/* then another address follows */
+ 	  break;
+ 	default:
+ 	  s = isalnum (c) ? "Must use comma to separate addresses: %.80s" :
+ 	    "Unexpected characters at end of address: %.80s";
+ 	  sprintf (tmp,s,string);
+ 	  mm_log (tmp,PARSE);
+ 	  last = last->next = mail_newaddr ();
+ 	  last->mailbox = cpystr ("UNEXPECTED_DATA_AFTER_ADDRESS");
+ 	  last->host = cpystr (errhst);
+ 				/* falls through */
+ 	case '\0':		/* null-specified address? */
+ 	  string = NIL;		/* punt remainder of parse */
+ 	  break;
+ 	}
+       }
+     }
+     else if (string) {		/* bad mailbox */
+       rfc822_skipws (&string);	/* skip WS */
+       if (!*string) strcpy (tmp,"Missing address after comma");
+       else sprintf (tmp,"Invalid mailbox list: %.80s",string);
+       mm_log (tmp,PARSE);
+       string = NIL;
+       (adr = mail_newaddr ())->mailbox = cpystr ("INVALID_ADDRESS");
+       adr->host = cpystr (errhst);
+       if (last) last = last->next = adr;
+       else *lst = last = adr;
+       break;
+     }
+   }
+ }
+ 
+ /* Parse RFC822 address
+  * Accepts: address list to write to
+  *	    tail of address list
+  *	    pointer to input string
+  *	    default host name
+  * Returns: new list tail
+  */
+ 
+ ADDRESS *rfc822_parse_address (ADDRESS **lst,ADDRESS *last,char **string,
+ 			       char *defaulthost)
+ {
+   ADDRESS *adr;
+   if (!*string) return NIL;	/* no string */
+   rfc822_skipws (string);	/* skip leading WS */
+   if (!**string) return NIL;	/* empty string */
+   if (adr = rfc822_parse_group (lst,last,string,defaulthost)) last = adr;
+ 				/* got an address? */
+   else if (adr = rfc822_parse_mailbox (string,defaulthost)) {
+     if (!*lst) *lst = adr;	/* yes, first time through? */
+     else last->next = adr;	/* no, append to the list */
+ 				/* set for subsequent linking */
+     for (last = adr; last->next; last = last->next);
+   }
+   else if (*string) return NIL;
+   return last;
+ }
+ 
+ /* Parse RFC822 group
+  * Accepts: address list to write to
+  *	    pointer to tail of address list
+  *	    pointer to input string
+  *	    default host name
+  */
+ 
+ ADDRESS *rfc822_parse_group (ADDRESS **lst,ADDRESS *last,char **string,
+ 			     char *defaulthost)
+ {
+   char tmp[MAILTMPLEN];
+   char *p,*s;
+   ADDRESS *adr;
+   if (!*string) return NIL;	/* no string */
+   rfc822_skipws (string);	/* skip leading WS */
+   if (!**string ||		/* trailing whitespace or not group */
+       ((*(p = *string) != ':') && !(p = rfc822_parse_phrase (*string))))
+     return NIL;
+   s = p;			/* end of candidate phrase */
+   rfc822_skipws (&s);		/* find delimiter */
+   if (*s != ':') return NIL;	/* not really a group */
+   *p = '\0';			/* tie off group name */
+   p = ++s;			/* continue after the delimiter */
+   rfc822_skipws (&p);		/* skip subsequent whitespace */
+ 				/* write as address */
+   (adr = mail_newaddr ())->mailbox = rfc822_cpy (*string);
+   if (!*lst) *lst = adr;	/* first time through? */
+   else last->next = adr;	/* no, append to the list */
+   last = adr;			/* set for subsequent linking */
+   *string = p;			/* continue after this point */
+   while (*string && **string && (**string != ';')) {
+     if (adr = rfc822_parse_address (lst,last,string,defaulthost)) {
+       last = adr;		/* new tail address */
+       if (*string) {		/* anything more? */
+ 	rfc822_skipws (string);	/* skip whitespace */
+ 	switch (**string) {	/* see what follows */
+ 	case ',':		/* another address? */
+ 	  ++*string;		/* yes, skip past the comma */
+ 	case ';':		/* end of group? */
+ 	case '\0':		/* end of string */
+ 	  break;
+ 	default:
+ 	  sprintf (tmp,"Unexpected characters after address in group: %.80s",
+ 		   *string);
+ 	  mm_log (tmp,PARSE);
+ 	  *string = NIL;	/* cancel remainder of parse */
+ 	  last = last->next = mail_newaddr ();
+ 	  last->mailbox = cpystr ("UNEXPECTED_DATA_AFTER_ADDRESS_IN_GROUP");
+ 	  last->host = cpystr (errhst);
+ 	}
+       }
+     }
+     else {			/* bogon */
+       sprintf (tmp,"Invalid group mailbox list: %.80s",*string);
+       mm_log (tmp,PARSE);
+       *string = NIL;		/* cancel remainder of parse */
+       (adr = mail_newaddr ())->mailbox = cpystr ("INVALID_ADDRESS_IN_GROUP");
+       adr->host = cpystr (errhst);
+       last = last->next = adr;
+     }
+   }
+   if (*string) {		/* skip close delimiter */
+     if (**string == ';') ++*string;
+     rfc822_skipws (string);
+   }
+ 				/* append end of address mark to the list */
+   last->next = (adr = mail_newaddr ());
+   last = adr;			/* set for subsequent linking */
+   return last;			/* return the tail */
+ }
+ 
+ /* Parse RFC822 mailbox
+  * Accepts: pointer to string pointer
+  *	    default host
+  * Returns: address list
+  *
+  * Updates string pointer
+  */
+ 
+ ADDRESS *rfc822_parse_mailbox (char **string,char *defaulthost)
+ {
+   ADDRESS *adr = NIL;
+   char *s,*end;
+   parsephrase_t pp = (parsephrase_t) mail_parameters (NIL,GET_PARSEPHRASE,NIL);
+   if (!*string) return NIL;	/* no string */
+   rfc822_skipws (string);	/* flush leading whitespace */
+   if (!**string) return NIL;	/* empty string */
+   if (*(s = *string) == '<') 	/* note start, handle case of phraseless RA */
+     adr = rfc822_parse_routeaddr (s,string,defaulthost);
+ 				/* otherwise, expect at least one word */
+   else if (end = rfc822_parse_phrase (s)) {
+     if ((adr = rfc822_parse_routeaddr (end,string,defaulthost))) {
+ 				/* phrase is a personal name */
+       if (adr->personal) fs_give ((void **) &adr->personal);
+       *end = '\0';		/* tie off phrase */
+       adr->personal = rfc822_cpy (s);
+     }
+ 				/* call external phraseparser if phrase only */
+     else if (pp && rfc822_phraseonly (end) &&
+ 	     (adr = (*pp) (s,end,defaulthost))) {
+       *string = end;		/* update parse pointer */
+       rfc822_skipws (string);	/* skip WS in the normal way */
+     }
+     else adr = rfc822_parse_addrspec (s,string,defaulthost);
+   }
+   return adr;			/* return the address */
+ }
+ 
+ 
+ /* Check if address is a phrase only
+  * Accepts: pointer to end of phrase
+  * Returns: T if phrase only, else NIL;
+  */
+ 
+ long rfc822_phraseonly (char *end)
+ {
+   while (*end == ' ') ++end;	/* call rfc822_skipws() instead?? */
+   switch (*end) {
+   case '\0': case ',': case ';':
+     return LONGT;		/* is a phrase only */
+   }
+   return NIL;			/* something other than phase is here */
+ }
+ 
+ /* Parse RFC822 route-address
+  * Accepts: string pointer
+  *	    pointer to string pointer to update
+  * Returns: address
+  *
+  * Updates string pointer
+  */
+ 
+ ADDRESS *rfc822_parse_routeaddr (char *string,char **ret,char *defaulthost)
+ {
+   char tmp[MAILTMPLEN];
+   ADDRESS *adr;
+   char *adl = NIL;
+   char *routeend = NIL;
+   if (!string) return NIL;
+   rfc822_skipws (&string);	/* flush leading whitespace */
+ 				/* must start with open broket */
+   if (*string != '<') return NIL;
+   if (string[1] == '@') {	/* have an A-D-L? */
+     adl = ++string;		/* yes, remember that fact */
+     while (*string != ':') {	/* search for end of A-D-L */
+ 				/* punt if never found */
+       if (!*string) return NIL;
+       ++string;			/* try next character */
+     }
+     *string = '\0';		/* tie off A-D-L */
+     routeend = string;		/* remember in case need to put back */
+   }
+ 				/* parse address spec */
+   if (!(adr = rfc822_parse_addrspec (++string,ret,defaulthost))) {
+     if (adl) *routeend = ':';	/* put colon back since parse barfed */
+     return NIL;
+   }
+ 				/* have an A-D-L? */
+   if (adl) adr->adl = cpystr (adl);
+   if (*ret) if (**ret == '>') {	/* make sure terminated OK */
+     ++*ret;			/* skip past the broket */
+     rfc822_skipws (ret);	/* flush trailing WS */
+     if (!**ret) *ret = NIL;	/* wipe pointer if at end of string */
+     return adr;			/* return the address */
+   }
+   sprintf (tmp,"Unterminated mailbox: %.80s@%.80s",adr->mailbox,
+ 	   *adr->host == '@' ? "<null>" : adr->host);
+   mm_log (tmp,PARSE);
+   adr->next = mail_newaddr ();
+   adr->next->mailbox = cpystr ("MISSING_MAILBOX_TERMINATOR");
+   adr->next->host = cpystr (errhst);
+   return adr;			/* return the address */
+ }
+ 
+ /* Parse RFC822 address-spec
+  * Accepts: string pointer
+  *	    pointer to string pointer to update
+  *	    default host
+  * Returns: address
+  *
+  * Updates string pointer
+  */
+ 
+ ADDRESS *rfc822_parse_addrspec (char *string,char **ret,char *defaulthost)
+ {
+   ADDRESS *adr;
+   char *end;
+   char c,*s,*t;
+   if (!string) return NIL;	/* no string */
+   rfc822_skipws (&string);	/* flush leading whitespace */
+   if (!*string) return NIL;	/* empty string */
+ 				/* find end of mailbox */
+   if (!(end = rfc822_parse_word (string,NIL))) return NIL;
+   adr = mail_newaddr ();	/* create address block */
+   c = *end;			/* remember delimiter */
+   *end = '\0';			/* tie off mailbox */
+ 				/* copy mailbox */
+   adr->mailbox = rfc822_cpy (string);
+   *end = c;			/* restore delimiter */
+   t = end;			/* remember end of mailbox for no host case */
+   rfc822_skipws (&end);		/* skip whitespace */
+   if (*end == '@') {		/* have host name? */
+     ++end;			/* skip delimiter */
+     rfc822_skipws (&end);	/* skip whitespace */
+     if (*end == '[') {		/* domain literal? */
+       string = end;		/* start of domain literal */
+       if (end = rfc822_parse_word (string + 1,"]\\")) {
+ 	size_t len = ++end - string;
+ 	strncpy (adr->host = (char *) fs_get (len + 1),string,len);
+ 	adr->host[len] = '\0';	/* tie off literal */
+       }
+       else {
+ 	mm_log ("Invalid domain literal after @",PARSE);
+ 	adr->host = cpystr (errhst);
+       }
+     }
+     				/* search for end of host */
+     else if (end = rfc822_parse_word ((string = end),wspecials)) {
+       c = *end;			/* remember delimiter */
+       *end = '\0';		/* tie off host */
+ 				/* copy host */
+       adr->host = rfc822_cpy (string);
+       *end = c;			/* restore delimiter */
+     }
+     else {
+       mm_log ("Missing or invalid host name after @",PARSE);
+       adr->host = cpystr (errhst);
+     }
+   }
+   else end = t;			/* make person name default start after mbx */
+ 				/* default host if missing */
+   if (!adr->host) adr->host = cpystr (defaulthost);
+   if (end && !adr->personal) {	/* try person name in comments if missing */
+     while (*end == ' ') ++end;	/* see if we can find a person name here */
+     if ((*end == '(') && (s = rfc822_skip_comment (&end,LONGT)) && strlen (s))
+       adr->personal = rfc822_cpy (s);
+     rfc822_skipws (&end);	/* skip any other WS in the normal way */
+   }
+ 				/* set return to end pointer */
+   *ret = (end && *end) ? end : NIL;
+   return adr;			/* return the address we got */
+ }
+ 
+ /* Parse RFC822 phrase
+  * Accepts: string pointer
+  * Returns: pointer to end of phrase
+  */
+ 
+ char *rfc822_parse_phrase (char *s)
+ {
+   char *curpos;
+   if (!s) return NIL;		/* no-op if no string */
+ 				/* find first word of phrase */
+   curpos = rfc822_parse_word (s,NIL);
+   if (!curpos) return NIL;	/* no words means no phrase */
+   if (!*curpos) return curpos;	/* check if string ends with word */
+   s = curpos;			/* sniff past the end of this word and WS */
+   rfc822_skipws (&s);		/* skip whitespace */
+ 				/* recurse to see if any more */
+   return (s = rfc822_parse_phrase (s)) ? s : curpos;
+ }
+ 
+ /* Parse RFC822 word
+  * Accepts: string pointer
+  * Returns: pointer to end of word
+  */
+ 
+ char *rfc822_parse_word (char *s,const char *delimiters)
+ {
+   char *st,*str;
+   if (!s) return NIL;		/* no string */
+   rfc822_skipws (&s);		/* flush leading whitespace */
+   if (!*s) return NIL;		/* empty string */
+ 				/* default delimiters to standard */
+   if (!delimiters) delimiters = wspecials;
+   str = s;			/* hunt pointer for strpbrk */
+   while (T) {			/* look for delimiter */
+     if (!(st = strpbrk (str,delimiters))) {
+       while (*s) ++s;		/* no delimiter, hunt for end */
+       return s;			/* return it */
+     }
+     switch (*st) {		/* dispatch based on delimiter */
+     case '"':			/* quoted string */
+ 				/* look for close quote */
+       while (*++st != '"') switch (*st) {
+       case '\0':		/* unbalanced quoted string */
+ 	return NIL;		/* sick sick sick */
+       case '\\':		/* quoted character */
+ 	if (!*++st) return NIL;	/* skip the next character */
+       default:			/* ordinary character */
+ 	break;			/* no special action */
+       }
+       str = ++st;		/* continue parse */
+       break;
+     case '\\':			/* quoted character */
+       /* This is wrong; a quoted-pair can not be part of a word.  However,
+        * domain-literal is parsed as a word and quoted-pairs can be used
+        * *there*.  Either way, it's pretty pathological.
+        */
+       if (st[1]) {		/* not on NUL though... */
+ 	str = st + 2;		/* skip quoted character and go on */
+ 	break;
+       }
+     default:			/* found a word delimiter */
+       return (st == s) ? NIL : st;
+     }
+   }
+ }
+ 
+ /* Copy an RFC822 format string
+  * Accepts: string
+  * Returns: copy of string
+  */
+ 
+ char *rfc822_cpy (char *src)
+ {
+ 				/* copy and unquote */
+   return rfc822_quote (cpystr (src));
+ }
+ 
+ 
+ /* Unquote an RFC822 format string
+  * Accepts: string
+  * Returns: string
+  */
+ 
+ char *rfc822_quote (char *src)
+ {
+   char *ret = src;
+   if (strpbrk (src,"\\\"")) {	/* any quoting in string? */
+     char *dst = ret;
+     while (*src) {		/* copy string */
+       if (*src == '\"') src++;	/* skip double quote entirely */
+       else {
+ 	if (*src == '\\') src++;/* skip over single quote, copy next always */
+ 	*dst++ = *src++;	/* copy character */
+       }
+     }
+     *dst = '\0';		/* tie off string */
+   }
+   return ret;			/* return our string */
+ }
+ 
+ 
+ /* Copy address list
+  * Accepts: address list
+  * Returns: address list
+  */
+ 
+ ADDRESS *rfc822_cpy_adr (ADDRESS *adr)
+ {
+   ADDRESS *dadr;
+   ADDRESS *ret = NIL;
+   ADDRESS *prev = NIL;
+   while (adr) {			/* loop while there's still an MAP adr */
+     dadr = mail_newaddr ();	/* instantiate a new address */
+     if (!ret) ret = dadr;	/* note return */
+     if (prev) prev->next = dadr;/* tie on to the end of any previous */
+     dadr->personal = cpystr (adr->personal);
+     dadr->adl = cpystr (adr->adl);
+     dadr->mailbox = cpystr (adr->mailbox);
+     dadr->host = cpystr (adr->host);
+     prev = dadr;		/* this is now the previous */
+     adr = adr->next;		/* go to next address in list */
+   }
+   return (ret);			/* return the MTP address list */
+ }
+ 
+ /* Skips RFC822 whitespace
+  * Accepts: pointer to string pointer
+  */
+ 
+ void rfc822_skipws (char **s)
+ {
+   while (T) {
+     if (**s == ' ') ++*s;	/* skip space */
+     else if ((**s != '(') || !rfc822_skip_comment (s,(long) NIL)) return;
+   }
+ }
+ 
+ 
+ /* Skips RFC822 comment
+  * Accepts: pointer to string pointer
+  *	    trim flag
+  * Returns: pointer to first non-blank character of comment
+  */
+ 
+ char *rfc822_skip_comment (char **s,long trim)
+ {
+   char *ret,tmp[MAILTMPLEN];
+   char *s1 = *s;
+   char *t = NIL;
+ 				/* skip past whitespace */
+   for (ret = ++s1; *ret == ' '; ret++);
+   do switch (*s1) {		/* get character of comment */
+   case '(':			/* nested comment? */
+     if (!rfc822_skip_comment (&s1,(long) NIL)) return NIL;
+     t = --s1;			/* last significant char at end of comment */
+     break;
+   case ')':			/* end of comment? */
+     *s = ++s1;			/* skip past end of comment */
+     if (trim) {			/* if level 0, must trim */
+       if (t) t[1] = '\0';	/* tie off comment string */
+       else *ret = '\0';		/* empty comment */
+     }
+     return ret;
+   case '\\':			/* quote next character? */
+     if (*++s1) {		/* next character non-null? */
+       t = s1;			/* update last significant character pointer */
+       break;			/* all OK */
+     }
+   case '\0':			/* end of string */
+     sprintf (tmp,"Unterminated comment: %.80s",*s);
+     mm_log (tmp,PARSE);
+     **s = '\0';			/* nuke duplicate messages in case reparse */
+     return NIL;			/* this is wierd if it happens */
+   case ' ':			/* whitespace isn't significant */
+     break;
+   default:			/* random character */
+     t = s1;			/* update last significant character pointer */
+     break;
+   } while (s1++);
+   return NIL;			/* impossible, but pacify lint et al */
+ }
+ 
+ /* Body contents utility and encoding/decoding routines */
+ 
+ 
+ /* Output RFC 822 message
+  * Accepts: temporary buffer
+  *	    envelope
+  *	    body
+  *	    I/O routine
+  *	    stream for I/O routine
+  *	    non-zero if 8-bit output desired
+  * Returns: T if successful, NIL if failure
+  */
+ 
+ long rfc822_output (char *t,ENVELOPE *env,BODY *body,soutr_t f,void *s,
+ 		    long ok8bit)
+ {
+   rfc822out_t r822o = (rfc822out_t) mail_parameters (NIL,GET_RFC822OUTPUT,NIL);
+ 				/* call external RFC822 output generator */
+   if (r822o) return (*r822o) (t,env,body,f,s,ok8bit);
+ 				/* encode body as necessary */
+   if (ok8bit) rfc822_encode_body_8bit (env,body);
+   else rfc822_encode_body_7bit (env,body);
+   rfc822_header (t,env,body);	/* build RFC822 header */
+ 				/* output header and body */
+   return (*f) (s,t) && (body ? rfc822_output_body (body,f,s) : T);
+ }
+ 
+ /* Encode a body for 7BIT transmittal
+  * Accepts: envelope
+  *	    body
+  */
+ 
+ void rfc822_encode_body_7bit (ENVELOPE *env,BODY *body)
+ {
+   void *f;
+   PART *part;
+   PARAMETER **param;
+   if (body) switch (body->type) {
+   case TYPEMULTIPART:		/* multi-part */
+     for (param = &body->parameter;
+ 	 *param && strcmp ((*param)->attribute,"BOUNDARY");
+ 	 param = &(*param)->next);
+     if (!*param) {		/* cookie not set up yet? */
+       char tmp[MAILTMPLEN];	/* make cookie not in BASE64 or QUOTEPRINT*/
+       sprintf (tmp,"%ld-%ld-%ld=:%ld",gethostid (),random (),time (0),
+ 	       getpid ());
+       (*param) = mail_newbody_parameter ();
+       (*param)->attribute = cpystr ("BOUNDARY");
+       (*param)->value = cpystr (tmp);
+     }
+     part = body->nested.part;	/* encode body parts */
+     do rfc822_encode_body_7bit (env,&part->body);
+     while (part = part->next);	/* until done */
+     break;
+   case TYPEMESSAGE:		/* encapsulated message */
+     switch (body->encoding) {
+     case ENC7BIT:
+       break;
+     case ENC8BIT:
+       mm_log ("8-bit included message in 7-bit message body",WARN);
+       break;
+     case ENCBINARY:
+       mm_log ("Binary included message in 7-bit message body",WARN);
+       break;
+     default:
+       fatal ("Invalid rfc822_encode_body_7bit message encoding");
+     }
+     break;			/* can't change encoding */
+   default:			/* all else has some encoding */
+     switch (body->encoding) {
+     case ENC8BIT:		/* encode 8BIT into QUOTED-PRINTABLE */
+ 				/* remember old 8-bit contents */
+       f = (void *) body->contents.text.data;
+       body->contents.text.data =
+ 	rfc822_8bit (body->contents.text.data,
+ 		     body->contents.text.size,&body->contents.text.size);
+       body->encoding = ENCQUOTEDPRINTABLE;
+       fs_give (&f);		/* flush old binary contents */
+       break;
+     case ENCBINARY:		/* encode binary into BASE64 */
+ 				/* remember old binary contents */
+       f = (void *) body->contents.text.data;
+       body->contents.text.data =
+ 	rfc822_binary ((void *) body->contents.text.data,
+ 		       body->contents.text.size,&body->contents.text.size);
+       body->encoding = ENCBASE64;
+       fs_give (&f);		/* flush old binary contents */
+     default:			/* otherwise OK */
+       break;
+     }
+     break;
+   }
+ }
+ 
+ /* Encode a body for 8BIT transmittal
+  * Accepts: envelope
+  *	    body
+  */
+ 
+ void rfc822_encode_body_8bit (ENVELOPE *env,BODY *body)
+ {
+   void *f;
+   PART *part;
+   PARAMETER **param;
+   if (body) switch (body->type) {
+   case TYPEMULTIPART:		/* multi-part */
+     for (param = &body->parameter;
+ 	 *param && strcmp ((*param)->attribute,"BOUNDARY");
+ 	 param = &(*param)->next);
+     if (!*param) {		/* cookie not set up yet? */
+       char tmp[MAILTMPLEN];	/* make cookie not in BASE64 or QUOTEPRINT*/
+       sprintf (tmp,"%ld-%ld-%ld=:%ld",gethostid (),random (),time (0),
+ 	       getpid ());
+       (*param) = mail_newbody_parameter ();
+       (*param)->attribute = cpystr ("BOUNDARY");
+       (*param)->value = cpystr (tmp);
+     }
+     part = body->nested.part;	/* encode body parts */
+     do rfc822_encode_body_8bit (env,&part->body);
+     while (part = part->next);	/* until done */
+     break;
+   case TYPEMESSAGE:		/* encapsulated message */
+     switch (body->encoding) {
+     case ENC7BIT:
+     case ENC8BIT:
+       break;
+     case ENCBINARY:
+       mm_log ("Binary included message in 8-bit message body",WARN);
+       break;
+     default:
+       fatal ("Invalid rfc822_encode_body_7bit message encoding");
+     }
+     break;			/* can't change encoding */
+   default:			/* other type, encode binary into BASE64 */
+     if (body->encoding == ENCBINARY) {
+ 				/* remember old binary contents */
+       f = (void *) body->contents.text.data;
+       body->contents.text.data =
+ 	rfc822_binary ((void *) body->contents.text.data,
+ 		       body->contents.text.size,&body->contents.text.size);
+       body->encoding = ENCBASE64;
+       fs_give (&f);		/* flush old binary contents */
+     }
+     break;
+   }
+ }
+ 
+ /* Output RFC 822 body
+  * Accepts: body
+  *	    I/O routine
+  *	    stream for I/O routine
+  * Returns: T if successful, NIL if failure
+  */
+ 
+ long rfc822_output_body (BODY *body,soutr_t f,void *s)
+ {
+   PART *part;
+   PARAMETER *param;
+   char *cookie = NIL;
+   char tmp[MAILTMPLEN];
+   char *t;
+   switch (body->type) {
+   case TYPEMULTIPART:		/* multipart gets special handling */
+     part = body->nested.part;	/* first body part */
+ 				/* find cookie */
+     for (param = body->parameter; param && !cookie; param = param->next)
+       if (!strcmp (param->attribute,"BOUNDARY")) cookie = param->value;
+     if (!cookie) cookie = "-";	/* yucky default */
+     do {			/* for each part */
+ 				/* build cookie */
+       sprintf (t = tmp,"--%s\015\012",cookie);
+ 				/* append mini-header */
+       rfc822_write_body_header (&t,&part->body);
+       strcat (t,"\015\012");	/* write terminating blank line */
+ 				/* output cookie, mini-header, and contents */
+       if (!((*f) (s,tmp) && rfc822_output_body (&part->body,f,s))) return NIL;
+     } while (part = part->next);/* until done */
+ 				/* output trailing cookie */
+     sprintf (t = tmp,"--%s--",cookie);
+     break;
+   default:			/* all else is text now */
+     t = (char *) body->contents.text.data;
+     break;
+   }
+ 				/* output final stuff */
+   if (t && *t && !((*f) (s,t) && (*f) (s,"\015\012"))) return NIL;
+   return LONGT;
+ }
+ 
+ /* Convert BASE64 contents to binary
+  * Accepts: source
+  *	    length of source
+  *	    pointer to return destination length
+  * Returns: destination as binary
+  */
+ 
+ void *rfc822_base64 (unsigned char *src,unsigned long srcl,unsigned long *len)
+ {
+   char c;
+   void *ret = fs_get ((size_t) (*len = 4 + ((srcl * 3) / 4)));
+   char *d = (char *) ret;
+   int e = 0;
+   memset (ret,0,(size_t) *len);	/* initialize block */
+   *len = 0;			/* in case we return an error */
+   while (srcl--) {		/* until run out of characters */
+     c = *src++;			/* simple-minded decode */
+     if (isupper (c)) c -= 'A';
+     else if (islower (c)) c -= 'a' - 26;
+     else if (isdigit (c)) c -= '0' - 52;
+     else if (c == '+') c = 62;
+     else if (c == '/') c = 63;
+     else if (c == '=') {	/* padding */
+       switch (e++) {		/* check quantum position */
+       case 3:
+ 	e = 0;			/* restart quantum */
+ 	break;
+       case 2:
+ 	if (*src == '=') break;
+       default:			/* impossible quantum position */
+ 	fs_give (&ret);
+ 	return NIL;
+       }
+       continue;
+     }
+     else continue;		/* junk character */
+     switch (e++) {		/* install based on quantum position */
+     case 0:
+       *d = c << 2;		/* byte 1: high 6 bits */
+       break;
+     case 1:
+       *d++ |= c >> 4;		/* byte 1: low 2 bits */
+       *d = c << 4;		/* byte 2: high 4 bits */
+       break;
+     case 2:
+       *d++ |= c >> 2;		/* byte 2: low 4 bits */
+       *d = c << 6;		/* byte 3: high 2 bits */
+       break;
+     case 3:
+       *d++ |= c;		/* byte 3: low 6 bits */
+       e = 0;			/* reinitialize mechanism */
+       break;
+     }
+   }
+   *len = d - (char *) ret;	/* calculate data length */
+   return ret;			/* return the string */
+ }
+ 
+ /* Convert binary contents to BASE64
+  * Accepts: source
+  *	    length of source
+  *	    pointer to return destination length
+  * Returns: destination as BASE64
+  */
+ 
+ unsigned char *rfc822_binary (void *src,unsigned long srcl,unsigned long *len)
+ {
+   unsigned char *ret,*d;
+   unsigned char *s = (unsigned char *) src;
+   char *v = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+   unsigned long i = ((srcl + 2) / 3) * 4;
+   *len = i += 2 * ((i / 60) + 1);
+   d = ret = (unsigned char *) fs_get ((size_t) ++i);
+   for (i = 0; srcl; s += 3) {	/* process tuplets */
+     *d++ = v[s[0] >> 2];	/* byte 1: high 6 bits (1) */
+ 				/* byte 2: low 2 bits (1), high 4 bits (2) */
+     *d++ = v[((s[0] << 4) + (--srcl ? (s[1] >> 4) : 0)) & 0x3f];
+ 				/* byte 3: low 4 bits (2), high 2 bits (3) */
+     *d++ = srcl ? v[((s[1] << 2) + (--srcl ? (s[2] >> 6) : 0)) & 0x3f] : '=';
+ 				/* byte 4: low 6 bits (3) */
+     *d++ = srcl ? v[s[2] & 0x3f] : '=';
+     if (srcl) srcl--;		/* count third character if processed */
+     if ((++i) == 15) {		/* output 60 characters? */
+       i = 0;			/* restart line break count, insert CRLF */
+       *d++ = '\015'; *d++ = '\012';
+     }
+   }
+   *d++ = '\015'; *d++ = '\012';	/* insert final CRLF */
+   *d = '\0';			/* tie off string */
+   if (((unsigned long) (d - ret)) != *len) fatal ("rfc822_binary logic flaw");
+   return ret;			/* return the resulting string */
+ }
+ 
+ /* Convert QUOTED-PRINTABLE contents to 8BIT
+  * Accepts: source
+  *	    length of source
+  * 	    pointer to return destination length
+  * Returns: destination as 8-bit text
+  */
+ 
+ unsigned char *rfc822_qprint (unsigned char *src,unsigned long srcl,
+ 			      unsigned long *len)
+ {
+   unsigned char *ret = (unsigned char *) fs_get ((size_t) srcl + 1);
+   unsigned char *d = ret;
+   unsigned char *s = d;
+   unsigned char c,e;
+   *len = 0;			/* in case we return an error */
+   src[srcl] = '\0';		/* make sure string tied off */
+   while (c = *src++) {		/* until run out of characters */
+     switch (c) {		/* what type of character is it? */
+     case '=':			/* quoting character */
+       switch (c = *src++) {	/* what does it quote? */
+       case '\0':		/* end of data */
+ 	src--;			/* back up pointer */
+ 	break;
+       case '\015':		/* non-significant line break */
+ 	s = d;			/* accept any leading spaces */
+ 	if (*src == '\012') src++;
+ 	break;
+       default:			/* two hex digits then */
+ 	if (!isxdigit (c)) {	/* must be hex! */
+ 	  fs_give ((void **) &ret);
+ 	  return NIL;
+ 	}
+ 	if (isdigit (c)) e = c - '0';
+ 	else e = c - (isupper (c) ? 'A' - 10 : 'a' - 10);
+ 	c = *src++;		/* snarf next character */
+ 	if (!isxdigit (c)) {	/* must be hex! */
+ 	  fs_give ((void **) &ret);
+ 	  return NIL;
+ 	}
+ 	if (isdigit (c)) c -= '0';
+ 	else c -= (isupper (c) ? 'A' - 10 : 'a' - 10);
+ 	*d++ = c + (e << 4);	/* merge the two hex digits */
+ 	s = d;			/* note point of non-space */
+ 	break;
+       }
+       break;
+     case ' ':			/* space, possibly bogus */
+       *d++ = c;			/* stash the space but don't update s */
+       break;
+     case '\015':		/* end of line */
+       d = s;			/* slide back to last non-space, drop in */
+     default:
+       *d++ = c;			/* stash the character */
+       s = d;			/* note point of non-space */
+     }      
+   }
+   *d = '\0';			/* tie off results */
+   *len = d - ret;		/* calculate length */
+   return ret;			/* return the string */
+ }
+ 
+ /* Convert 8BIT contents to QUOTED-PRINTABLE
+  * Accepts: source
+  *	    length of source
+  * 	    pointer to return destination length
+  * Returns: destination as quoted-printable text
+  */
+ 
+ #define MAXL (size_t) 75	/* 76th position only used by continuation = */
+ 
+ unsigned char *rfc822_8bit (unsigned char *src,unsigned long srcl,
+ 			    unsigned long *len)
+ {
+   unsigned long lp = 0;
+   unsigned char *ret = (unsigned char *)
+     fs_get ((size_t) (3*srcl + (6*srcl)/MAXL + 3));
+   unsigned char *d = ret;
+   char *hex = "0123456789ABCDEF";
+   unsigned char c;
+   while (srcl--) {		/* for each character */
+ 				/* true line break? */
+     if (((c = *src++) == '\015') && (*src == '\012') && srcl) {
+       *d++ = '\015'; *d++ = *src++; srcl--;
+       lp = 0;			/* reset line count */
+     }
+     else {			/* not a line break */
+ 				/* quoting required? */
+       if (iscntrl (c) || (c == 0x7f) || (c & 0x80) || (c == '=') ||
+ 	  ((c == ' ') && (*src == '\015'))) {
+ 	if ((lp += 3) > MAXL) {	/* yes, would line overflow? */
+ 	  *d++ = '='; *d++ = '\015'; *d++ = '\012';
+ 	  lp = 3;		/* set line count */
+ 	}
+ 	*d++ = '=';		/* quote character */
+ 	*d++ = hex[c >> 4];	/* high order 4 bits */
+ 	*d++ = hex[c & 0xf];	/* low order 4 bits */
+       }
+       else {			/* ordinary character */
+ 	if ((++lp) > MAXL) {	/* would line overflow? */
+ 	  *d++ = '='; *d++ = '\015'; *d++ = '\012';
+ 	  lp = 1;		/* set line count */
+ 	}
+ 	*d++ = c;		/* ordinary character */
+       }
+     }
+   }
+   *d = '\0';			/* tie off destination */
+   *len = d - ret;		/* calculate true size */
+ 				/* try to give some space back */
+   fs_resize ((void **) &ret,(size_t) *len + 1);
+   return ret;
+ }
diff -c -N c-client.pure/rfc822.c.original c-client/rfc822.c.original
*** c-client.pure/rfc822.c.original	Thu Jan  1 01:00:00 1970
--- c-client/rfc822.c.original	Sat Feb  5 14:44:02 2000
***************
*** 0 ****
--- 1,1763 ----
+ /*
+  * Program:	RFC-822 routines (originally from SMTP)
+  *
+  * Author:	Mark Crispin
+  *		Networks and Distributed Computing
+  *		Computing & Communications
+  *		University of Washington
+  *		Administration Building, AG-44
+  *		Seattle, WA  98195
+  *		Internet: MRC@CAC.Washington.EDU
+  *
+  * Date:	27 July 1988
+  * Last Edited:	21 October 1997
+  *
+  * Sponsorship:	The original version of this work was developed in the
+  *		Symbolic Systems Resources Group of the Knowledge Systems
+  *		Laboratory at Stanford University in 1987-88, and was funded
+  *		by the Biomedical Research Technology Program of the National
+  *		Institutes of Health under grant number RR-00785.
+  *
+  * Original version Copyright 1988 by The Leland Stanford Junior University
+  * Copyright 1997 by the University of Washington
+  *
+  *  Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notices appear in all copies and that both the
+  * above copyright notices and this permission notice appear in supporting
+  * documentation, and that the name of the University of Washington or The
+  * Leland Stanford Junior University not be used in advertising or publicity
+  * pertaining to distribution of the software without specific, written prior
+  * permission.  This software is made available "as is", and
+  * THE UNIVERSITY OF WASHINGTON AND THE LELAND STANFORD JUNIOR UNIVERSITY
+  * DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD TO THIS SOFTWARE,
+  * INCLUDING WITHOUT LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+  * FITNESS FOR A PARTICULAR PURPOSE, AND IN NO EVENT SHALL THE UNIVERSITY OF
+  * WASHINGTON OR THE LELAND STANFORD JUNIOR UNIVERSITY BE LIABLE FOR ANY
+  * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+  * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+  * CONTRACT, TORT (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF
+  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  */
+ 
+ 
+ #include <ctype.h>
+ #include <stdio.h>
+ #include <time.h>
+ #include "mail.h"
+ #include "osdep.h"
+ #include "rfc822.h"
+ #include "misc.h"
+ 
+ /* RFC-822 static data */
+ 
+ 
+ char *errhst = ERRHOST;		/* syntax error host string */
+ 
+ 
+ /* Body formats constant strings, must match definitions in mail.h */
+ 
+ char *body_types[TYPEMAX+1] = {
+   "TEXT", "MULTIPART", "MESSAGE", "APPLICATION", "AUDIO", "IMAGE", "VIDEO",
+   "MODEL", "X-UNKNOWN"
+ };
+ 
+ 
+ char *body_encodings[ENCMAX+1] = {
+   "7BIT", "8BIT", "BINARY", "BASE64", "QUOTED-PRINTABLE", "X-UNKNOWN"
+ };
+ 
+ 
+ /* Token delimiting special characters */
+ 
+ 				/* full RFC-822 specials */
+ const char *rspecials =  "()<>@,;:\\\"[].";
+ 				/* body token specials */
+ const char *tspecials = " ()<>@,;:\\\"[]./?=";
+ 
+ 
+ /* Once upon a time, CSnet had a mailer which assigned special semantics to
+  * dot in e-mail addresses.  For the sake of that mailer, dot was added to
+  * the RFC-822 definition of `specials', even though it had numerous bad side
+  * effects:
+  *   1)	It broke mailbox names on systems which had dots in user names, such as
+  *	Multics and TOPS-20.  RFC-822's syntax rules require that `Admin . MRC'
+  *	be considered equivalent to `Admin.MRC'.  Fortunately, few people ever
+  *	tried this in practice.
+  *   2) It required that all personal names with an initial be quoted, a widely
+  *	detested user interface misfeature.
+  *   3)	It made the parsing of host names be non-atomic for no good reason.
+  * To work around these problems, the following alternate specials lists are
+  * defined.  hspecials and wspecials are used in lieu of rspecials, and
+  * ptspecials are used in lieu of tspecials.  These alternate specials lists
+  * make the parser work a lot better in the real world.  It ain't politically
+  * correct, but it lets the users get their job done!
+  */
+ 
+ 				/* parse-word specials */
+ const char *wspecials = " ()<>@,;:\\\"[]";
+ 				/* parse-token specials for parsing */
+ const char *ptspecials = " ()<>@,;:\\\"[]/?=";
+ 
+ /* RFC822 writing routines */
+ 
+ 
+ /* Write RFC822 header from message structure
+  * Accepts: scratch buffer to write into
+  *	    message envelope
+  *	    message body
+  */
+ 
+ void rfc822_header (char *header,ENVELOPE *env,BODY *body)
+ {
+   if (env->remail) {		/* if remailing */
+     long i = strlen (env->remail);
+     strcpy (header,env->remail);/* start with remail header */
+ 				/* flush extra blank line */
+     if (i > 4 && header[i-4] == '\015') header[i-2] = '\0';
+   }
+   else *header = '\0';		/* else initialize header to null */
+   rfc822_header_line (&header,"Newsgroups",env,env->newsgroups);
+   rfc822_header_line (&header,"Date",env,env->date);
+   rfc822_address_line (&header,"From",env,env->from);
+   rfc822_address_line (&header,"Sender",env,env->sender);
+   rfc822_address_line (&header,"Reply-To",env,env->reply_to);
+   rfc822_header_line (&header,"Subject",env,env->subject);
+   if (env->bcc && !(env->to || env->cc))
+     strcat (header,"To: undisclosed recipients: ;\015\012");
+   rfc822_address_line (&header,"To",env,env->to);
+   rfc822_address_line (&header,"cc",env,env->cc);
+ /* bcc's are never written...
+  * rfc822_address_line (&header,"bcc",env,env->bcc);
+  */
+   rfc822_header_line (&header,"In-Reply-To",env,env->in_reply_to);
+   rfc822_header_line (&header,"Message-ID",env,env->message_id);
+   rfc822_header_line (&header,"Followup-to",env,env->followup_to);
+   rfc822_header_line (&header,"References",env,env->references);
+   if (body && !env->remail) {	/* not if remail or no body structure */
+     strcat (header,"MIME-Version: 1.0\015\012");
+     rfc822_write_body_header (&header,body);
+   }
+   strcat (header,"\015\012");	/* write terminating blank line */
+ }
+ 
+ /* Write RFC822 address from header line
+  * Accepts: pointer to destination string pointer
+  *	    pointer to header type
+  *	    message to interpret
+  *	    address to interpret
+  */
+ 
+ void rfc822_address_line (char **header,char *type,ENVELOPE *env,ADDRESS *adr)
+ {
+   char *t,tmp[MAILTMPLEN];
+   long i,len,n = 0;
+   char *s = (*header += strlen (*header));
+   if (adr) {			/* do nothing if no addresses */
+     if (env && env->remail) strcat (s,"ReSent-");
+     strcat (s,type);		/* write header name */
+     strcat (s,": ");
+     s += (len = strlen (s));	/* initial string length */
+     do {			/* run down address list */
+       *(t = tmp) = '\0';	/* initially empty string */
+ 				/* start of group? */
+       if (adr->mailbox && !adr->host) {
+ 				/* yes, write group name */
+ 	rfc822_cat (t,adr->mailbox,rspecials);
+ 	strcat (t,": ");	/* write group identifier */
+ 	n++;			/* in a group, suppress expansion */
+       }
+       else {			/* not start of group */
+ 	if (!adr->host && n) {	/* end of group? */
+ 	  strcat (t,";");	/* write close delimiter */
+ 	  n--;			/* no longer in a group */
+ 	}
+ 	else if (!n) {		/* only print if not inside a group */
+ 				/* simple case? */
+ 	  if (!(adr->personal || adr->adl)) rfc822_address (t,adr);
+ 	  else {		/* no, must use phrase <route-addr> form */
+ 	    if (adr->personal) rfc822_cat (t,adr->personal,rspecials);
+ 	    strcat (t," <");	/* write address delimiter */
+ 				/* write address */
+ 	    rfc822_address (t,adr);
+ 	    strcat (t,">");	/* closing delimiter */
+ 	  }
+ 	}
+ 				/* write delimiter for next recipient */
+ 	if (!n && adr->next && adr->next->mailbox) strcat (t,", ");
+       }
+ 				/* if string would overflow */
+       if ((len += (i = strlen (t))) > 78) {
+ 	len = 4 + i;		/* continue it on a new line */
+ 	*s++ = '\015'; *s++ = '\012';
+ 	*s++ = ' '; *s++ = ' '; *s++ = ' '; *s++ = ' ';
+       }
+       while (*t) *s++ = *t++;	/* write this address */
+     } while (adr = adr->next);
+ 				/* tie off header line */
+     *s++ = '\015'; *s++ = '\012'; *s = '\0';
+     *header = s;		/* set return value */
+   }
+ }
+ 
+ /* Write RFC822 text from header line
+  * Accepts: pointer to destination string pointer
+  *	    pointer to header type
+  *	    message to interpret
+  *	    pointer to text
+  */
+ 
+ void rfc822_header_line (char **header,char *type,ENVELOPE *env,char *text)
+ {
+   if (text) sprintf ((*header += strlen (*header)),"%s%s: %s\015\012",
+ 		     env->remail ? "ReSent-" : "",type,text);
+ }
+ 
+ 
+ /* Write RFC822 address
+  * Accepts: pointer to destination string
+  *	    address to interpret
+  */
+ 
+ void rfc822_write_address (char *dest,ADDRESS *adr)
+ {
+   while (adr) {
+ 				/* start of group? */
+     if (adr->mailbox && !adr->host) {
+ 				/* yes, write group name */
+       rfc822_cat (dest,adr->mailbox,rspecials);
+       strcat (dest,": ");	/* write group identifier */
+       adr = adr->next;		/* move to next address block */
+     }
+     else {			/* end of group? */
+       if (!adr->host) strcat (dest,";");
+ 				/* simple case? */
+       else if (!(adr->personal || adr->adl)) rfc822_address (dest,adr);
+       else {			/* no, must use phrase <route-addr> form */
+ 	if (adr->personal) {	/* in case have adl but no personal name */
+ 	  rfc822_cat (dest,adr->personal,rspecials);
+ 	  strcat (dest," ");
+ 	}
+ 	strcat (dest,"<");	/* write address delimiter */
+ 	rfc822_address (dest,adr);/* write address */
+ 	strcat (dest,">");	/* closing delimiter */
+       }
+ 				/* delimit if there is one */
+       if ((adr = adr->next) && adr->mailbox) strcat (dest,", ");
+     }
+   }
+ }
+ 
+ /* Write RFC822 route-address to string
+  * Accepts: pointer to destination string
+  *	    address to interpret
+  */
+ 
+ void rfc822_address (char *dest,ADDRESS *adr)
+ {
+   if (adr && adr->host) {	/* no-op if no address */
+     if (adr->adl) {		/* have an A-D-L? */
+       strcat (dest,adr->adl);
+       strcat (dest,":");
+     }
+ 				/* write mailbox name */
+     rfc822_cat (dest,adr->mailbox,wspecials);
+     if (*adr->host != '@') {	/* unless null host (HIGHLY discouraged!) */
+       strcat (dest,"@");	/* host delimiter */
+       strcat (dest,adr->host);	/* write host name */
+     }
+   }
+ }
+ 
+ 
+ /* Concatenate RFC822 string
+  * Accepts: pointer to destination string
+  *	    pointer to string to concatenate
+  *	    list of special characters
+  */
+ 
+ void rfc822_cat (char *dest,char *src,const char *specials)
+ {
+   char *s;
+   if (strpbrk (src,specials)) {	/* any specials present? */
+     strcat (dest,"\"");		/* opening quote */
+ 				/* truly bizarre characters in there? */
+     while (s = strpbrk (src,"\\\"")) {
+       strncat (dest,src,s-src);	/* yes, output leader */
+       strcat (dest,"\\");	/* quoting */
+       strncat (dest,s,1);	/* output the bizarre character */
+       src = ++s;		/* continue after the bizarre character */
+     }
+     if (*src) strcat (dest,src);/* output non-bizarre string */
+     strcat (dest,"\"");		/* closing quote */
+   }
+   else strcat (dest,src);	/* otherwise it's the easy case */
+ }
+ 
+ /* Write body content header
+  * Accepts: pointer to destination string pointer
+  *	    pointer to body to interpret
+  */
+ 
+ void rfc822_write_body_header (char **dst,BODY *body)
+ {
+   char *s;
+   STRINGLIST *stl;
+   PARAMETER *param = body->parameter;
+   sprintf (*dst += strlen (*dst),"Content-Type: %s",body_types[body->type]);
+   s = body->subtype ? body->subtype : rfc822_default_subtype (body->type);
+   sprintf (*dst += strlen (*dst),"/%s",s);
+   if (param) do {
+     sprintf (*dst += strlen (*dst),"; %s=",param->attribute);
+     rfc822_cat (*dst,param->value,tspecials);
+   } while (param = param->next);
+   else if (body->type == TYPETEXT) strcat (*dst,"; CHARSET=US-ASCII");
+   strcpy (*dst += strlen (*dst),"\015\012");
+   if (body->encoding)		/* note: encoding 7BIT never output! */
+     sprintf (*dst += strlen (*dst),"Content-Transfer-Encoding: %s\015\012",
+ 	     body_encodings[body->encoding]);
+   if (body->id) sprintf (*dst += strlen (*dst),"Content-ID: %s\015\012",
+ 			 body->id);
+   if (body->description)
+     sprintf (*dst += strlen (*dst),"Content-Description: %s\015\012",
+ 	     body->description);
+   if (body->md5)
+     sprintf (*dst += strlen (*dst),"Content-MD5: %s\015\012",body->md5);
+   if (stl = body->language) {
+     strcpy (*dst += strlen (*dst),"Content-Language: ");
+     do {
+       rfc822_cat (*dst,stl->text.data,tspecials);
+       if (stl = stl->next) strcat (*dst += strlen (*dst),", ");
+     }
+     while (stl);
+     strcpy (*dst += strlen (*dst),"\015\012");
+   }
+   if (body->disposition.type) {
+     sprintf (*dst += strlen (*dst),"Content-Disposition: %s",
+ 	     body->disposition.type);
+     if (param = body->disposition.parameter) do {
+       sprintf (*dst += strlen (*dst),"; %s=",param->attribute);
+       rfc822_cat (*dst,param->value,tspecials);
+     } while (param = param->next);
+     strcpy (*dst += strlen (*dst),"\015\012");
+   }
+ }
+ 
+ 
+ /* Subtype defaulting (a no-no, but regretably necessary...)
+  * Accepts: type code
+  * Returns: default subtype name
+  */
+ 
+ char *rfc822_default_subtype (unsigned short type)
+ {
+   switch (type) {
+   case TYPETEXT:		/* default is TEXT/PLAIN */
+     return "PLAIN";
+   case TYPEMULTIPART:		/* default is MULTIPART/MIXED */
+     return "MIXED";
+   case TYPEMESSAGE:		/* default is MESSAGE/RFC822 */
+     return "RFC822";
+   case TYPEAPPLICATION:		/* default is APPLICATION/OCTET-STREAM */
+     return "OCTET-STREAM";
+   case TYPEAUDIO:		/* default is AUDIO/BASIC */
+     return "BASIC";
+   default:			/* others have no default subtype */
+     return "UNKNOWN";
+   }
+ }
+ 
+ /* RFC822 parsing routines */
+ 
+ 
+ /* Parse an RFC822 message
+  * Accepts: pointer to return envelope
+  *	    pointer to return body
+  *	    pointer to header
+  *	    header byte count
+  *	    pointer to body stringstruct
+  *	    pointer to local host name
+  *	    source driver flags
+  */
+ 
+ void rfc822_parse_msg (ENVELOPE **en,BODY **bdy,char *s,unsigned long i,
+ 		       STRING *bs,char *host,unsigned long flags)
+ {
+   char c,*t,*d;
+   char *tmp = (char *) fs_get ((size_t) i + 100);
+   ENVELOPE *env = (*en = mail_newenvelope ());
+   BODY *body = bdy ? (*bdy = mail_newbody ()) : NIL;
+   long MIMEp = NIL;		/* flag that MIME semantics are in effect */
+   long PathP = NIL;		/* flag that a Path: was seen */
+   while (i && *s != '\n') {	/* until end of header */
+     t = tmp;			/* initialize buffer pointer */
+     c = ' ';			/* and previous character */
+     while (i && c) {		/* collect text until logical end of line */
+       switch (c = *s++) {	/* slurp a character */
+       case '\015':		/* return, possible end of logical line */
+ 	if (*s == '\n') break;	/* ignore if LF follows */
+       case '\012':		/* LF, possible end of logical line */
+ 				/* tie off unless next line starts with WS */
+ 	if (*s != ' ' && *s != '\t') *t++ = c = '\0';
+ 	break;
+       case '\t':		/* tab */
+ 	*t++ = ' ';		/* coerce to space */
+ 	break;
+       default:			/* all other characters */
+ 	*t++ = c;		/* insert the character into the line */
+ 	break;
+       }
+       if (!--i) *t++ = '\0';	/* see if end of header */
+     }
+ 
+ 				/* find header item type */
+     if (t = d = strchr (tmp,':')) {
+       *d++ = '\0';		/* tie off header item, point at its data */
+       while (*d == ' ') d++;	/* flush whitespace */
+       while ((tmp < t--) && (*t == ' ')) *t = '\0';
+       switch (*ucase (tmp)) {	/* dispatch based on first character */
+       case '>':			/* possible >From: */
+ 	if (!strcmp (tmp+1,"FROM")) rfc822_parse_adrlist (&env->from,d,host);
+ 	break;
+       case 'B':			/* possible bcc: */
+ 	if (!strcmp (tmp+1,"CC")) rfc822_parse_adrlist (&env->bcc,d,host);
+ 	break;
+       case 'C':			/* possible cc: or Content-<mumble>*/
+ 	if (!strcmp (tmp+1,"C")) rfc822_parse_adrlist (&env->cc,d,host);
+ 	else if ((tmp[1] == 'O') && (tmp[2] == 'N') && (tmp[3] == 'T') &&
+ 		 (tmp[4] == 'E') && (tmp[5] == 'N') && (tmp[6] == 'T') &&
+ 		 (tmp[7] == '-') && body &&
+ 		 (MIMEp || (search (s-1,i,"\012MIME-Version",(long) 13))))
+ 	  rfc822_parse_content_header (body,tmp+8,d);
+ 	break;
+       case 'D':			/* possible Date: */
+ 	if (!env->date && !strcmp (tmp+1,"ATE")) env->date = cpystr (d);
+ 	break;
+       case 'F':			/* possible From: */
+ 	if (!strcmp (tmp+1,"ROM")) rfc822_parse_adrlist (&env->from,d,host);
+ 	else if (!strcmp (tmp+1,"OLLOWUP-TO")) {
+ 	  t = env->followup_to = (char *) fs_get (1 + strlen (d));
+ 	  while (c = *d++) if (c != ' ') *t++ = c;
+ 	  *t++ = '\0';
+ 	}
+ 	break;
+       case 'I':			/* possible In-Reply-To: */
+ 	if (!env->in_reply_to && !strcmp (tmp+1,"N-REPLY-TO"))
+ 	  env->in_reply_to = cpystr (d);
+ 	break;
+       case 'M':			/* possible Message-ID: or MIME-Version: */
+ 	if (!env->message_id && !strcmp (tmp+1,"ESSAGE-ID"))
+ 	  env->message_id = cpystr (d);
+ 	else if (!strcmp (tmp+1,"IME-VERSION")) {
+ 				/* tie off at end of phrase */
+ 	  if (t = rfc822_parse_phrase (d)) *t = '\0';
+ 	  rfc822_skipws (&d);	/* skip whitespace */
+ 				/* known version? */
+ 	  if (strcmp (d,"1.0") && strcmp (d,"RFC-XXXX"))
+ 	    mm_log ("Warning: message has unknown MIME version",PARSE);
+ 	  MIMEp = T;		/* note that we are MIME */
+ 	}
+ 	break;
+       case 'N':			/* possible Newsgroups: */
+ 	if (!env->newsgroups && !strcmp (tmp+1,"EWSGROUPS")) {
+ 	  t = env->newsgroups = (char *) fs_get (1 + strlen (d));
+ 	  while (c = *d++) if (c != ' ') *t++ = c;
+ 	  *t++ = '\0';
+ 	}
+ 	break;
+ 
+       case 'P':			/* possible Path: */
+ 	if (!strcmp (tmp+1,"ATH")) PathP = T;
+ 	break;
+       case 'R':			/* possible Reply-To: */
+ 	if (!strcmp (tmp+1,"EPLY-TO"))
+ 	  rfc822_parse_adrlist (&env->reply_to,d,host);
+ 	else if (!env->references && !strcmp (tmp+1,"EFERENCES"))
+ 	  env->references = cpystr (d);
+ 	break;
+       case 'S':			/* possible Subject: or Sender: */
+ 	if (!env->subject && !strcmp (tmp+1,"UBJECT"))
+ 	  env->subject = cpystr (d);
+ 	else if (!strcmp (tmp+1,"ENDER"))
+ 	  rfc822_parse_adrlist (&env->sender,d,host);
+ 	break;
+       case 'T':			/* possible To: */
+ 	if (!strcmp (tmp+1,"O")) rfc822_parse_adrlist (&env->to,d,host);
+ 	break;
+       default:
+ 	break;
+       }
+     }
+   }
+   /* We require a Path: header and/or a Message-ID belonging to a known
+    * winning mail program, in order to believe Newsgroups:.  This is because
+    * of the unfortunate existance of certain cretins who believe that it
+    * is reasonable to transmit messages via SMTP with a "Newsgroups" header
+    * that were not actually posted to any of the named newsgroups.
+    * The authors of other high-quality email/news software are encouraged to
+    * use similar methods to indentify messages as coming from their software,
+    * and having done so, to tell us so they too can be blessed in this list.
+    */
+   if (env->newsgroups && !PathP && env->message_id &&
+       strncmp (env->message_id,"<Pine.",6) &&
+       strncmp (env->message_id,"<MS-C.",6) &&
+       strncmp (env->message_id,"<MailManager.",13) &&
+       strncmp (env->message_id,"<EasyMail.",11) &&
+       strncmp (env->message_id,"<ML-",4)) {
+     sprintf (tmp,"Probable bogus newsgroup list \"%s\" in \"%s\" ignored",
+ 	     env->newsgroups,env->message_id);
+     mm_log (tmp,PARSE);
+     fs_give ((void **) &env->newsgroups);
+   }
+   fs_give ((void **) &tmp);	/* done with scratch buffer */
+ 				/* default Sender: and Reply-To: to From: */
+   if (!env->sender) env->sender = rfc822_cpy_adr (env->from);
+   if (!env->reply_to) env->reply_to = rfc822_cpy_adr (env->from);
+ 				/* now parse the body */
+   if (body) rfc822_parse_content (body,bs,host,flags);
+ }
+ 
+ /* Parse a message body content
+  * Accepts: pointer to body structure
+  *	    body string
+  *	    pointer to local host name
+  *	    source driver flags
+  */
+ 
+ void rfc822_parse_content (BODY *body,STRING *bs,char *h,unsigned long flags)
+ {
+   char c,c1,*s,*s1;
+   int f;
+   unsigned long i,j,k,m;
+   PARAMETER *param;
+   PART *part = NIL;
+   if (!body->subtype)		/* default subtype if still unknown */
+     body->subtype = cpystr (rfc822_default_subtype (body->type));
+ 				/* note offset and sizes */
+   body->contents.offset = GETPOS (bs);
+ 				/* note internal body size in all cases */
+   body->size.bytes = body->contents.text.size = i = SIZE (bs);
+   if (!(flags & DR_CRLF)) body->size.bytes = strcrlflen (bs);
+   switch (body->type) {		/* see if anything else special to do */
+   case TYPETEXT:		/* text content */
+     if (!body->parameter) {	/* default parameters */
+       body->parameter = mail_newbody_parameter ();
+       body->parameter->attribute = cpystr ("CHARSET");
+       body->parameter->value = cpystr ("US-ASCII");
+     }
+ 				/* count number of lines */
+     while (i--) if ((SNX (bs)) == '\n') body->size.lines++;
+     break;
+ 
+   case TYPEMESSAGE:		/* encapsulated message */
+     body->nested.msg = mail_newmsg ();
+ 				/* encapsulated RFC-822 message? */
+     if (!strcmp (body->subtype,"RFC822")) {
+       if ((body->encoding == ENCBASE64) ||
+ 	  (body->encoding == ENCQUOTEDPRINTABLE)
+ 	  || (body->encoding == ENCOTHER))
+ 	mm_log ("Ignoring nested encoding of message contents",PARSE);
+ 				/* hunt for blank line */
+       for (c = '\012',j = 0; (i > j) && ((c != '\012') || (CHR(bs) != '\012'));
+ 	   j++) if ((c1 = SNX (bs)) != '\015') c = c1;
+       if (i > j) {		/* unless no more text */
+ 	c1 = SNX (bs);		/* body starts here */
+ 	j++;			/* advance count */
+       }
+ 				/* note body text offset and header size */
+       body->nested.msg->header.text.size = j;
+       body->nested.msg->text.text.size = body->contents.text.size - j;
+       body->nested.msg->text.offset = GETPOS (bs);
+       body->nested.msg->full.offset = body->nested.msg->header.offset =
+ 	body->contents.offset;
+       body->nested.msg->full.text.size = body->contents.text.size;
+ 				/* copy header string */
+       SETPOS (bs,body->contents.offset);
+       s = (char *) fs_get ((size_t) j + 1);
+       for (s1 = s,k = j; k--; *s1++ = SNX (bs));
+       s[j] = '\0';		/* tie off string (not really necessary) */
+ 				/* now parse the body */
+       rfc822_parse_msg (&body->nested.msg->env,&body->nested.msg->body,s,j,bs,
+ 			h,flags);
+       fs_give ((void **) &s);	/* free header string */
+ 				/* restore position */
+       SETPOS (bs,body->contents.offset);
+     }
+ 				/* count number of lines */
+     while (i--) if (SNX (bs) == '\n') body->size.lines++;
+     break;
+   case TYPEMULTIPART:		/* multiple parts */
+ 				/* remember if digest */
+     f = !strcmp (body->subtype,"DIGEST");
+     if ((body->encoding == ENCBASE64) || (body->encoding == ENCQUOTEDPRINTABLE)
+ 	|| (body->encoding == ENCOTHER))
+       mm_log ("Ignoring nested encoding of multipart contents",PARSE);
+ 				/* find cookie */
+     for (s1 = NIL,param = body->parameter; param && !s1; param = param->next)
+       if (!strcmp (param->attribute,"BOUNDARY")) s1 = param->value;
+     if (!(s1 && *s1)) s1 = "-";	/* yucky default */
+     j = strlen (s1);		/* length of cookie and header */
+     c = '\012';			/* initially at beginning of line */
+ 
+     while (i > j) {		/* examine data */
+       if (m = GETPOS (bs)) m--;	/* get position in front of character */
+       switch (c) {		/* examine each line */
+       case '\015':		/* handle CRLF form */
+ 	if (CHR (bs) == '\012'){/* following LF? */
+ 	  c = SNX (bs); i--;	/* yes, slurp it */
+ 	}
+       case '\012':		/* at start of a line, start with -- ? */
+ 	if (i-- && ((c = SNX (bs)) == '-') && i-- && ((c = SNX (bs)) == '-')) {
+ 				/* see if cookie matches */
+ 	  for (k = j,s = s1; i-- && *s++ == (c = SNX (bs)) && --k;);
+ 	  if (k) break;		/* strings didn't match if non-zero */
+ 				/* look at what follows cookie */
+ 	  if (i && i--) switch (c = SNX (bs)) {
+ 	  case '-':		/* at end if two dashes */
+ 	    if ((i && i--) && ((c = SNX (bs)) == '-') &&
+ 		((i && i--) ? (((c = SNX (bs)) == '\015') || (c=='\012')):T)) {
+ 				/* if have a final part calculate its size */
+ 	      if (part) part->body.mime.text.size =
+ 		(m > part->body.mime.offset) ? (m - part->body.mime.offset) :0;
+ 	      part = NIL; i = 1; /* terminate scan */
+ 	    }
+ 	    break;
+ 	  case '\015':		/* handle CRLF form */
+ 	    if (i && CHR (bs) == '\012') {
+ 	      c = SNX (bs); i--;/* yes, slurp it */
+ 	    }
+ 	  case '\012':		/* new line */
+ 	    if (part) {		/* calculate size of previous */
+ 	      part->body.mime.text.size =
+ 		(m > part->body.mime.offset) ? (m-part->body.mime.offset) : 0;
+ 				/* instantiate next */
+ 	      part = part->next = mail_newbody_part ();
+ 	    }			/* otherwise start new list */
+ 	    else part = body->nested.part = mail_newbody_part ();
+ 				/* digest has a different default */
+ 	    if (f) part->body.type = TYPEMESSAGE;
+ 				/* note offset from main body */
+ 	    part->body.mime.offset = GETPOS (bs);
+ 	    break;
+ 	  default:		/* whatever it was it wasn't valid */
+ 	    break;
+ 	  }
+ 	}
+ 	break;
+       default:			/* not at a line */
+ 	c = SNX (bs); i--;	/* get next character */
+ 	break;
+       }
+     }
+ 
+ 				/* calculate size of any final part */
+     if (part) part->body.mime.text.size = i +
+       ((GETPOS(bs) > part->body.mime.offset) ?
+        (GETPOS(bs) - part->body.mime.offset) : 0);
+ 				/* make a scratch buffer */
+     s1 = (char *) fs_get ((size_t) (k = MAILTMPLEN));
+ 				/* parse non-empty body parts */
+     for (part = body->nested.part; part; part = part->next) {
+       if (i = part->body.mime.text.size) {
+ 				/* move to that part of the body */
+ 	SETPOS (bs,part->body.mime.offset);
+ 				/* until end of header */
+ 	while (i && ((c = CHR (bs)) != '\015') && (c != '\012')) {
+ 				/* collect text until logical end of line */
+ 	  for (j = 0,c = ' '; c; ) {
+ 				/* make sure buffer big enough */
+ 	    if (j > (k - 10)) fs_resize ((void *) &s1,k += MAILTMPLEN);
+ 	    switch (c1 = SNX (bs)) {
+ 	    case '\015':	/* return */
+ 	      if (i && (CHR (bs) == '\012')) {
+ 		c1 = SNX (bs);	/* eat any LF following */
+ 		i--;
+ 	      }
+ 	    case '\012':	/* newline, possible end of logical line */
+ 				/* tie off unless continuation */
+ 	      if (!i || ((CHR (bs) != ' ') && (CHR (bs) != '\t')))
+ 		s1[j] = c = '\0';
+ 	      break;
+ 	    case '\t':		/* tab */
+ 	    case ' ':		/* insert whitespace if not already there */
+ 	      if (c != ' ') s1[j++] = c = ' ';
+ 	      break;
+ 	    default:		/* all other characters */
+ 	      s1[j++] = c = c1;	/* insert the character into the line */
+ 	      break;
+ 	    }
+ 				/* end of data ties off the header */
+ 	    if (!--i) s1[j++] = c = '\0';
+ 	  }
+ 
+ 				/* find header item type */
+ 	  if (((s1[0] == 'C') || (s1[0] == 'c')) &&
+ 	      ((s1[1] == 'O') || (s1[1] == 'o')) &&
+ 	      ((s1[2] == 'N') || (s1[2] == 'n')) &&
+ 	      ((s1[3] == 'T') || (s1[3] == 't')) &&
+ 	      ((s1[4] == 'E') || (s1[4] == 'e')) &&
+ 	      ((s1[5] == 'N') || (s1[5] == 'n')) &&
+ 	      ((s1[6] == 'T') || (s1[6] == 't')) &&
+ 	      (s1[7] == '-') && (s = strchr (s1+8,':'))) {
+ 				/* tie off and flush whitespace */
+ 	    for (*s++ = '\0'; *s == ' '; s++);
+ 				/* parse the header */
+ 	    rfc822_parse_content_header (&part->body,ucase (s1+8),s);
+ 	  }
+ 	}
+ 				/* skip header trailing (CR)LF */
+ 	if (i && (CHR (bs) =='\015')) {i--; c1 = SNX (bs);}
+ 	if (i && (CHR (bs) =='\012')) {i--; c1 = SNX (bs);}
+ 	j = bs->size;		/* save upper level size */
+ 				/* set offset for next level, fake size to i */
+ 	bs->size = GETPOS (bs) + i;
+ 	part->body.mime.text.size -= i;
+ 				/* now parse it */
+ 	rfc822_parse_content (&part->body,bs,h,flags);
+ 	bs->size = j;		/* restore current level size */
+       }
+       else part->body.subtype =	/* default subtype if necessary */
+ 	cpystr (rfc822_default_subtype (part->body.type));
+     }
+     fs_give ((void **) &s1);	/* finished with scratch buffer */
+     break;
+   default:			/* nothing special to do in any other case */
+     break;
+   }
+ }
+ 
+ /* Parse RFC822 body content header
+  * Accepts: body to write to
+  *	    possible content name
+  *	    remainder of header
+  */
+ 
+ void rfc822_parse_content_header (BODY *body,char *name,char *s)
+ {
+   char c,*t;
+   long i;
+   STRINGLIST *stl;
+ 				/* flush whitespace */
+   if (t = strchr (name,' ')) *t = '\0';
+   switch (*name) {		/* see what kind of content */
+   case 'I':			/* possible Content-ID */
+     if (!(strcmp (name+1,"D") || body->id)) body->id = cpystr (s);
+     break;
+   case 'D':			/* possible Content-Description */
+     if (!(strcmp (name+1,"ESCRIPTION") || body->description))
+       body->description = cpystr (s);
+     if (!(strcmp (name+1,"ISPOSITION") || body->disposition.type)) {
+ 				/* get type word */
+       if (!(name = rfc822_parse_word (s,ptspecials))) break;
+       c = *name;		/* remember delimiter */
+       *name = '\0';		/* tie off type */
+       body->disposition.type = ucase (cpystr (s));
+       *name = c;		/* restore delimiter */
+       rfc822_skipws (&name);	/* skip whitespace */
+       rfc822_parse_parameter (&body->disposition.parameter,name);
+     }
+     break;
+   case 'L':			/* possible Content-Language */
+     if (!(strcmp (name+1,"ANGUAGE") || body->language)) {
+       stl = NIL;		/* process languages */
+       while (s && (name = rfc822_parse_word (s,ptspecials))) {
+ 	c = *name;		/* save delimiter */
+ 	*name = '\0';		/* tie off subtype */
+ 	if (stl) stl = stl->next = mail_newstringlist ();
+ 	else stl = body->language = mail_newstringlist ();
+ 	stl->text.data = ucase (cpystr (s));
+ 	stl->text.size = strlen (stl->text.data);
+ 	*name = c;		/* restore delimiter */
+ 	rfc822_skipws (&name);	/* skip whitespace */
+ 	if (*name == ',') {	/* any more languages? */
+ 	  s = ++name;		/* advance to it them */
+ 	  rfc822_skipws (&s);
+ 	}
+ 	else s = NIL;		/* bogus or end of list */
+       }
+     }
+     break;
+   case 'M':			/* possible Content-MD5 */
+     if (!(strcmp (name+1,"D5") || body->md5)) body->md5 = cpystr (s);
+     break;
+ 
+   case 'T':			/* possible Content-Type/Transfer-Encoding */
+     if (!(strcmp (name+1,"YPE") || body->subtype || body->parameter)) {
+ 				/* get type word */
+       if (!(name = rfc822_parse_word (s,ptspecials))) break;
+       c = *name;		/* remember delimiter */
+       *name = '\0';		/* tie off type */
+       ucase (s);		/* search for body type */
+       for (i=0; (i<=TYPEMAX) && body_types[i] && strcmp(s,body_types[i]); i++);
+       if (i > TYPEMAX) body->type = TYPEOTHER;
+       else {			/* if empty slot, assign it to this type */
+ 	if (!body_types[i]) body_types[i] = cpystr (s);
+ 	body->type = (unsigned short) i;
+       }
+       *name = c;		/* restore delimiter */
+       rfc822_skipws (&name);	/* skip whitespace */
+       if ((*name == '/') &&	/* subtype? */
+ 	  (name = rfc822_parse_word ((s = ++name),ptspecials))) {
+ 	c = *name;		/* save delimiter */
+ 	*name = '\0';		/* tie off subtype */
+ 	rfc822_skipws (&s);	/* copy subtype */
+ 	if (s) body->subtype = ucase (cpystr (s));
+ 	*name = c;		/* restore delimiter */
+ 	rfc822_skipws (&name);	/* skip whitespace */
+       }
+       else {			/* no subtype */
+ 	if (!name) {		/* did the fool have a subtype delimiter? */
+ 	  name = s;		/* barf, restore pointer */
+ 	  rfc822_skipws (&name);/* skip leading whitespace */
+ 	}
+       }
+       rfc822_parse_parameter (&body->parameter,name);
+     }
+     else if (!strcmp (name+1,"RANSFER-ENCODING")) {
+ 				/* flush out any confusing whitespace */
+       if (t = strchr (ucase (s),' ')) *t = '\0';
+ 				/* search for body encoding */
+       for (i = 0; (i <= ENCMAX) && body_encodings[i] &&
+ 	   strcmp (s,body_encodings[i]); i++);
+       if (i > ENCMAX) body->type = ENCOTHER;
+       else {			/* if empty slot, assign it to this type */
+ 	if (!body_encodings[i]) body_encodings[i] = cpystr (s);
+ 	body->encoding = (unsigned short) i;
+       }
+     }
+     break;
+   default:			/* otherwise unknown */
+     break;
+   }
+ }
+ 
+ /* Parse RFC822 body parameter list
+  * Accepts: parameter list to write to
+  *	    text of list
+  */
+ 
+ void rfc822_parse_parameter (PARAMETER **par,char *text)
+ {
+   char c,*s,tmp[MAILTMPLEN];
+   PARAMETER *param = NIL;
+ 				/* parameter list? */
+   while (text && (*text == ';') &&
+ 	 (text = rfc822_parse_word ((s = ++text),ptspecials))) {
+     c = *text;			/* remember delimiter */
+     *text = '\0';		/* tie off attribute name */
+     rfc822_skipws (&s);		/* skip leading attribute whitespace */
+     if (!*s) *text = c;		/* must have an attribute name */
+     else {			/* instantiate a new parameter */
+       if (*par) param = param->next = mail_newbody_parameter ();
+       else param = *par = mail_newbody_parameter ();
+       param->attribute = ucase (cpystr (s));
+       *text = c;		/* restore delimiter */
+       rfc822_skipws (&text);	/* skip whitespace before equal sign */
+       if ((*text != '=') ||	/* missing value is a no-no too */
+ 	  !(text = rfc822_parse_word ((s = ++text),ptspecials)))
+ 	param->value = cpystr ("UNKNOWN_PARAMETER_VALUE");
+       else {			/* good, have equals sign */
+ 	c = *text;		/* remember delimiter */
+ 	*text = '\0';		/* tie off value */
+ 	rfc822_skipws (&s);	/* skip leading value whitespace */
+ 	if (*s) param->value = rfc822_cpy (s);
+ 	*text = c;		/* restore delimiter */
+ 	rfc822_skipws (&text);
+       }
+     }
+   }
+   if (!text) {			/* must be end of poop */
+     if (param && param->attribute)
+       sprintf (tmp,"Missing parameter value: %.80s",param->attribute);
+     else strcpy (tmp,"Missing parameter");
+     mm_log (tmp,PARSE);
+   }
+   else if (*text) {		/* must be end of poop */
+     sprintf (tmp,"Unexpected characters at end of parameters: %.80s",text);
+     mm_log (tmp,PARSE);
+   }
+ }
+ 
+ /* Parse RFC822 address list
+  * Accepts: address list to write to
+  *	    input string
+  *	    default host name
+  */
+ 
+ void rfc822_parse_adrlist (ADDRESS **lst,char *string,char *host)
+ {
+   char c,*s,tmp[MAILTMPLEN];
+   ADDRESS *last = *lst;
+   ADDRESS *adr;
+   if (!string) return;		/* no string */
+   rfc822_skipws (&string);	/* skip leading WS */
+   if (!*string) return;		/* empty string */
+ 				/* run to tail of list */
+   if (last) while (last->next) last = last->next;
+   while (string) {		/* loop until string exhausted */
+ 				/* got an address? */
+     if (adr = rfc822_parse_address (lst,last,&string,host)) {
+       last = adr;
+       if (string) {		/* analyze what follows */
+ 	rfc822_skipws (&string);
+ 	switch (c = *string) {
+ 	case ',':		/* comma? */
+ 	  ++string;		/* then another address follows */
+ 	  break;
+ 	default:
+ 	  s = isalnum (c) ? "Must use comma to separate addresses: %.80s" :
+ 	    "Unexpected characters at end of address: %.80s";
+ 	  sprintf (tmp,s,string);
+ 	  mm_log (tmp,PARSE);
+ 	  last = last->next = mail_newaddr ();
+ 	  last->mailbox = cpystr ("UNEXPECTED_DATA_AFTER_ADDRESS");
+ 	  last->host = cpystr (errhst);
+ 				/* falls through */
+ 	case '\0':		/* null-specified address? */
+ 	  string = NIL;		/* punt remainder of parse */
+ 	  break;
+ 	}
+       }
+     }
+     else if (string) {		/* bad mailbox */
+       rfc822_skipws (&string);	/* skip WS */
+       if (!*string) strcpy (tmp,"Missing address after comma");
+       else sprintf (tmp,"Invalid mailbox list: %.80s",string);
+       mm_log (tmp,PARSE);
+       string = NIL;
+       (adr = mail_newaddr ())->mailbox = cpystr ("INVALID_ADDRESS");
+       adr->host = cpystr (errhst);
+       if (last) last = last->next = adr;
+       else *lst = last = adr;
+       break;
+     }
+   }
+ }
+ 
+ /* Parse RFC822 address
+  * Accepts: address list to write to
+  *	    tail of address list
+  *	    pointer to input string
+  *	    default host name
+  */
+ 
+ ADDRESS *rfc822_parse_address (ADDRESS **lst,ADDRESS *last,char **string,
+ 			       char *defaulthost)
+ {
+   ADDRESS *adr;
+   if (!*string) return NIL;	/* no string */
+   rfc822_skipws (string);	/* skip leading WS */
+   if (!**string) return NIL;	/* empty string */
+   if (adr = rfc822_parse_group (lst,last,string,defaulthost)) last = adr;
+ 				/* got an address? */
+   else if (adr = rfc822_parse_mailbox (string,defaulthost)) {
+     if (!*lst) *lst = adr;	/* yes, first time through? */
+     else last->next = adr;	/* no, append to the list */
+     last = adr;			/* set for subsequent linking */
+   }
+   else if (*string) return NIL;
+   return last;
+ }
+ 
+ /* Parse RFC822 group
+  * Accepts: address list to write to
+  *	    pointer to tail of address list
+  *	    pointer to input string
+  *	    default host name
+  */
+ 
+ ADDRESS *rfc822_parse_group (ADDRESS **lst,ADDRESS *last,char **string,
+ 			     char *defaulthost)
+ {
+   char tmp[MAILTMPLEN];
+   char *p,*s;
+   ADDRESS *adr;
+   if (!*string) return NIL;	/* no string */
+   rfc822_skipws (string);	/* skip leading WS */
+   if (!**string ||		/* trailing whitespace or not group */
+       ((*(p = *string) != ':') && !(p = rfc822_parse_phrase (*string))))
+     return NIL;
+   s = p;			/* end of candidate phrase */
+   rfc822_skipws (&s);		/* find delimiter */
+   if (*s != ':') return NIL;	/* not really a group */
+   *p = '\0';			/* tie off group name */
+   p = ++s;			/* continue after the delimiter */
+   rfc822_skipws (&p);		/* skip subsequent whitespace */
+ 				/* write as address */
+   (adr = mail_newaddr ())->mailbox = rfc822_cpy (*string);
+   if (!*lst) *lst = adr;	/* first time through? */
+   else last->next = adr;	/* no, append to the list */
+   last = adr;			/* set for subsequent linking */
+   *string = p;			/* continue after this point */
+   while (*string && **string && (**string != ';')) {
+     if (adr = rfc822_parse_address (lst,last,string,defaulthost)) {
+       last = adr;
+       if (*string) {		/* anything more? */
+ 	rfc822_skipws (string);	/* skip whitespace */
+ 	switch (**string) {	/* see what follows */
+ 	case ',':		/* another address? */
+ 	  ++*string;		/* yes, skip past the comma */
+ 	case ';':		/* end of group? */
+ 	case '\0':		/* end of string */
+ 	  break;
+ 	default:
+ 	  sprintf (tmp,"Unexpected characters after address in group: %.80s",
+ 		   *string);
+ 	  mm_log (tmp,PARSE);
+ 	  *string = NIL;	/* cancel remainder of parse */
+ 	  last = last->next = mail_newaddr ();
+ 	  last->mailbox = cpystr ("UNEXPECTED_DATA_AFTER_ADDRESS_IN_GROUP");
+ 	  last->host = cpystr (errhst);
+ 	}
+       }
+     }
+     else {			/* bogon */
+       sprintf (tmp,"Invalid group mailbox list: %.80s",*string);
+       mm_log (tmp,PARSE);
+       *string = NIL;		/* cancel remainder of parse */
+       (adr = mail_newaddr ())->mailbox = cpystr ("INVALID_ADDRESS_IN_GROUP");
+       adr->host = cpystr (errhst);
+       last = last->next = adr;
+     }
+   }
+   if (*string) {		/* skip close delimiter */
+     if (**string == ';') ++*string;
+     rfc822_skipws (string);
+   }
+ 				/* append end of address mark to the list */
+   last->next = (adr = mail_newaddr ());
+   last = adr;			/* set for subsequent linking */
+   return last;			/* return the tail */
+ }
+ 
+ /* Parse RFC822 mailbox
+  * Accepts: pointer to string pointer
+  *	    default host
+  * Returns: address
+  *
+  * Updates string pointer
+  */
+ 
+ ADDRESS *rfc822_parse_mailbox (char **string,char *defaulthost)
+ {
+   ADDRESS *adr;
+   char *s,*phrase;
+   if (!*string) return NIL;	/* no string */
+   rfc822_skipws (string);	/* flush leading whitespace */
+   if (!**string) return NIL;	/* empty string */
+ 
+   /* This is much more complicated than it should be because users like
+    * to write local addrspecs without "@localhost".  This makes it very
+    * difficult to tell a phrase from an addrspec!
+    * The other problem we must cope with is a route-addr without a leading
+    * phrase.  Yuck!
+    */
+ 
+   if (*(s = *string) == '<') 	/* note start, handle case of phraseless RA */
+     adr = rfc822_parse_routeaddr (s,string,defaulthost);
+   else {			/* get phrase if any */
+     if ((phrase = rfc822_parse_phrase (s)) &&
+ 	(adr = rfc822_parse_routeaddr (phrase,string,defaulthost))) {
+       *phrase = '\0';		/* tie off phrase */
+ 				/* phrase is a personal name */
+       adr->personal = rfc822_cpy (s);
+     }
+     else adr = rfc822_parse_addrspec (s,string,defaulthost);
+   }
+   return adr;			/* return the address */
+ }
+ 
+ /* Parse RFC822 route-address
+  * Accepts: string pointer
+  *	    pointer to string pointer to update
+  * Returns: address
+  *
+  * Updates string pointer
+  */
+ 
+ ADDRESS *rfc822_parse_routeaddr (char *string,char **ret,char *defaulthost)
+ {
+   char tmp[MAILTMPLEN];
+   ADDRESS *adr;
+   char *adl = NIL;
+   char *routeend = NIL;
+   if (!string) return NIL;
+   rfc822_skipws (&string);	/* flush leading whitespace */
+ 				/* must start with open broket */
+   if (*string != '<') return NIL;
+   if (string[1] == '@') {	/* have an A-D-L? */
+     adl = ++string;		/* yes, remember that fact */
+     while (*string != ':') {	/* search for end of A-D-L */
+ 				/* punt if never found */
+       if (!*string) return NIL;
+       ++string;			/* try next character */
+     }
+     *string = '\0';		/* tie off A-D-L */
+     routeend = string;		/* remember in case need to put back */
+   }
+ 				/* parse address spec */
+   if (!(adr = rfc822_parse_addrspec (++string,ret,defaulthost))) {
+     if (adl) *routeend = ':';	/* put colon back since parse barfed */
+     return NIL;
+   }
+ 				/* have an A-D-L? */
+   if (adl) adr->adl = cpystr (adl);
+   if (*ret) if (**ret == '>') {	/* make sure terminated OK */
+     ++*ret;			/* skip past the broket */
+     rfc822_skipws (ret);	/* flush trailing WS */
+     if (!**ret) *ret = NIL;	/* wipe pointer if at end of string */
+     return adr;			/* return the address */
+   }
+   sprintf (tmp,"Unterminated mailbox: %.80s@%.80s",adr->mailbox,
+ 	   *adr->host == '@' ? "<null>" : adr->host);
+   mm_log (tmp,PARSE);
+   adr->next = mail_newaddr ();
+   adr->next->mailbox = cpystr ("MISSING_MAILBOX_TERMINATOR");
+   adr->next->host = cpystr (errhst);
+   return adr;			/* return the address */
+ }
+ 
+ /* Parse RFC822 address-spec
+  * Accepts: string pointer
+  *	    pointer to string pointer to update
+  *	    default host
+  * Returns: address
+  *
+  * Updates string pointer
+  */
+ 
+ ADDRESS *rfc822_parse_addrspec (char *string,char **ret,char *defaulthost)
+ {
+   ADDRESS *adr;
+   char *end;
+   char c,*s,*t;
+   if (!string) return NIL;	/* no string */
+   rfc822_skipws (&string);	/* flush leading whitespace */
+   if (!*string) return NIL;	/* empty string */
+ 				/* find end of mailbox */
+   if (!(end = rfc822_parse_word (string,NIL))) return NIL;
+   adr = mail_newaddr ();	/* create address block */
+   c = *end;			/* remember delimiter */
+   *end = '\0';			/* tie off mailbox */
+ 				/* copy mailbox */
+   adr->mailbox = rfc822_cpy (string);
+   *end = c;			/* restore delimiter */
+   t = end;			/* remember end of mailbox for no host case */
+   rfc822_skipws (&end);		/* skip whitespace */
+   if (*end == '@') {		/* have host name? */
+     ++end;			/* skip delimiter */
+     rfc822_skipws (&end);	/* skip whitespace */
+     if (*end == '[') {		/* domain literal? */
+       string = end;		/* start of domain literal */
+       if (end = rfc822_parse_word (string + 1,"]\\")) {
+ 	c = end[1];		/* tie off literal */
+ 	end[1] = '\0';
+ 	adr->host = cpystr (string);
+ 	*++end = c;		/* restore delimiter */
+       }
+       else {
+ 	mm_log ("Invalid domain literal after @",PARSE);
+ 	adr->host = cpystr (errhst);
+       }
+     }
+     				/* search for end of host */
+     else if (end = rfc822_parse_word ((string = end),wspecials)) {
+       c = *end;			/* remember delimiter */
+       *end = '\0';		/* tie off host */
+ 				/* copy host */
+       adr->host = rfc822_cpy (string);
+       *end = c;			/* restore delimiter */
+     }
+     else {
+       mm_log ("Missing or invalid host name after @",PARSE);
+       adr->host = cpystr (errhst);
+     }
+   }
+   else end = t;			/* make person name default start after mbx */
+ 				/* default host if missing */
+   if (!adr->host) adr->host = cpystr (defaulthost);
+   if (end && !adr->personal) {	/* try person name in comments if missing */
+     while (*end == ' ') ++end;	/* see if we can find a person name here */
+     if ((*end == '(') && (s = rfc822_skip_comment (&end,LONGT)) && strlen (s))
+       adr->personal = rfc822_cpy (s);
+     rfc822_skipws (&end);	/* skip any other WS in the normal way */
+   }
+ 				/* set return to end pointer */
+   *ret = (end && *end) ? end : NIL;
+   return adr;			/* return the address we got */
+ }
+ 
+ /* Parse RFC822 phrase
+  * Accepts: string pointer
+  * Returns: pointer to end of phrase
+  */
+ 
+ char *rfc822_parse_phrase (char *s)
+ {
+   char *curpos;
+   if (!s) return NIL;		/* no-op if no string */
+ 				/* find first word of phrase */
+   curpos = rfc822_parse_word (s,NIL);
+   if (!curpos) return NIL;	/* no words means no phrase */
+   if (!*curpos) return curpos;	/* check if string ends with word */
+   s = curpos;			/* sniff past the end of this word and WS */
+   rfc822_skipws (&s);		/* skip whitespace */
+ 				/* recurse to see if any more */
+   return (s = rfc822_parse_phrase (s)) ? s : curpos;
+ }
+ 
+ /* Parse RFC822 word
+  * Accepts: string pointer
+  * Returns: pointer to end of word
+  */
+ 
+ char *rfc822_parse_word (char *s,const char *delimiters)
+ {
+   char *st,*str;
+   if (!s) return NIL;		/* no string */
+   rfc822_skipws (&s);		/* flush leading whitespace */
+   if (!*s) return NIL;		/* empty string */
+ 				/* default delimiters to standard */
+   if (!delimiters) delimiters = wspecials;
+   str = s;			/* hunt pointer for strpbrk */
+   while (T) {			/* look for delimiter */
+     if (!(st = strpbrk (str,delimiters))) {
+       while (*s) ++s;		/* no delimiter, hunt for end */
+       return s;			/* return it */
+     }
+     switch (*st) {		/* dispatch based on delimiter */
+     case '"':			/* quoted string */
+ 				/* look for close quote */
+       while (*++st != '"') switch (*st) {
+       case '\0':		/* unbalanced quoted string */
+ 	return NIL;		/* sick sick sick */
+       case '\\':		/* quoted character */
+ 	if (!*++st) return NIL;	/* skip the next character */
+       default:			/* ordinary character */
+ 	break;			/* no special action */
+       }
+       str = ++st;		/* continue parse */
+       break;
+     case '\\':			/* quoted character */
+       /* This is wrong; a quoted-pair can not be part of a word.  However,
+        * domain-literal is parsed as a word and quoted-pairs can be used
+        * *there*.  Either way, it's pretty pathological.
+        */
+       if (st[1]) {		/* not on NUL though... */
+ 	str = st + 2;		/* skip quoted character and go on */
+ 	break;
+       }
+     default:			/* found a word delimiter */
+       return (st == s) ? NIL : st;
+     }
+   }
+ }
+ 
+ /* Copy an RFC822 format string
+  * Accepts: string
+  * Returns: copy of string
+  */
+ 
+ char *rfc822_cpy (char *src)
+ {
+ 				/* copy and unquote */
+   return rfc822_quote (cpystr (src));
+ }
+ 
+ 
+ /* Unquote an RFC822 format string
+  * Accepts: string
+  * Returns: string
+  */
+ 
+ char *rfc822_quote (char *src)
+ {
+   char *ret = src;
+   if (strpbrk (src,"\\\"")) {	/* any quoting in string? */
+     char *dst = ret;
+     while (*src) {		/* copy string */
+       if (*src == '\"') src++;	/* skip double quote entirely */
+       else {
+ 	if (*src == '\\') src++;/* skip over single quote, copy next always */
+ 	*dst++ = *src++;	/* copy character */
+       }
+     }
+     *dst = '\0';		/* tie off string */
+   }
+   return ret;			/* return our string */
+ }
+ 
+ 
+ /* Copy address list
+  * Accepts: address list
+  * Returns: address list
+  */
+ 
+ ADDRESS *rfc822_cpy_adr (ADDRESS *adr)
+ {
+   ADDRESS *dadr;
+   ADDRESS *ret = NIL;
+   ADDRESS *prev = NIL;
+   while (adr) {			/* loop while there's still an MAP adr */
+     dadr = mail_newaddr ();	/* instantiate a new address */
+     if (!ret) ret = dadr;	/* note return */
+     if (prev) prev->next = dadr;/* tie on to the end of any previous */
+     dadr->personal = cpystr (adr->personal);
+     dadr->adl = cpystr (adr->adl);
+     dadr->mailbox = cpystr (adr->mailbox);
+     dadr->host = cpystr (adr->host);
+     prev = dadr;		/* this is now the previous */
+     adr = adr->next;		/* go to next address in list */
+   }
+   return (ret);			/* return the MTP address list */
+ }
+ 
+ /* Skips RFC822 whitespace
+  * Accepts: pointer to string pointer
+  */
+ 
+ void rfc822_skipws (char **s)
+ {
+   while (T) {
+     if (**s == ' ') ++*s;	/* skip space */
+     else if ((**s != '(') || !rfc822_skip_comment (s,(long) NIL)) return;
+   }
+ }
+ 
+ 
+ /* Skips RFC822 comment
+  * Accepts: pointer to string pointer
+  *	    trim flag
+  * Returns: pointer to first non-blank character of comment
+  */
+ 
+ char *rfc822_skip_comment (char **s,long trim)
+ {
+   char *ret,tmp[MAILTMPLEN];
+   char *s1 = *s;
+   char *t = NIL;
+ 				/* skip past whitespace */
+   for (ret = ++s1; *ret == ' '; ret++);
+   do switch (*s1) {		/* get character of comment */
+   case '(':			/* nested comment? */
+     if (!rfc822_skip_comment (&s1,(long) NIL)) return NIL;
+     t = --s1;			/* last significant char at end of comment */
+     break;
+   case ')':			/* end of comment? */
+     *s = ++s1;			/* skip past end of comment */
+     if (trim) {			/* if level 0, must trim */
+       if (t) t[1] = '\0';	/* tie off comment string */
+       else *ret = '\0';		/* empty comment */
+     }
+     return ret;
+   case '\\':			/* quote next character? */
+     if (*++s1) break;		/* drop in if null seen */
+   case '\0':			/* end of string */
+     sprintf (tmp,"Unterminated comment: %.80s",*s);
+     mm_log (tmp,PARSE);
+     **s = '\0';			/* nuke duplicate messages in case reparse */
+     return NIL;			/* this is wierd if it happens */
+   case ' ':			/* whitespace isn't significant */
+     break;
+   default:			/* random character */
+     t = s1;			/* update last significant character pointer */
+     break;
+   } while (s1++);
+   return NIL;			/* impossible, but pacify lint et al */
+ }
+ 
+ /* Body contents utility and encoding/decoding routines */
+ 
+ 
+ /* Output RFC 822 message
+  * Accepts: temporary buffer
+  *	    envelope
+  *	    body
+  *	    I/O routine
+  *	    stream for I/O routine
+  *	    non-zero if 8-bit output desired
+  * Returns: T if successful, NIL if failure
+  */
+ 
+ long rfc822_output (char *t,ENVELOPE *env,BODY *body,soutr_t f,void *s,
+ 		    long ok8bit)
+ {
+   rfc822out_t r822o = (rfc822out_t) mail_parameters (NIL,GET_RFC822OUTPUT,NIL);
+ 				/* call external RFC822 output generator */
+   if (r822o) return (*r822o) (t,env,body,f,s,ok8bit);
+ 				/* encode body as necessary */
+   if (ok8bit) rfc822_encode_body_8bit (env,body);
+   else rfc822_encode_body_7bit (env,body);
+   rfc822_header (t,env,body);	/* build RFC822 header */
+ 				/* output header and body */
+   return (*f) (s,t) && (body ? rfc822_output_body (body,f,s) : T);
+ }
+ 
+ /* Encode a body for 7BIT transmittal
+  * Accepts: envelope
+  *	    body
+  */
+ 
+ void rfc822_encode_body_7bit (ENVELOPE *env,BODY *body)
+ {
+   void *f;
+   PART *part;
+   PARAMETER **param;
+   if (body) switch (body->type) {
+   case TYPEMULTIPART:		/* multi-part */
+     for (param = &body->parameter;
+ 	 *param && strcmp ((*param)->attribute,"BOUNDARY");
+ 	 param = &(*param)->next);
+     if (!*param) {		/* cookie not set up yet? */
+       char tmp[MAILTMPLEN];	/* make cookie not in BASE64 or QUOTEPRINT*/
+       sprintf (tmp,"%ld-%ld-%ld=:%ld",gethostid (),random (),time (0),
+ 	       getpid ());
+       (*param) = mail_newbody_parameter ();
+       (*param)->attribute = cpystr ("BOUNDARY");
+       (*param)->value = cpystr (tmp);
+     }
+     part = body->nested.part;	/* encode body parts */
+     do rfc822_encode_body_7bit (env,&part->body);
+     while (part = part->next);	/* until done */
+     break;
+   case TYPEMESSAGE:		/* encapsulated message */
+     switch (body->encoding) {
+     case ENC7BIT:
+       break;
+     case ENC8BIT:
+       mm_log ("8-bit included message in 7-bit message body",WARN);
+       break;
+     case ENCBINARY:
+       mm_log ("Binary included message in 7-bit message body",WARN);
+       break;
+     default:
+       fatal ("Invalid rfc822_encode_body_7bit message encoding");
+     }
+     break;			/* can't change encoding */
+   default:			/* all else has some encoding */
+     switch (body->encoding) {
+     case ENC8BIT:		/* encode 8BIT into QUOTED-PRINTABLE */
+ 				/* remember old 8-bit contents */
+       f = (void *) body->contents.text.data;
+       body->contents.text.data = (char *)
+ 	rfc822_8bit ((unsigned char *) body->contents.text.data,
+ 		     body->contents.text.size,&body->contents.text.size);
+       body->encoding = ENCQUOTEDPRINTABLE;
+       fs_give (&f);		/* flush old binary contents */
+       break;
+     case ENCBINARY:		/* encode binary into BASE64 */
+ 				/* remember old binary contents */
+       f = (void *) body->contents.text.data;
+       body->contents.text.data = (char *)
+ 	rfc822_binary ((void *) body->contents.text.data,
+ 		       body->contents.text.size,&body->contents.text.size);
+       body->encoding = ENCBASE64;
+       fs_give (&f);		/* flush old binary contents */
+     default:			/* otherwise OK */
+       break;
+     }
+     break;
+   }
+ }
+ 
+ /* Encode a body for 8BIT transmittal
+  * Accepts: envelope
+  *	    body
+  */
+ 
+ void rfc822_encode_body_8bit (ENVELOPE *env,BODY *body)
+ {
+   void *f;
+   PART *part;
+   PARAMETER **param;
+   if (body) switch (body->type) {
+   case TYPEMULTIPART:		/* multi-part */
+     for (param = &body->parameter;
+ 	 *param && strcmp ((*param)->attribute,"BOUNDARY");
+ 	 param = &(*param)->next);
+     if (!*param) {		/* cookie not set up yet? */
+       char tmp[MAILTMPLEN];	/* make cookie not in BASE64 or QUOTEPRINT*/
+       sprintf (tmp,"%ld-%ld-%ld=:%ld",gethostid (),random (),time (0),
+ 	       getpid ());
+       (*param) = mail_newbody_parameter ();
+       (*param)->attribute = cpystr ("BOUNDARY");
+       (*param)->value = cpystr (tmp);
+     }
+     part = body->nested.part;	/* encode body parts */
+     do rfc822_encode_body_8bit (env,&part->body);
+     while (part = part->next);	/* until done */
+     break;
+   case TYPEMESSAGE:		/* encapsulated message */
+     switch (body->encoding) {
+     case ENC7BIT:
+     case ENC8BIT:
+       break;
+     case ENCBINARY:
+       mm_log ("Binary included message in 8-bit message body",WARN);
+       break;
+     default:
+       fatal ("Invalid rfc822_encode_body_7bit message encoding");
+     }
+     break;			/* can't change encoding */
+   default:			/* other type, encode binary into BASE64 */
+     if (body->encoding == ENCBINARY) {
+ 				/* remember old binary contents */
+       f = (void *) body->contents.text.data;
+       body->contents.text.data = (char *)
+ 	rfc822_binary ((void *) body->contents.text.data,
+ 		       body->contents.text.size,&body->contents.text.size);
+       body->encoding = ENCBASE64;
+       fs_give (&f);		/* flush old binary contents */
+     }
+     break;
+   }
+ }
+ 
+ /* Output RFC 822 body
+  * Accepts: body
+  *	    I/O routine
+  *	    stream for I/O routine
+  * Returns: T if successful, NIL if failure
+  */
+ 
+ long rfc822_output_body (BODY *body,soutr_t f,void *s)
+ {
+   PART *part;
+   PARAMETER *param;
+   char *cookie = NIL;
+   char tmp[MAILTMPLEN];
+   char *t;
+   switch (body->type) {
+   case TYPEMULTIPART:		/* multipart gets special handling */
+     part = body->nested.part;	/* first body part */
+ 				/* find cookie */
+     for (param = body->parameter; param && !cookie; param = param->next)
+       if (!strcmp (param->attribute,"BOUNDARY")) cookie = param->value;
+     if (!cookie) cookie = "-";	/* yucky default */
+     do {			/* for each part */
+ 				/* build cookie */
+       sprintf (t = tmp,"--%s\015\012",cookie);
+ 				/* append mini-header */
+       rfc822_write_body_header (&t,&part->body);
+       strcat (t,"\015\012");	/* write terminating blank line */
+ 				/* output cookie, mini-header, and contents */
+       if (!((*f) (s,tmp) && rfc822_output_body (&part->body,f,s))) return NIL;
+     } while (part = part->next);/* until done */
+ 				/* output trailing cookie */
+     sprintf (t = tmp,"--%s--",cookie);
+     break;
+   default:			/* all else is text now */
+     t = (char *) body->contents.text.data;
+     break;
+   }
+ 				/* output final stuff */
+   if (t && *t && !((*f) (s,t) && (*f) (s,"\015\012"))) return NIL;
+   return LONGT;
+ }
+ 
+ /* Convert BASE64 contents to binary
+  * Accepts: source
+  *	    length of source
+  *	    pointer to return destination length
+  * Returns: destination as binary
+  */
+ 
+ void *rfc822_base64 (unsigned char *src,unsigned long srcl,unsigned long *len)
+ {
+   char c;
+   void *ret = fs_get ((size_t) (*len = 4 + ((srcl * 3) / 4)));
+   char *d = (char *) ret;
+   int e = 0;
+   memset (ret,0,(size_t) *len);	/* initialize block */
+   *len = 0;			/* in case we return an error */
+   while (srcl--) {		/* until run out of characters */
+     c = *src++;			/* simple-minded decode */
+     if (isupper (c)) c -= 'A';
+     else if (islower (c)) c -= 'a' - 26;
+     else if (isdigit (c)) c -= '0' - 52;
+     else if (c == '+') c = 62;
+     else if (c == '/') c = 63;
+     else if (c == '=') {	/* padding */
+       switch (e++) {		/* check quantum position */
+       case 3:
+ 	e = 0;			/* restart quantum */
+ 	break;
+       case 2:
+ 	if (*src == '=') break;
+       default:			/* impossible quantum position */
+ 	fs_give (&ret);
+ 	return NIL;
+       }
+       continue;
+     }
+     else continue;		/* junk character */
+     switch (e++) {		/* install based on quantum position */
+     case 0:
+       *d = c << 2;		/* byte 1: high 6 bits */
+       break;
+     case 1:
+       *d++ |= c >> 4;		/* byte 1: low 2 bits */
+       *d = c << 4;		/* byte 2: high 4 bits */
+       break;
+     case 2:
+       *d++ |= c >> 2;		/* byte 2: low 4 bits */
+       *d = c << 6;		/* byte 3: high 2 bits */
+       break;
+     case 3:
+       *d++ |= c;		/* byte 3: low 6 bits */
+       e = 0;			/* reinitialize mechanism */
+       break;
+     }
+   }
+   *len = d - (char *) ret;	/* calculate data length */
+   return ret;			/* return the string */
+ }
+ 
+ /* Convert binary contents to BASE64
+  * Accepts: source
+  *	    length of source
+  *	    pointer to return destination length
+  * Returns: destination as BASE64
+  */
+ 
+ unsigned char *rfc822_binary (void *src,unsigned long srcl,unsigned long *len)
+ {
+   unsigned char *ret,*d;
+   unsigned char *s = (unsigned char *) src;
+   char *v = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+   unsigned long i = ((srcl + 2) / 3) * 4;
+   *len = i += 2 * ((i / 60) + 1);
+   d = ret = (unsigned char *) fs_get ((size_t) ++i);
+   for (i = 0; srcl; s += 3) {	/* process tuplets */
+     *d++ = v[s[0] >> 2];	/* byte 1: high 6 bits (1) */
+ 				/* byte 2: low 2 bits (1), high 4 bits (2) */
+     *d++ = v[((s[0] << 4) + (--srcl ? (s[1] >> 4) : 0)) & 0x3f];
+ 				/* byte 3: low 4 bits (2), high 2 bits (3) */
+     *d++ = srcl ? v[((s[1] << 2) + (--srcl ? (s[2] >> 6) : 0)) & 0x3f] : '=';
+ 				/* byte 4: low 6 bits (3) */
+     *d++ = srcl ? v[s[2] & 0x3f] : '=';
+     if (srcl) srcl--;		/* count third character if processed */
+     if ((++i) == 15) {		/* output 60 characters? */
+       i = 0;			/* restart line break count, insert CRLF */
+       *d++ = '\015'; *d++ = '\012';
+     }
+   }
+   *d++ = '\015'; *d++ = '\012';	/* insert final CRLF */
+   *d = '\0';			/* tie off string */
+   if (((unsigned long) (d - ret)) != *len) fatal ("rfc822_binary logic flaw");
+   return ret;			/* return the resulting string */
+ }
+ 
+ /* Convert QUOTED-PRINTABLE contents to 8BIT
+  * Accepts: source
+  *	    length of source
+  * 	    pointer to return destination length
+  * Returns: destination as 8-bit text
+  */
+ 
+ unsigned char *rfc822_qprint (unsigned char *src,unsigned long srcl,
+ 			      unsigned long *len)
+ {
+   unsigned char *ret = (unsigned char *) fs_get ((size_t) srcl + 1);
+   unsigned char *d = ret;
+   unsigned char *s = d;
+   unsigned char c,e;
+   *len = 0;			/* in case we return an error */
+   src[srcl] = '\0';		/* make sure string tied off */
+   while (c = *src++) {		/* until run out of characters */
+     switch (c) {		/* what type of character is it? */
+     case '=':			/* quoting character */
+       switch (c = *src++) {	/* what does it quote? */
+       case '\0':		/* end of data */
+ 	src--;			/* back up pointer */
+ 	break;
+       case '\015':		/* non-significant line break */
+ 	s = d;			/* accept any leading spaces */
+ 	if (*src == '\012') src++;
+ 	break;
+       default:			/* two hex digits then */
+ 	if (!isxdigit (c)) {	/* must be hex! */
+ 	  fs_give ((void **) &ret);
+ 	  return NIL;
+ 	}
+ 	if (isdigit (c)) e = c - '0';
+ 	else e = c - (isupper (c) ? 'A' - 10 : 'a' - 10);
+ 	c = *src++;		/* snarf next character */
+ 	if (!isxdigit (c)) {	/* must be hex! */
+ 	  fs_give ((void **) &ret);
+ 	  return NIL;
+ 	}
+ 	if (isdigit (c)) c -= '0';
+ 	else c -= (isupper (c) ? 'A' - 10 : 'a' - 10);
+ 	*d++ = c + (e << 4);	/* merge the two hex digits */
+ 	s = d;			/* note point of non-space */
+ 	break;
+       }
+       break;
+     case ' ':			/* space, possibly bogus */
+       *d++ = c;			/* stash the space but don't update s */
+       break;
+     case '\015':		/* end of line */
+       d = s;			/* slide back to last non-space, drop in */
+     default:
+       *d++ = c;			/* stash the character */
+       s = d;			/* note point of non-space */
+     }      
+   }
+   *d = '\0';			/* tie off results */
+   *len = d - ret;		/* calculate length */
+   return ret;			/* return the string */
+ }
+ 
+ /* Convert 8BIT contents to QUOTED-PRINTABLE
+  * Accepts: source
+  *	    length of source
+  * 	    pointer to return destination length
+  * Returns: destination as quoted-printable text
+  */
+ 
+ #define MAXL (size_t) 75	/* 76th position only used by continuation = */
+ 
+ unsigned char *rfc822_8bit (unsigned char *src,unsigned long srcl,
+ 			    unsigned long *len)
+ {
+   unsigned long lp = 0;
+   unsigned char *ret = (unsigned char *)
+     fs_get ((size_t) (3*srcl + (6*srcl)/MAXL + 3));
+   unsigned char *d = ret;
+   char *hex = "0123456789ABCDEF";
+   unsigned char c;
+   while (srcl--) {		/* for each character */
+ 				/* true line break? */
+     if (((c = *src++) == '\015') && (*src == '\012') && srcl) {
+       *d++ = '\015'; *d++ = *src++; srcl--;
+       lp = 0;			/* reset line count */
+     }
+     else {			/* not a line break */
+ 				/* quoting required? */
+       if (iscntrl (c) || (c == 0x7f) || (c & 0x80) || (c == '=') ||
+ 	  ((c == ' ') && (*src == '\015'))) {
+ 	if ((lp += 3) > MAXL) {	/* yes, would line overflow? */
+ 	  *d++ = '='; *d++ = '\015'; *d++ = '\012';
+ 	  lp = 3;		/* set line count */
+ 	}
+ 	*d++ = '=';		/* quote character */
+ 	*d++ = hex[c >> 4];	/* high order 4 bits */
+ 	*d++ = hex[c & 0xf];	/* low order 4 bits */
+       }
+       else {			/* ordinary character */
+ 	if ((++lp) > MAXL) {	/* would line overflow? */
+ 	  *d++ = '='; *d++ = '\015'; *d++ = '\012';
+ 	  lp = 1;		/* set line count */
+ 	}
+ 	*d++ = c;		/* ordinary character */
+       }
+     }
+   }
+   *d = '\0';			/* tie off destination */
+   *len = d - ret;		/* calculate true size */
+ 				/* try to give some space back */
+   fs_resize ((void **) &ret,(size_t) *len + 1);
+   return ret;
+ }
diff -c -N c-client.pure/rfc822.c~ c-client/rfc822.c~
*** c-client.pure/rfc822.c~	Thu Jan  1 01:00:00 1970
--- c-client/rfc822.c~	Sat Feb  5 15:39:52 2000
***************
*** 0 ****
--- 1,1830 ----
+ /*
+  * Program:	RFC-822 routines (originally from SMTP)
+  *
+  * Author:	Mark Crispin
+  *		Networks and Distributed Computing
+  *		Computing & Communications
+  *		University of Washington
+  *		Administration Building, AG-44
+  *		Seattle, WA  98195
+  *		Internet: MRC@CAC.Washington.EDU
+  *
+  * Date:	27 July 1988
+  * Last Edited:	13 July 1999
+  *
+  * Sponsorship:	The original version of this work was developed in the
+  *		Symbolic Systems Resources Group of the Knowledge Systems
+  *		Laboratory at Stanford University in 1987-88, and was funded
+  *		by the Biomedical Research Technology Program of the National
+  *		Institutes of Health under grant number RR-00785.
+  *
+  * Original version Copyright 1988 by The Leland Stanford Junior University
+  * Copyright 1999 by the University of Washington
+  *
+  *  Permission to use, copy, modify, and distribute this software and its
+  * documentation for any purpose and without fee is hereby granted, provided
+  * that the above copyright notices appear in all copies and that both the
+  * above copyright notices and this permission notice appear in supporting
+  * documentation, and that the name of the University of Washington or The
+  * Leland Stanford Junior University not be used in advertising or publicity
+  * pertaining to distribution of the software without specific, written prior
+  * permission.  This software is made available "as is", and
+  * THE UNIVERSITY OF WASHINGTON AND THE LELAND STANFORD JUNIOR UNIVERSITY
+  * DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD TO THIS SOFTWARE,
+  * INCLUDING WITHOUT LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+  * FITNESS FOR A PARTICULAR PURPOSE, AND IN NO EVENT SHALL THE UNIVERSITY OF
+  * WASHINGTON OR THE LELAND STANFORD JUNIOR UNIVERSITY BE LIABLE FOR ANY
+  * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+  * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+  * CONTRACT, TORT (INCLUDING NEGLIGENCE) OR STRICT LIABILITY, ARISING OUT OF
+  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  */
+ 
+ 
+ #include <ctype.h>
+ #include <stdio.h>
+ #include <time.h>
+ #include "mail.h"
+ #include "osdep.h"
+ #include "rfc822.h"
+ #include "misc.h"
+ 
+ /* RFC-822 static data */
+ 
+ 
+ char *errhst = ERRHOST;		/* syntax error host string */
+ 
+ 
+ /* Body formats constant strings, must match definitions in mail.h */
+ 
+ char *body_types[TYPEMAX+1] = {
+   "TEXT", "MULTIPART", "MESSAGE", "APPLICATION", "AUDIO", "IMAGE", "VIDEO",
+   "MODEL", "X-UNKNOWN"
+ };
+ 
+ 
+ char *body_encodings[ENCMAX+1] = {
+   "7BIT", "8BIT", "BINARY", "BASE64", "QUOTED-PRINTABLE", "X-UNKNOWN"
+ };
+ 
+ 
+ /* Token delimiting special characters */
+ 
+ 				/* full RFC-822 specials */
+ const char *rspecials =  "()<>@,;:\\\"[].";
+ 				/* body token specials */
+ const char *tspecials = " ()<>@,;:\\\"[]./?=";
+ 
+ 
+ /* Once upon a time, CSnet had a mailer which assigned special semantics to
+  * dot in e-mail addresses.  For the sake of that mailer, dot was added to
+  * the RFC-822 definition of `specials', even though it had numerous bad side
+  * effects:
+  *   1)	It broke mailbox names on systems which had dots in user names, such as
+  *	Multics and TOPS-20.  RFC-822's syntax rules require that `Admin . MRC'
+  *	be considered equivalent to `Admin.MRC'.  Fortunately, few people ever
+  *	tried this in practice.
+  *   2) It required that all personal names with an initial be quoted, a widely
+  *	detested user interface misfeature.
+  *   3)	It made the parsing of host names be non-atomic for no good reason.
+  * To work around these problems, the following alternate specials lists are
+  * defined.  hspecials and wspecials are used in lieu of rspecials, and
+  * ptspecials are used in lieu of tspecials.  These alternate specials lists
+  * make the parser work a lot better in the real world.  It ain't politically
+  * correct, but it lets the users get their job done!
+  */
+ 
+ 				/* parse-word specials */
+ const char *wspecials = " ()<>@,;:\\\"[]";
+ 				/* parse-token specials for parsing */
+ const char *ptspecials = " ()<>@,;:\\\"[]/?=";
+ 
+ /* RFC822 writing routines */
+ 
+ 
+ /* Write RFC822 header from message structure
+  * Accepts: scratch buffer to write into
+  *	    message envelope
+  *	    message body
+  */
+ 
+ static char **rfc822_extraheaders_names = NULL;
+ static char **rfc822_extraheaders_values = NULL;
+ 
+ void rfc822_setextraheaders(char **names, char **values)
+ {
+    rfc822_extraheaders_names = names;
+    rfc822_extraheaders_values = values;
+ }
+ 
+ void rfc822_extraheaders_lines (char **header,ENVELOPE *env)
+ {
+    char **names = rfc822_extraheaders_names;
+    char **values = rfc822_extraheaders_values;
+    while(names && *names && values && *values)
+       sprintf ((*header += strlen (*header)),"%s%s: %s\015\012",
+                env->remail ? "ReSent-" : "",
+                *(names++),
+                *(values++)
+          );
+ }
+ 
+ void rfc822_header (char *header,ENVELOPE *env,BODY *body)
+ {
+   if (env->remail) {		/* if remailing */
+     long i = strlen (env->remail);
+     strcpy (header,env->remail);/* start with remail header */
+ 				/* flush extra blank line */
+     if (i > 4 && header[i-4] == '\015') header[i-2] = '\0';
+   }
+   else *header = '\0';		/* else initialize header to null */
+   rfc822_header_line (&header,"Newsgroups",env,env->newsgroups);
+   rfc822_header_line (&header,"Date",env,env->date);
+   rfc822_address_line (&header,"From",env,env->from);
+   rfc822_address_line (&header,"Sender",env,env->sender);
+   rfc822_address_line (&header,"Reply-To",env,env->reply_to);
+   rfc822_header_line (&header,"Subject",env,env->subject);
+   if (env->bcc && !(env->to || env->cc))
+     strcat (header,"To: undisclosed recipients: ;\015\012");
+   rfc822_address_line (&header,"To",env,env->to);
+   rfc822_address_line (&header,"cc",env,env->cc);
+ /* bcc's are never written...
+  * rfc822_address_line (&header,"bcc",env,env->bcc);
+  */
+   rfc822_header_line (&header,"In-Reply-To",env,env->in_reply_to);
+   rfc822_header_line (&header,"Message-ID",env,env->message_id);
+   rfc822_header_line (&header,"Followup-to",env,env->followup_to);
+   rfc822_header_line (&header,"References",env,env->references);
+ 
+   rfc822_extraheaders_lines (&header,env);
+   
+   if (body && !env->remail) {	/* not if remail or no body structure */
+     strcat (header,"MIME-Version: 1.0\015\012");
+     rfc822_write_body_header (&header,body);
+   }
+   strcat (header,"\015\012");	/* write terminating blank line */
+ }
+ 
+ /* Write RFC822 address from header line
+  * Accepts: pointer to destination string pointer
+  *	    pointer to header type
+  *	    message to interpret
+  *	    address to interpret
+  */
+ 
+ void rfc822_address_line (char **header,char *type,ENVELOPE *env,ADDRESS *adr)
+ {
+   char *s = (*header += strlen (*header));
+   if (adr) {			/* do nothing if no addresses */
+     if (env && env->remail) strcat (s,"ReSent-");
+     strcat (s,type);		/* write header name */
+     strcat (s,": ");
+     s = rfc822_write_address_full (s + strlen (s),adr,*header);
+ 				/* tie off header line */
+     *s++ = '\015'; *s++ = '\012'; *s = '\0';
+     *header = s;		/* set return value */
+   }
+ }
+ 
+ 
+ /* Write RFC822 text from header line
+  * Accepts: pointer to destination string pointer
+  *	    pointer to header type
+  *	    message to interpret
+  *	    pointer to text
+  */
+ 
+ void rfc822_header_line (char **header,char *type,ENVELOPE *env,char *text)
+ {
+   if (text) sprintf ((*header += strlen (*header)),"%s%s: %s\015\012",
+ 		     env->remail ? "ReSent-" : "",type,text);
+ }
+ 
+ /* Write RFC822 address list
+  * Accepts: pointer to destination string
+  *	    address to interpret
+  *	    header base if pretty-printing
+  * Returns: end of destination string
+  */
+ 
+ 				/* RFC822 continuation, must start with CRLF */
+ #define RFC822CONT "\015\012    "
+ 
+ char *rfc822_write_address_full (char *dest,ADDRESS *adr,char *base)
+ {
+   long i,n;
+   for (n = 0; adr; adr = adr->next) {
+     if (adr->host) {		/* ordinary address? */
+       if (!(base && n)) {	/* only write if exact form or not in group */
+ 				/* simple case? */
+ 	if (!(adr->personal || adr->adl)) rfc822_address (dest,adr);
+ 	else {			/* no, must use phrase <route-addr> form */
+ 	  if (adr->personal) rfc822_cat (dest,adr->personal,rspecials);
+ 	  strcat (dest," <");	/* write address delimiter */
+ 	  rfc822_address (dest,adr);
+ 	  strcat (dest,">");	/* closing delimiter */
+ 	}
+ 	if (adr->next && adr->next->mailbox) strcat (dest,", ");
+       }
+     }
+ /* what's this? KB */
+ #if 0
+     else if (adr->mailbox) {	/* start of group? */
+ 				/* yes, write group name */
+       rfc822_cat (dest,adr->mailbox,rspecials);
+       strcat (dest,": ");	/* write group identifier */
+       n++;			/* in a group */
+     }
+ #else
+     else if (adr->mailbox) {	/* start of group? */
+ 				/* yes, write group name */
+       rfc822_cat (dest,adr->mailbox,rspecials);
+     }
+ #endif
+     else if (n) {		/* must be end of group (but be paranoid) */
+       strcat (dest,";");
+ 				/* no longer in that group */
+       if (!--n && adr->next && adr->next->mailbox) strcat (dest,", ");
+     }
+     i = strlen (dest);		/* length of what we just wrote */
+ 				/* write continuation if doesn't fit */
+     if (base && (dest > (base + 4)) && ((dest + i) > (base + 78))) {
+       memmove (dest + sizeof (RFC822CONT) - 1,dest,i + 1);
+       memcpy (dest,RFC822CONT,sizeof (RFC822CONT) - 1);
+       base = dest + 2;		/* new base */
+       dest += i + sizeof (RFC822CONT) - 1;
+     }
+     else dest += i;		/* new end of string */
+   }
+   return dest;			/* return end of string */
+ }
+ 
+ /* Write RFC822 route-address to string
+  * Accepts: pointer to destination string
+  *	    address to interpret
+  */
+ 
+ void rfc822_address (char *dest,ADDRESS *adr)
+ {
+   if (adr && adr->host) {	/* no-op if no address */
+     if (adr->adl) {		/* have an A-D-L? */
+       strcat (dest,adr->adl);
+       strcat (dest,":");
+     }
+ 				/* write mailbox name */
+     rfc822_cat (dest,adr->mailbox,wspecials);
+     if (*adr->host != '@') {	/* unless null host (HIGHLY discouraged!) */
+       strcat (dest,"@");	/* host delimiter */
+       strcat (dest,adr->host);	/* write host name */
+     }
+   }
+   else if(adr && adr->mailbox) {
+     rfc822_cat (dest,adr->mailbox,wspecials);
+   }
+ }
+ 
+ 
+ /* Concatenate RFC822 string
+  * Accepts: pointer to destination string
+  *	    pointer to string to concatenate
+  *	    list of special characters
+  */
+ 
+ void rfc822_cat (char *dest,char *src,const char *specials)
+ {
+   char *s;
+   if (strpbrk (src,specials)) {	/* any specials present? */
+     strcat (dest,"\"");		/* opening quote */
+ 				/* truly bizarre characters in there? */
+     while (s = strpbrk (src,"\\\"")) {
+       strncat (dest,src,s-src);	/* yes, output leader */
+       strcat (dest,"\\");	/* quoting */
+       strncat (dest,s,1);	/* output the bizarre character */
+       src = ++s;		/* continue after the bizarre character */
+     }
+     if (*src) strcat (dest,src);/* output non-bizarre string */
+     strcat (dest,"\"");		/* closing quote */
+   }
+   else strcat (dest,src);	/* otherwise it's the easy case */
+ }
+ 
+ /* Write body content header
+  * Accepts: pointer to destination string pointer
+  *	    pointer to body to interpret
+  */
+ 
+ void rfc822_write_body_header (char **dst,BODY *body)
+ {
+   char *s;
+   STRINGLIST *stl;
+   PARAMETER *param = body->parameter;
+   sprintf (*dst += strlen (*dst),"Content-Type: %s",body_types[body->type]);
+   s = body->subtype ? body->subtype : rfc822_default_subtype (body->type);
+   sprintf (*dst += strlen (*dst),"/%s",s);
+   if (param) do {
+     sprintf (*dst += strlen (*dst),"; %s=",param->attribute);
+     rfc822_cat (*dst,param->value,tspecials);
+   } while (param = param->next);
+   else if (body->type == TYPETEXT) strcat (*dst,"; CHARSET=US-ASCII");
+   strcpy (*dst += strlen (*dst),"\015\012");
+   if (body->encoding)		/* note: encoding 7BIT never output! */
+     sprintf (*dst += strlen (*dst),"Content-Transfer-Encoding: %s\015\012",
+ 	     body_encodings[body->encoding]);
+   if (body->id) sprintf (*dst += strlen (*dst),"Content-ID: %s\015\012",
+ 			 body->id);
+   if (body->description)
+     sprintf (*dst += strlen (*dst),"Content-Description: %s\015\012",
+ 	     body->description);
+   if (body->md5)
+     sprintf (*dst += strlen (*dst),"Content-MD5: %s\015\012",body->md5);
+   if (stl = body->language) {
+     strcpy (*dst += strlen (*dst),"Content-Language: ");
+     do {
+       rfc822_cat (*dst,(char *) stl->text.data,tspecials);
+       if (stl = stl->next) strcat (*dst += strlen (*dst),", ");
+     }
+     while (stl);
+     strcpy (*dst += strlen (*dst),"\015\012");
+   }
+   if (body->disposition.type) {
+     sprintf (*dst += strlen (*dst),"Content-Disposition: %s",
+ 	     body->disposition.type);
+     if (param = body->disposition.parameter) do {
+       sprintf (*dst += strlen (*dst),"; %s=",param->attribute);
+       rfc822_cat (*dst,param->value,tspecials);
+     } while (param = param->next);
+     strcpy (*dst += strlen (*dst),"\015\012");
+   }
+ }
+ 
+ 
+ /* Subtype defaulting (a no-no, but regretably necessary...)
+  * Accepts: type code
+  * Returns: default subtype name
+  */
+ 
+ char *rfc822_default_subtype (unsigned short type)
+ {
+   switch (type) {
+   case TYPETEXT:		/* default is TEXT/PLAIN */
+     return "PLAIN";
+   case TYPEMULTIPART:		/* default is MULTIPART/MIXED */
+     return "MIXED";
+   case TYPEMESSAGE:		/* default is MESSAGE/RFC822 */
+     return "RFC822";
+   case TYPEAPPLICATION:		/* default is APPLICATION/OCTET-STREAM */
+     return "OCTET-STREAM";
+   case TYPEAUDIO:		/* default is AUDIO/BASIC */
+     return "BASIC";
+   default:			/* others have no default subtype */
+     return "UNKNOWN";
+   }
+ }
+ 
+ /* RFC822 parsing routines */
+ 
+ 
+ /* Parse an RFC822 message
+  * Accepts: pointer to return envelope
+  *	    pointer to return body
+  *	    pointer to header
+  *	    header byte count
+  *	    pointer to body stringstruct
+  *	    pointer to local host name
+  *	    recursion depth
+  *	    source driver flags
+  */
+ 
+ void rfc822_parse_msg_full (ENVELOPE **en,BODY **bdy,char *s,unsigned long i,
+ 			    STRING *bs,char *host,unsigned long depth,
+ 			    unsigned long flags)
+ {
+   char c,*t,*d;
+   char *tmp = (char *) fs_get ((size_t) i + 100);
+   ENVELOPE *env = (*en = mail_newenvelope ());
+   BODY *body = bdy ? (*bdy = mail_newbody ()) : NIL;
+   long MIMEp = -1;		/* flag that MIME semantics are in effect */
+   long PathP = NIL;		/* flag that a Path: was seen */
+   parseline_t pl = (parseline_t) mail_parameters (NIL,GET_PARSELINE,NIL);
+   while (i && *s != '\n') {	/* until end of header */
+     t = tmp;			/* initialize buffer pointer */
+     c = ' ';			/* and previous character */
+     while (i && c) {		/* collect text until logical end of line */
+       switch (c = *s++) {	/* slurp a character */
+       case '\015':		/* return, possible end of logical line */
+ 	if (*s == '\n') break;	/* ignore if LF follows */
+       case '\012':		/* LF, possible end of logical line */
+ 				/* tie off unless next line starts with WS */
+ 	if (*s != ' ' && *s != '\t') *t++ = c = '\0';
+ 	break;
+       case '\t':		/* tab */
+ 	*t++ = ' ';		/* coerce to space */
+ 	break;
+       default:			/* all other characters */
+ 	*t++ = c;		/* insert the character into the line */
+ 	break;
+       }
+       if (!--i) *t++ = '\0';	/* see if end of header */
+     }
+ 
+ 				/* find header item type */
+     if (t = d = strchr (tmp,':')) {
+       *d++ = '\0';		/* tie off header item, point at its data */
+       while (*d == ' ') d++;	/* flush whitespace */
+       while ((tmp < t--) && (*t == ' ')) *t = '\0';
+       ucase (tmp);		/* coerce to uppercase */
+ 				/* external callback */
+       if (pl) (*pl) (env,tmp,d,host);
+       switch (*tmp) {		/* dispatch based on first character */
+       case '>':			/* possible >From: */
+ 	if (!strcmp (tmp+1,"FROM")) rfc822_parse_adrlist (&env->from,d,host);
+ 	break;
+       case 'B':			/* possible bcc: */
+ 	if (!strcmp (tmp+1,"CC")) rfc822_parse_adrlist (&env->bcc,d,host);
+ 	break;
+       case 'C':			/* possible cc: or Content-<mumble>*/
+ 	if (!strcmp (tmp+1,"C")) rfc822_parse_adrlist (&env->cc,d,host);
+ 	else if ((tmp[1] == 'O') && (tmp[2] == 'N') && (tmp[3] == 'T') &&
+ 		 (tmp[4] == 'E') && (tmp[5] == 'N') && (tmp[6] == 'T') &&
+ 		 (tmp[7] == '-') && body)
+ 	  switch (MIMEp) {
+ 	  case -1:		/* unknown if MIME or not */
+ 	    if (MIMEp = search ((unsigned char *) s-1,i,
+ 				(unsigned char *)"\012MIME-Version",
+ 				(long) 13))
+ 	  case T:		/* definitely MIME */
+ 	      rfc822_parse_content_header (body,tmp+8,d);
+ 	  }
+ 	break;
+       case 'D':			/* possible Date: */
+ 	if (!env->date && !strcmp (tmp+1,"ATE")) env->date = cpystr (d);
+ 	break;
+       case 'F':			/* possible From: */
+ 	if (!strcmp (tmp+1,"ROM")) rfc822_parse_adrlist (&env->from,d,host);
+ 	else if (!strcmp (tmp+1,"OLLOWUP-TO")) {
+ 	  t = env->followup_to = (char *) fs_get (1 + strlen (d));
+ 	  while (c = *d++) if (c != ' ') *t++ = c;
+ 	  *t++ = '\0';
+ 	}
+ 	break;
+       case 'I':			/* possible In-Reply-To: */
+ 	if (!env->in_reply_to && !strcmp (tmp+1,"N-REPLY-TO"))
+ 	  env->in_reply_to = cpystr (d);
+ 	break;
+ 
+       case 'M':			/* possible Message-ID: or MIME-Version: */
+ 	if (!env->message_id && !strcmp (tmp+1,"ESSAGE-ID"))
+ 	  env->message_id = cpystr (d);
+ 	else if (!strcmp (tmp+1,"IME-VERSION")) {
+ 				/* tie off at end of phrase */
+ 	  if (t = rfc822_parse_phrase (d)) *t = '\0';
+ 	  rfc822_skipws (&d);	/* skip whitespace */
+ 				/* known version? */
+ 	  if (strcmp (d,"1.0") && strcmp (d,"RFC-XXXX"))
+ 	    mm_log ("Warning: message has unknown MIME version",PARSE);
+ 	  MIMEp = T;		/* note that we are MIME */
+ 	}
+ 	break;
+       case 'N':			/* possible Newsgroups: */
+ 	if (!env->newsgroups && !strcmp (tmp+1,"EWSGROUPS")) {
+ 	  t = env->newsgroups = (char *) fs_get (1 + strlen (d));
+ 	  while (c = *d++) if (c != ' ') *t++ = c;
+ 	  *t++ = '\0';
+ 	}
+ 	break;
+       case 'P':			/* possible Path: */
+ 	if (!strcmp (tmp+1,"ATH")) PathP = T;
+ 	break;
+       case 'R':			/* possible Reply-To: */
+ 	if (!strcmp (tmp+1,"EPLY-TO"))
+ 	  rfc822_parse_adrlist (&env->reply_to,d,host);
+ 	else if (!env->references && !strcmp (tmp+1,"EFERENCES"))
+ 	  env->references = cpystr (d);
+ 	break;
+       case 'S':			/* possible Subject: or Sender: */
+ 	if (!env->subject && !strcmp (tmp+1,"UBJECT"))
+ 	  env->subject = cpystr (d);
+ 	else if (!strcmp (tmp+1,"ENDER"))
+ 	  rfc822_parse_adrlist (&env->sender,d,host);
+ 	break;
+       case 'T':			/* possible To: */
+ 	if (!strcmp (tmp+1,"O")) rfc822_parse_adrlist (&env->to,d,host);
+ 	break;
+       default:
+ 	break;
+       }
+     }
+   }
+ 
+   /* We require a Path: header and/or a Message-ID belonging to a known
+    * winning mail program, in order to believe Newsgroups:.  This is because
+    * of the unfortunate existance of certain cretins who believe that it
+    * is reasonable to transmit messages via SMTP with a "Newsgroups" header
+    * that were not actually posted to any of the named newsgroups.
+    * The authors of other high-quality email/news software are encouraged to
+    * use similar methods to indentify messages as coming from their software,
+    * and having done so, to tell us so they too can be blessed in this list.
+    *
+    * May 1998 update: as was predicted back in March 1995 when this kludge was
+    * first added, mail/news unifying programs are now the norm.  However, the
+    * encouragement in the previous paragraph didn't take, and there's no good
+    * way to determine bogons accurately.  Consequently, we no longer remove the
+    * newsgroup information from the envelope on the bogon test; we just light
+    * a bogon bit and let the main program worry about what to do.
+    */
+   if (env->newsgroups && !PathP && env->message_id &&
+       strncmp (env->message_id,"<Pine.",6) &&
+       strncmp (env->message_id,"<MS-C.",6) &&
+       strncmp (env->message_id,"<MailManager.",13) &&
+       strncmp (env->message_id,"<EasyMail.",11) &&
+       strncmp (env->message_id,"<ML-",4)) env->ngbogus = T;
+   fs_give ((void **) &tmp);	/* done with scratch buffer */
+ 				/* default Sender: and Reply-To: to From: */
+   if (!env->sender) env->sender = rfc822_cpy_adr (env->from);
+   if (!env->reply_to) env->reply_to = rfc822_cpy_adr (env->from);
+ 				/* now parse the body */
+   if (body) rfc822_parse_content (body,bs,host,depth,flags);
+ }
+ 
+ /* Parse a message body content
+  * Accepts: pointer to body structure
+  *	    body string
+  *	    pointer to local host name
+  *	    recursion depth
+  *	    source driver flags
+  */
+ 
+ void rfc822_parse_content (BODY *body,STRING *bs,char *h,unsigned long depth,
+ 			   unsigned long flags)
+ {
+   char c,c1,*s,*s1;
+   int f;
+   unsigned long i,j,k,m;
+   PARAMETER *param;
+   PART *part = NIL;
+   if (depth > MAXMIMEDEPTH) {	/* excessively deep recursion? */
+     body->type = TYPETEXT;	/* yes, probably a malicious MIMEgram */
+     mm_log ("Ignoring excessively deep MIME recursion",PARSE);
+   }
+   if (!body->subtype)		/* default subtype if still unknown */
+     body->subtype = cpystr (rfc822_default_subtype (body->type));
+ 				/* note offset and sizes */
+   body->contents.offset = GETPOS (bs);
+ 				/* note internal body size in all cases */
+   body->size.bytes = body->contents.text.size = i = SIZE (bs);
+   if (!(flags & DR_CRLF)) body->size.bytes = strcrlflen (bs);
+   switch (body->type) {		/* see if anything else special to do */
+   case TYPETEXT:		/* text content */
+     if (!body->parameter) {	/* default parameters */
+       body->parameter = mail_newbody_parameter ();
+       body->parameter->attribute = cpystr ("CHARSET");
+       body->parameter->value = cpystr ("US-ASCII");
+     }
+ 				/* count number of lines */
+     while (i--) if ((SNX (bs)) == '\n') body->size.lines++;
+     break;
+ 
+   case TYPEMESSAGE:		/* encapsulated message */
+     body->nested.msg = mail_newmsg ();
+ 				/* encapsulated RFC-822 message? */
+     if (!strcmp (body->subtype,"RFC822")) {
+       switch (body->encoding) {	/* make sure valid encoding */
+       case ENC7BIT:		/* these are valid nested encodings */
+       case ENC8BIT:
+       case ENCBINARY:
+ 	break;
+       default:
+ 	mm_log ("Ignoring nested encoding of message contents",PARSE);
+       }
+ 				/* hunt for blank line */
+       for (c = '\012',j = 0; (i > j) && ((c != '\012') || (CHR(bs) != '\012'));
+ 	   j++) if ((c1 = SNX (bs)) != '\015') c = c1;
+       if (i > j) {		/* unless no more text */
+ 	c1 = SNX (bs);		/* body starts here */
+ 	j++;			/* advance count */
+       }
+ 				/* note body text offset and header size */
+       body->nested.msg->header.text.size = j;
+       body->nested.msg->text.text.size = body->contents.text.size - j;
+       body->nested.msg->text.offset = GETPOS (bs);
+       body->nested.msg->full.offset = body->nested.msg->header.offset =
+ 	body->contents.offset;
+       body->nested.msg->full.text.size = body->contents.text.size;
+ 				/* copy header string */
+       SETPOS (bs,body->contents.offset);
+       s = (char *) fs_get ((size_t) j + 1);
+       for (s1 = s,k = j; k--; *s1++ = SNX (bs));
+       s[j] = '\0';		/* tie off string (not really necessary) */
+ 				/* now parse the body */
+       rfc822_parse_msg_full (&body->nested.msg->env,&body->nested.msg->body,s,
+ 			     j,bs,h,depth+1,flags);
+       fs_give ((void **) &s);	/* free header string */
+ 				/* restore position */
+       SETPOS (bs,body->contents.offset);
+     }
+ 				/* count number of lines */
+     while (i--) if (SNX (bs) == '\n') body->size.lines++;
+     break;
+   case TYPEMULTIPART:		/* multiple parts */
+     switch (body->encoding) {	/* make sure valid encoding */
+     case ENC7BIT:		/* these are valid nested encodings */
+     case ENC8BIT:
+     case ENCBINARY:
+       break;
+     default:
+       mm_log ("Ignoring nested encoding of multipart contents",PARSE);
+     }
+ 				/* remember if digest */
+     f = !strcmp (body->subtype,"DIGEST");
+ 				/* find cookie */
+     for (s1 = NIL,param = body->parameter; param && !s1; param = param->next)
+       if (!strcmp (param->attribute,"BOUNDARY")) s1 = param->value;
+     if (!(s1 && *s1)) s1 = "-";	/* yucky default */
+     j = strlen (s1);		/* length of cookie and header */
+     c = '\012';			/* initially at beginning of line */
+ 
+     while (i > j) {		/* examine data */
+       if (m = GETPOS (bs)) m--;	/* get position in front of character */
+       switch (c) {		/* examine each line */
+       case '\015':		/* handle CRLF form */
+ 	if (CHR (bs) == '\012'){/* following LF? */
+ 	  c = SNX (bs); i--;	/* yes, slurp it */
+ 	}
+       case '\012':		/* at start of a line, start with -- ? */
+ 	if (i-- && ((c = SNX (bs)) == '-') && i-- && ((c = SNX (bs)) == '-')) {
+ 				/* see if cookie matches */
+ 	  for (k = j,s = s1; i-- && *s++ == (c = SNX (bs)) && --k;);
+ 	  if (k) break;		/* strings didn't match if non-zero */
+ 				/* look at what follows cookie */
+ 	  if (i && i--) switch (c = SNX (bs)) {
+ 	  case '-':		/* at end if two dashes */
+ 	    if ((i && i--) && ((c = SNX (bs)) == '-') &&
+ 		((i && i--) ? (((c = SNX (bs)) == '\015') || (c=='\012')):T)) {
+ 				/* if have a final part calculate its size */
+ 	      if (part) part->body.mime.text.size =
+ 		(m > part->body.mime.offset) ? (m - part->body.mime.offset) :0;
+ 	      part = NIL; i = 1; /* terminate scan */
+ 	    }
+ 	    break;
+ 	  case '\015':		/* handle CRLF form */
+ 	    if (i && CHR (bs) == '\012') {
+ 	      c = SNX (bs); i--;/* yes, slurp it */
+ 	    }
+ 	  case '\012':		/* new line */
+ 	    if (part) {		/* calculate size of previous */
+ 	      part->body.mime.text.size =
+ 		(m > part->body.mime.offset) ? (m-part->body.mime.offset) : 0;
+ 				/* instantiate next */
+ 	      part = part->next = mail_newbody_part ();
+ 	    }			/* otherwise start new list */
+ 	    else part = body->nested.part = mail_newbody_part ();
+ 				/* digest has a different default */
+ 	    if (f) part->body.type = TYPEMESSAGE;
+ 				/* note offset from main body */
+ 	    part->body.mime.offset = GETPOS (bs);
+ 	    break;
+ 	  default:		/* whatever it was it wasn't valid */
+ 	    break;
+ 	  }
+ 	}
+ 	break;
+       default:			/* not at a line */
+ 	c = SNX (bs); i--;	/* get next character */
+ 	break;
+       }
+     }
+ 
+ 				/* calculate size of any final part */
+     if (part) part->body.mime.text.size = i +
+       ((GETPOS(bs) > part->body.mime.offset) ?
+        (GETPOS(bs) - part->body.mime.offset) : 0);
+ 				/* make a scratch buffer */
+     s1 = (char *) fs_get ((size_t) (k = MAILTMPLEN));
+ 				/* parse non-empty body parts */
+     for (part = body->nested.part; part; part = part->next) {
+       if (i = part->body.mime.text.size) {
+ 				/* move to that part of the body */
+ 	SETPOS (bs,part->body.mime.offset);
+ 				/* until end of header */
+ 	while (i && ((c = CHR (bs)) != '\015') && (c != '\012')) {
+ 				/* collect text until logical end of line */
+ 	  for (j = 0,c = ' '; c; ) {
+ 				/* make sure buffer big enough */
+ 	    if (j > (k - 10)) fs_resize ((void *) &s1,k += MAILTMPLEN);
+ 	    switch (c1 = SNX (bs)) {
+ 	    case '\015':	/* return */
+ 	      if (i && (CHR (bs) == '\012')) {
+ 		c1 = SNX (bs);	/* eat any LF following */
+ 		i--;
+ 	      }
+ 	    case '\012':	/* newline, possible end of logical line */
+ 				/* tie off unless continuation */
+ 	      if (!i || ((CHR (bs) != ' ') && (CHR (bs) != '\t')))
+ 		s1[j] = c = '\0';
+ 	      break;
+ 	    case '\t':		/* tab */
+ 	    case ' ':		/* insert whitespace if not already there */
+ 	      if (c != ' ') s1[j++] = c = ' ';
+ 	      break;
+ 	    default:		/* all other characters */
+ 	      s1[j++] = c = c1;	/* insert the character into the line */
+ 	      break;
+ 	    }
+ 				/* end of data ties off the header */
+ 	    if (!--i) s1[j++] = c = '\0';
+ 	  }
+ 
+ 				/* find header item type */
+ 	  if (((s1[0] == 'C') || (s1[0] == 'c')) &&
+ 	      ((s1[1] == 'O') || (s1[1] == 'o')) &&
+ 	      ((s1[2] == 'N') || (s1[2] == 'n')) &&
+ 	      ((s1[3] == 'T') || (s1[3] == 't')) &&
+ 	      ((s1[4] == 'E') || (s1[4] == 'e')) &&
+ 	      ((s1[5] == 'N') || (s1[5] == 'n')) &&
+ 	      ((s1[6] == 'T') || (s1[6] == 't')) &&
+ 	      (s1[7] == '-') && (s = strchr (s1+8,':'))) {
+ 				/* tie off and flush whitespace */
+ 	    for (*s++ = '\0'; *s == ' '; s++);
+ 				/* parse the header */
+ 	    rfc822_parse_content_header (&part->body,ucase (s1+8),s);
+ 	  }
+ 	}
+ 				/* skip header trailing (CR)LF */
+ 	if (i && (CHR (bs) =='\015')) {i--; c1 = SNX (bs);}
+ 	if (i && (CHR (bs) =='\012')) {i--; c1 = SNX (bs);}
+ 	j = bs->size;		/* save upper level size */
+ 				/* set offset for next level, fake size to i */
+ 	bs->size = GETPOS (bs) + i;
+ 	part->body.mime.text.size -= i;
+ 				/* now parse it */
+ 	rfc822_parse_content (&part->body,bs,h,depth+1,flags);
+ 	bs->size = j;		/* restore current level size */
+       }
+       else part->body.subtype =	/* default subtype if necessary */
+ 	cpystr (rfc822_default_subtype (part->body.type));
+     }
+     fs_give ((void **) &s1);	/* finished with scratch buffer */
+     break;
+   default:			/* nothing special to do in any other case */
+     break;
+   }
+ }
+ 
+ /* Parse RFC822 body content header
+  * Accepts: body to write to
+  *	    possible content name
+  *	    remainder of header
+  */
+ 
+ void rfc822_parse_content_header (BODY *body,char *name,char *s)
+ {
+   char c,*t;
+   long i;
+   STRINGLIST *stl;
+ 				/* flush whitespace */
+   if (t = strchr (name,' ')) *t = '\0';
+   switch (*name) {		/* see what kind of content */
+   case 'I':			/* possible Content-ID */
+     if (!(strcmp (name+1,"D") || body->id)) body->id = cpystr (s);
+     break;
+   case 'D':			/* possible Content-Description */
+     if (!(strcmp (name+1,"ESCRIPTION") || body->description))
+       body->description = cpystr (s);
+     if (!(strcmp (name+1,"ISPOSITION") || body->disposition.type)) {
+ 				/* get type word */
+       if (!(name = rfc822_parse_word (s,ptspecials))) break;
+       c = *name;		/* remember delimiter */
+       *name = '\0';		/* tie off type */
+       body->disposition.type = ucase (cpystr (s));
+       *name = c;		/* restore delimiter */
+       rfc822_skipws (&name);	/* skip whitespace */
+       rfc822_parse_parameter (&body->disposition.parameter,name);
+     }
+     break;
+   case 'L':			/* possible Content-Language */
+     if (!(strcmp (name+1,"ANGUAGE") || body->language)) {
+       stl = NIL;		/* process languages */
+       while (s && (name = rfc822_parse_word (s,ptspecials))) {
+ 	c = *name;		/* save delimiter */
+ 	*name = '\0';		/* tie off subtype */
+ 	if (stl) stl = stl->next = mail_newstringlist ();
+ 	else stl = body->language = mail_newstringlist ();
+ 	stl->text.data = (unsigned char *) ucase (cpystr (s));
+ 	stl->text.size = strlen ((char *) stl->text.data);
+ 	*name = c;		/* restore delimiter */
+ 	rfc822_skipws (&name);	/* skip whitespace */
+ 	if (*name == ',') {	/* any more languages? */
+ 	  s = ++name;		/* advance to it them */
+ 	  rfc822_skipws (&s);
+ 	}
+ 	else s = NIL;		/* bogus or end of list */
+       }
+     }
+     break;
+   case 'M':			/* possible Content-MD5 */
+     if (!(strcmp (name+1,"D5") || body->md5)) body->md5 = cpystr (s);
+     break;
+ 
+   case 'T':			/* possible Content-Type/Transfer-Encoding */
+     if (!(strcmp (name+1,"YPE") || body->subtype || body->parameter)) {
+ 				/* get type word */
+       if (!(name = rfc822_parse_word (s,ptspecials))) break;
+       c = *name;		/* remember delimiter */
+       *name = '\0';		/* tie off type */
+       ucase (s);		/* search for body type */
+       for (i=0; (i<=TYPEMAX) && body_types[i] && strcmp(s,body_types[i]); i++);
+       if (i > TYPEMAX) body->type = TYPEOTHER;
+       else {			/* if empty slot, assign it to this type */
+ 	if (!body_types[i]) body_types[i] = cpystr (s);
+ 	body->type = (unsigned short) i;
+       }
+       *name = c;		/* restore delimiter */
+       rfc822_skipws (&name);	/* skip whitespace */
+       if ((*name == '/') &&	/* subtype? */
+ 	  (name = rfc822_parse_word ((s = ++name),ptspecials))) {
+ 	c = *name;		/* save delimiter */
+ 	*name = '\0';		/* tie off subtype */
+ 	rfc822_skipws (&s);	/* copy subtype */
+ 	if (s) body->subtype = ucase (cpystr (s));
+ 	*name = c;		/* restore delimiter */
+ 	rfc822_skipws (&name);	/* skip whitespace */
+       }
+       else {			/* no subtype */
+ 	if (!name) {		/* did the fool have a subtype delimiter? */
+ 	  name = s;		/* barf, restore pointer */
+ 	  rfc822_skipws (&name);/* skip leading whitespace */
+ 	}
+       }
+       rfc822_parse_parameter (&body->parameter,name);
+     }
+     else if (!strcmp (name+1,"RANSFER-ENCODING")) {
+ 				/* flush out any confusing whitespace */
+       if (t = strchr (ucase (s),' ')) *t = '\0';
+ 				/* search for body encoding */
+       for (i = 0; (i <= ENCMAX) && body_encodings[i] &&
+ 	   strcmp (s,body_encodings[i]); i++);
+       if (i > ENCMAX) body->type = ENCOTHER;
+       else {			/* if empty slot, assign it to this type */
+ 	if (!body_encodings[i]) body_encodings[i] = cpystr (s);
+ 	body->encoding = (unsigned short) i;
+       }
+     }
+     break;
+   default:			/* otherwise unknown */
+     break;
+   }
+ }
+ 
+ /* Parse RFC822 body parameter list
+  * Accepts: parameter list to write to
+  *	    text of list
+  */
+ 
+ void rfc822_parse_parameter (PARAMETER **par,char *text)
+ {
+   char c,*s,tmp[MAILTMPLEN];
+   PARAMETER *param = NIL;
+ 				/* parameter list? */
+   while (text && (*text == ';') &&
+ 	 (text = rfc822_parse_word ((s = ++text),ptspecials))) {
+     c = *text;			/* remember delimiter */
+     *text = '\0';		/* tie off attribute name */
+     rfc822_skipws (&s);		/* skip leading attribute whitespace */
+     if (!*s) *text = c;		/* must have an attribute name */
+     else {			/* instantiate a new parameter */
+       if (*par) param = param->next = mail_newbody_parameter ();
+       else param = *par = mail_newbody_parameter ();
+       param->attribute = ucase (cpystr (s));
+       *text = c;		/* restore delimiter */
+       rfc822_skipws (&text);	/* skip whitespace before equal sign */
+       if ((*text != '=') ||	/* missing value is a no-no too */
+ 	  !(text = rfc822_parse_word ((s = ++text),ptspecials)))
+ 	param->value = cpystr ("UNKNOWN_PARAMETER_VALUE");
+       else {			/* good, have equals sign */
+ 	c = *text;		/* remember delimiter */
+ 	*text = '\0';		/* tie off value */
+ 	rfc822_skipws (&s);	/* skip leading value whitespace */
+ 	if (*s) param->value = rfc822_cpy (s);
+ 	*text = c;		/* restore delimiter */
+ 	rfc822_skipws (&text);
+       }
+     }
+   }
+   if (!text) {			/* must be end of poop */
+     if (param && param->attribute)
+       sprintf (tmp,"Missing parameter value: %.80s",param->attribute);
+     else strcpy (tmp,"Missing parameter");
+     mm_log (tmp,PARSE);
+   }
+   else if (*text) {		/* must be end of poop */
+     sprintf (tmp,"Unexpected characters at end of parameters: %.80s",text);
+     mm_log (tmp,PARSE);
+   }
+ }
+ 
+ /* Parse RFC822 address list
+  * Accepts: address list to write to
+  *	    input string
+  *	    default host name
+  */
+ 
+ void rfc822_parse_adrlist (ADDRESS **lst,char *string,char *host)
+ {
+   char c,*s,tmp[MAILTMPLEN];
+   ADDRESS *last = *lst;
+   ADDRESS *adr;
+   if (!string) return;		/* no string */
+   rfc822_skipws (&string);	/* skip leading WS */
+   if (!*string) return;		/* empty string */
+ 				/* run to tail of list */
+   if (last) while (last->next) last = last->next;
+   while (string) {		/* loop until string exhausted */
+ 				/* got an address? */
+     if (adr = rfc822_parse_address (lst,last,&string,host,0)) {
+       last = adr;		/* new tail address */
+       if (string) {		/* analyze what follows */
+ 	rfc822_skipws (&string);
+ 	switch (c = *string) {
+ 	case ',':		/* comma? */
+ 	  ++string;		/* then another address follows */
+ 	  break;
+ 	default:
+ 	  s = isalnum (c) ? "Must use comma to separate addresses: %.80s" :
+ 	    "Unexpected characters at end of address: %.80s";
+ 	  sprintf (tmp,s,string);
+ 	  mm_log (tmp,PARSE);
+ 	  last = last->next = mail_newaddr ();
+ 	  last->mailbox = cpystr ("UNEXPECTED_DATA_AFTER_ADDRESS");
+ 	  last->host = cpystr (errhst);
+ 				/* falls through */
+ 	case '\0':		/* null-specified address? */
+ 	  string = NIL;		/* punt remainder of parse */
+ 	  break;
+ 	}
+       }
+     }
+     else if (string) {		/* bad mailbox */
+       rfc822_skipws (&string);	/* skip WS */
+       if (!*string) strcpy (tmp,"Missing address after comma");
+       else sprintf (tmp,"Invalid mailbox list: %.80s",string);
+       mm_log (tmp,PARSE);
+       string = NIL;
+       (adr = mail_newaddr ())->mailbox = cpystr ("INVALID_ADDRESS");
+       adr->host = cpystr (errhst);
+       if (last) last = last->next = adr;
+       else *lst = last = adr;
+       break;
+     }
+   }
+ }
+ 
+ /* Parse RFC822 address
+  * Accepts: address list to write to
+  *	    tail of address list
+  *	    pointer to input string
+  *	    default host name
+  *	    group nesting depth
+  * Returns: new list tail
+  */
+ 
+ ADDRESS *rfc822_parse_address (ADDRESS **lst,ADDRESS *last,char **string,
+ 			       char *defaulthost,unsigned long depth)
+ {
+   ADDRESS *adr;
+   if (!*string) return NIL;	/* no string */
+   rfc822_skipws (string);	/* skip leading WS */
+   if (!**string) return NIL;	/* empty string */
+   if (adr = rfc822_parse_group (lst,last,string,defaulthost,depth)) last = adr;
+ 				/* got an address? */
+   else if (adr = rfc822_parse_mailbox (string,defaulthost)) {
+     if (!*lst) *lst = adr;	/* yes, first time through? */
+     else last->next = adr;	/* no, append to the list */
+ 				/* set for subsequent linking */
+     for (last = adr; last->next; last = last->next);
+   }
+   else if (*string) return NIL;
+   return last;
+ }
+ 
+ /* Parse RFC822 group
+  * Accepts: address list to write to
+  *	    pointer to tail of address list
+  *	    pointer to input string
+  *	    default host name
+  *	    group nesting depth
+  */
+ 
+ ADDRESS *rfc822_parse_group (ADDRESS **lst,ADDRESS *last,char **string,
+ 			     char *defaulthost,unsigned long depth)
+ {
+   char tmp[MAILTMPLEN];
+   char *p,*s;
+   ADDRESS *adr;
+   if (depth > MAXGROUPDEPTH) {	/* excessively deep recursion? */
+     mm_log ("Ignoring excessively deep group recursion",PARSE);
+     return NIL;			/* probably abusive */
+   }
+   if (!*string) return NIL;	/* no string */
+   rfc822_skipws (string);	/* skip leading WS */
+   if (!**string ||		/* trailing whitespace or not group */
+       ((*(p = *string) != ':') && !(p = rfc822_parse_phrase (*string))))
+     return NIL;
+   s = p;			/* end of candidate phrase */
+   rfc822_skipws (&s);		/* find delimiter */
+   if (*s != ':') return NIL;	/* not really a group */
+   *p = '\0';			/* tie off group name */
+   p = ++s;			/* continue after the delimiter */
+   rfc822_skipws (&p);		/* skip subsequent whitespace */
+ 				/* write as address */
+   (adr = mail_newaddr ())->mailbox = rfc822_cpy (*string);
+   if (!*lst) *lst = adr;	/* first time through? */
+   else last->next = adr;	/* no, append to the list */
+   last = adr;			/* set for subsequent linking */
+   *string = p;			/* continue after this point */
+   while (*string && **string && (**string != ';')) {
+     if (adr = rfc822_parse_address (lst,last,string,defaulthost,depth+1)) {
+       last = adr;		/* new tail address */
+       if (*string) {		/* anything more? */
+ 	rfc822_skipws (string);	/* skip whitespace */
+ 	switch (**string) {	/* see what follows */
+ 	case ',':		/* another address? */
+ 	  ++*string;		/* yes, skip past the comma */
+ 	case ';':		/* end of group? */
+ 	case '\0':		/* end of string */
+ 	  break;
+ 	default:
+ 	  sprintf (tmp,"Unexpected characters after address in group: %.80s",
+ 		   *string);
+ 	  mm_log (tmp,PARSE);
+ 	  *string = NIL;	/* cancel remainder of parse */
+ 	  last = last->next = mail_newaddr ();
+ 	  last->mailbox = cpystr ("UNEXPECTED_DATA_AFTER_ADDRESS_IN_GROUP");
+ 	  last->host = cpystr (errhst);
+ 	}
+       }
+     }
+     else {			/* bogon */
+       sprintf (tmp,"Invalid group mailbox list: %.80s",*string);
+       mm_log (tmp,PARSE);
+       *string = NIL;		/* cancel remainder of parse */
+       (adr = mail_newaddr ())->mailbox = cpystr ("INVALID_ADDRESS_IN_GROUP");
+       adr->host = cpystr (errhst);
+       last = last->next = adr;
+     }
+   }
+   if (*string) {		/* skip close delimiter */
+     if (**string == ';') ++*string;
+     rfc822_skipws (string);
+   }
+ 				/* append end of address mark to the list */
+   last->next = (adr = mail_newaddr ());
+   last = adr;			/* set for subsequent linking */
+   return last;			/* return the tail */
+ }
+ 
+ /* Parse RFC822 mailbox
+  * Accepts: pointer to string pointer
+  *	    default host
+  * Returns: address list
+  *
+  * Updates string pointer
+  */
+ 
+ ADDRESS *rfc822_parse_mailbox (char **string,char *defaulthost)
+ {
+   ADDRESS *adr = NIL;
+   char *s,*end;
+   parsephrase_t pp = (parsephrase_t) mail_parameters (NIL,GET_PARSEPHRASE,NIL);
+   if (!*string) return NIL;	/* no string */
+   rfc822_skipws (string);	/* flush leading whitespace */
+   if (!**string) return NIL;	/* empty string */
+   if (*(s = *string) == '<') 	/* note start, handle case of phraseless RA */
+     adr = rfc822_parse_routeaddr (s,string,defaulthost);
+ 				/* otherwise, expect at least one word */
+   else if (end = rfc822_parse_phrase (s)) {
+     if ((adr = rfc822_parse_routeaddr (end,string,defaulthost))) {
+ 				/* phrase is a personal name */
+       if (adr->personal) fs_give ((void **) &adr->personal);
+       *end = '\0';		/* tie off phrase */
+       adr->personal = rfc822_cpy (s);
+     }
+ 				/* call external phraseparser if phrase only */
+     else if (pp && rfc822_phraseonly (end) &&
+ 	     (adr = (*pp) (s,end,defaulthost))) {
+       *string = end;		/* update parse pointer */
+       rfc822_skipws (string);	/* skip WS in the normal way */
+     }
+     else adr = rfc822_parse_addrspec (s,string,defaulthost);
+   }
+   return adr;			/* return the address */
+ }
+ 
+ 
+ /* Check if address is a phrase only
+  * Accepts: pointer to end of phrase
+  * Returns: T if phrase only, else NIL;
+  */
+ 
+ long rfc822_phraseonly (char *end)
+ {
+   while (*end == ' ') ++end;	/* call rfc822_skipws() instead?? */
+   switch (*end) {
+   case '\0': case ',': case ';':
+     return LONGT;		/* is a phrase only */
+   }
+   return NIL;			/* something other than phase is here */
+ }
+ 
+ /* Parse RFC822 route-address
+  * Accepts: string pointer
+  *	    pointer to string pointer to update
+  * Returns: address
+  *
+  * Updates string pointer
+  */
+ 
+ ADDRESS *rfc822_parse_routeaddr (char *string,char **ret,char *defaulthost)
+ {
+   char tmp[MAILTMPLEN];
+   ADDRESS *adr;
+   char *adl = NIL;
+   char *routeend = NIL;
+   if (!string) return NIL;
+   rfc822_skipws (&string);	/* flush leading whitespace */
+ 				/* must start with open broket */
+   if (*string != '<') return NIL;
+   if (string[1] == '@') {	/* have an A-D-L? */
+     adl = ++string;		/* yes, remember that fact */
+     while (*string != ':') {	/* search for end of A-D-L */
+ 				/* punt if never found */
+       if (!*string) return NIL;
+       ++string;			/* try next character */
+     }
+     *string = '\0';		/* tie off A-D-L */
+     routeend = string;		/* remember in case need to put back */
+   }
+ 				/* parse address spec */
+   if (!(adr = rfc822_parse_addrspec (++string,ret,defaulthost))) {
+     if (adl) *routeend = ':';	/* put colon back since parse barfed */
+     return NIL;
+   }
+ 				/* have an A-D-L? */
+   if (adl) adr->adl = cpystr (adl);
+   if (*ret) if (**ret == '>') {	/* make sure terminated OK */
+     ++*ret;			/* skip past the broket */
+     rfc822_skipws (ret);	/* flush trailing WS */
+     if (!**ret) *ret = NIL;	/* wipe pointer if at end of string */
+     return adr;			/* return the address */
+   }
+   sprintf (tmp,"Unterminated mailbox: %.80s@%.80s",adr->mailbox,
+ 	   *adr->host == '@' ? "<null>" : adr->host);
+   mm_log (tmp,PARSE);
+   adr->next = mail_newaddr ();
+   adr->next->mailbox = cpystr ("MISSING_MAILBOX_TERMINATOR");
+   adr->next->host = cpystr (errhst);
+   return adr;			/* return the address */
+ }
+ 
+ /* Parse RFC822 address-spec
+  * Accepts: string pointer
+  *	    pointer to string pointer to update
+  *	    default host
+  * Returns: address
+  *
+  * Updates string pointer
+  */
+ 
+ ADDRESS *rfc822_parse_addrspec (char *string,char **ret,char *defaulthost)
+ {
+   ADDRESS *adr;
+   char *end;
+   char c,*s,*t;
+   if (!string) return NIL;	/* no string */
+   rfc822_skipws (&string);	/* flush leading whitespace */
+   if (!*string) return NIL;	/* empty string */
+ 				/* find end of mailbox */
+   if (!(end = rfc822_parse_word (string,NIL))) return NIL;
+   adr = mail_newaddr ();	/* create address block */
+   c = *end;			/* remember delimiter */
+   *end = '\0';			/* tie off mailbox */
+ 				/* copy mailbox */
+   adr->mailbox = rfc822_cpy (string);
+   *end = c;			/* restore delimiter */
+   t = end;			/* remember end of mailbox for no host case */
+   rfc822_skipws (&end);		/* skip whitespace */
+   if (*end == '@') {		/* have host name? */
+     ++end;			/* skip delimiter */
+     rfc822_skipws (&end);	/* skip whitespace */
+     if (*end == '[') {		/* domain literal? */
+       string = end;		/* start of domain literal */
+       if (end = rfc822_parse_word (string + 1,"]\\")) {
+ 	size_t len = ++end - string;
+ 	strncpy (adr->host = (char *) fs_get (len + 1),string,len);
+ 	adr->host[len] = '\0';	/* tie off literal */
+       }
+       else {
+ 	mm_log ("Invalid domain literal after @",PARSE);
+ 	adr->host = cpystr (errhst);
+       }
+     }
+     				/* search for end of host */
+     else if (end = rfc822_parse_word ((string = end),wspecials)) {
+       c = *end;			/* remember delimiter */
+       *end = '\0';		/* tie off host */
+ 				/* copy host */
+       adr->host = rfc822_cpy (string);
+       *end = c;			/* restore delimiter */
+     }
+     else {
+       mm_log ("Missing or invalid host name after @",PARSE);
+       adr->host = cpystr (errhst);
+     }
+   }
+   else end = t;			/* make person name default start after mbx */
+ 				/* default host if missing */
+   if (!adr->host) adr->host = cpystr (defaulthost);
+   if (end && !adr->personal) {	/* try person name in comments if missing */
+     while (*end == ' ') ++end;	/* see if we can find a person name here */
+     if ((*end == '(') && (s = rfc822_skip_comment (&end,LONGT)) && strlen (s))
+       adr->personal = rfc822_cpy (s);
+     rfc822_skipws (&end);	/* skip any other WS in the normal way */
+   }
+ 				/* set return to end pointer */
+   *ret = (end && *end) ? end : NIL;
+   return adr;			/* return the address we got */
+ }
+ 
+ /* Parse RFC822 phrase
+  * Accepts: string pointer
+  * Returns: pointer to end of phrase
+  */
+ 
+ char *rfc822_parse_phrase (char *s)
+ {
+   char *curpos;
+   if (!s) return NIL;		/* no-op if no string */
+ 				/* find first word of phrase */
+   curpos = rfc822_parse_word (s,NIL);
+   if (!curpos) return NIL;	/* no words means no phrase */
+   if (!*curpos) return curpos;	/* check if string ends with word */
+   s = curpos;			/* sniff past the end of this word and WS */
+   rfc822_skipws (&s);		/* skip whitespace */
+ 				/* recurse to see if any more */
+   return (s = rfc822_parse_phrase (s)) ? s : curpos;
+ }
+ 
+ /* Parse RFC822 word
+  * Accepts: string pointer
+  * Returns: pointer to end of word
+  */
+ 
+ char *rfc822_parse_word (char *s,const char *delimiters)
+ {
+   char *st,*str;
+   if (!s) return NIL;		/* no string */
+   rfc822_skipws (&s);		/* flush leading whitespace */
+   if (!*s) return NIL;		/* empty string */
+ 				/* default delimiters to standard */
+   if (!delimiters) delimiters = wspecials;
+   str = s;			/* hunt pointer for strpbrk */
+   while (T) {			/* look for delimiter */
+     if (!(st = strpbrk (str,delimiters))) {
+       while (*s) ++s;		/* no delimiter, hunt for end */
+       return s;			/* return it */
+     }
+     switch (*st) {		/* dispatch based on delimiter */
+     case '"':			/* quoted string */
+ 				/* look for close quote */
+       while (*++st != '"') switch (*st) {
+       case '\0':		/* unbalanced quoted string */
+ 	return NIL;		/* sick sick sick */
+       case '\\':		/* quoted character */
+ 	if (!*++st) return NIL;	/* skip the next character */
+       default:			/* ordinary character */
+ 	break;			/* no special action */
+       }
+       str = ++st;		/* continue parse */
+       break;
+     case '\\':			/* quoted character */
+       /* This is wrong; a quoted-pair can not be part of a word.  However,
+        * domain-literal is parsed as a word and quoted-pairs can be used
+        * *there*.  Either way, it's pretty pathological.
+        */
+       if (st[1]) {		/* not on NUL though... */
+ 	str = st + 2;		/* skip quoted character and go on */
+ 	break;
+       }
+     default:			/* found a word delimiter */
+       return (st == s) ? NIL : st;
+     }
+   }
+ }
+ 
+ /* Copy an RFC822 format string
+  * Accepts: string
+  * Returns: copy of string
+  */
+ 
+ char *rfc822_cpy (char *src)
+ {
+ 				/* copy and unquote */
+   return rfc822_quote (cpystr (src));
+ }
+ 
+ 
+ /* Unquote an RFC822 format string
+  * Accepts: string
+  * Returns: string
+  */
+ 
+ char *rfc822_quote (char *src)
+ {
+   char *ret = src;
+   if (strpbrk (src,"\\\"")) {	/* any quoting in string? */
+     char *dst = ret;
+     while (*src) {		/* copy string */
+       if (*src == '\"') src++;	/* skip double quote entirely */
+       else {
+ 	if (*src == '\\') src++;/* skip over single quote, copy next always */
+ 	*dst++ = *src++;	/* copy character */
+       }
+     }
+     *dst = '\0';		/* tie off string */
+   }
+   return ret;			/* return our string */
+ }
+ 
+ 
+ /* Copy address list
+  * Accepts: address list
+  * Returns: address list
+  */
+ 
+ ADDRESS *rfc822_cpy_adr (ADDRESS *adr)
+ {
+   ADDRESS *dadr;
+   ADDRESS *ret = NIL;
+   ADDRESS *prev = NIL;
+   while (adr) {			/* loop while there's still an MAP adr */
+     dadr = mail_newaddr ();	/* instantiate a new address */
+     if (!ret) ret = dadr;	/* note return */
+     if (prev) prev->next = dadr;/* tie on to the end of any previous */
+     dadr->personal = cpystr (adr->personal);
+     dadr->adl = cpystr (adr->adl);
+     dadr->mailbox = cpystr (adr->mailbox);
+     dadr->host = cpystr (adr->host);
+     prev = dadr;		/* this is now the previous */
+     adr = adr->next;		/* go to next address in list */
+   }
+   return (ret);			/* return the MTP address list */
+ }
+ 
+ /* Skips RFC822 whitespace
+  * Accepts: pointer to string pointer
+  */
+ 
+ void rfc822_skipws (char **s)
+ {
+   while (T) {
+     if (**s == ' ') ++*s;	/* skip space */
+     else if ((**s != '(') || !rfc822_skip_comment (s,(long) NIL)) return;
+   }
+ }
+ 
+ 
+ /* Skips RFC822 comment
+  * Accepts: pointer to string pointer
+  *	    trim flag
+  * Returns: pointer to first non-blank character of comment
+  */
+ 
+ char *rfc822_skip_comment (char **s,long trim)
+ {
+   char *ret,tmp[MAILTMPLEN];
+   char *s1 = *s;
+   char *t = NIL;
+ 				/* skip past whitespace */
+   for (ret = ++s1; *ret == ' '; ret++);
+   do switch (*s1) {		/* get character of comment */
+   case '(':			/* nested comment? */
+     if (!rfc822_skip_comment (&s1,(long) NIL)) return NIL;
+     t = --s1;			/* last significant char at end of comment */
+     break;
+   case ')':			/* end of comment? */
+     *s = ++s1;			/* skip past end of comment */
+     if (trim) {			/* if level 0, must trim */
+       if (t) t[1] = '\0';	/* tie off comment string */
+       else *ret = '\0';		/* empty comment */
+     }
+     return ret;
+   case '\\':			/* quote next character? */
+     if (*++s1) {		/* next character non-null? */
+       t = s1;			/* update last significant character pointer */
+       break;			/* all OK */
+     }
+   case '\0':			/* end of string */
+     sprintf (tmp,"Unterminated comment: %.80s",*s);
+     mm_log (tmp,PARSE);
+     **s = '\0';			/* nuke duplicate messages in case reparse */
+     return NIL;			/* this is wierd if it happens */
+   case ' ':			/* whitespace isn't significant */
+     break;
+   default:			/* random character */
+     t = s1;			/* update last significant character pointer */
+     break;
+   } while (s1++);
+   return NIL;			/* impossible, but pacify lint et al */
+ }
+ 
+ /* Body contents utility and encoding/decoding routines */
+ 
+ 
+ /* Output RFC 822 message
+  * Accepts: temporary buffer
+  *	    envelope
+  *	    body
+  *	    I/O routine
+  *	    stream for I/O routine
+  *	    non-zero if 8-bit output desired
+  * Returns: T if successful, NIL if failure
+  */
+ 
+ long rfc822_output (char *t,ENVELOPE *env,BODY *body,soutr_t f,void *s,
+ 		    long ok8bit)
+ {
+   rfc822out_t r822o = (rfc822out_t) mail_parameters (NIL,GET_RFC822OUTPUT,NIL);
+ 				/* call external RFC822 output generator */
+   if (r822o) return (*r822o) (t,env,body,f,s,ok8bit);
+ 				/* encode body as necessary */
+   if (ok8bit) rfc822_encode_body_8bit (env,body);
+   else rfc822_encode_body_7bit (env,body);
+   rfc822_header (t,env,body);	/* build RFC822 header */
+ 				/* output header and body */
+   return (*f) (s,t) && (body ? rfc822_output_body (body,f,s) : T);
+ }
+ 
+ /* Encode a body for 7BIT transmittal
+  * Accepts: envelope
+  *	    body
+  */
+ 
+ void rfc822_encode_body_7bit (ENVELOPE *env,BODY *body)
+ {
+   void *f;
+   PART *part;
+   PARAMETER **param;
+   if (body) switch (body->type) {
+   case TYPEMULTIPART:		/* multi-part */
+     for (param = &body->parameter;
+ 	 *param && strcmp ((*param)->attribute,"BOUNDARY");
+ 	 param = &(*param)->next);
+     if (!*param) {		/* cookie not set up yet? */
+       char tmp[MAILTMPLEN];	/* make cookie not in BASE64 or QUOTEPRINT*/
+       sprintf (tmp,"%ld-%ld-%ld=:%ld",(long) gethostid (),random (),time (0),
+ 	       (long) getpid ());
+       (*param) = mail_newbody_parameter ();
+       (*param)->attribute = cpystr ("BOUNDARY");
+       (*param)->value = cpystr (tmp);
+     }
+     part = body->nested.part;	/* encode body parts */
+     do rfc822_encode_body_7bit (env,&part->body);
+     while (part = part->next);	/* until done */
+     break;
+   case TYPEMESSAGE:		/* encapsulated message */
+     switch (body->encoding) {
+     case ENC7BIT:
+       break;
+     case ENC8BIT:
+       mm_log ("8-bit included message in 7-bit message body",WARN);
+       break;
+     case ENCBINARY:
+       mm_log ("Binary included message in 7-bit message body",WARN);
+       break;
+     default:
+       fatal ("Invalid rfc822_encode_body_7bit message encoding");
+     }
+     break;			/* can't change encoding */
+   default:			/* all else has some encoding */
+     switch (body->encoding) {
+     case ENC8BIT:		/* encode 8BIT into QUOTED-PRINTABLE */
+ 				/* remember old 8-bit contents */
+       f = (void *) body->contents.text.data;
+       body->contents.text.data =
+ 	rfc822_8bit (body->contents.text.data,
+ 		     body->contents.text.size,&body->contents.text.size);
+       body->encoding = ENCQUOTEDPRINTABLE;
+       fs_give (&f);		/* flush old binary contents */
+       break;
+     case ENCBINARY:		/* encode binary into BASE64 */
+ 				/* remember old binary contents */
+       f = (void *) body->contents.text.data;
+       body->contents.text.data =
+ 	rfc822_binary ((void *) body->contents.text.data,
+ 		       body->contents.text.size,&body->contents.text.size);
+       body->encoding = ENCBASE64;
+       fs_give (&f);		/* flush old binary contents */
+     default:			/* otherwise OK */
+       break;
+     }
+     break;
+   }
+ }
+ 
+ /* Encode a body for 8BIT transmittal
+  * Accepts: envelope
+  *	    body
+  */
+ 
+ void rfc822_encode_body_8bit (ENVELOPE *env,BODY *body)
+ {
+   void *f;
+   PART *part;
+   PARAMETER **param;
+   if (body) switch (body->type) {
+   case TYPEMULTIPART:		/* multi-part */
+     for (param = &body->parameter;
+ 	 *param && strcmp ((*param)->attribute,"BOUNDARY");
+ 	 param = &(*param)->next);
+     if (!*param) {		/* cookie not set up yet? */
+       char tmp[MAILTMPLEN];	/* make cookie not in BASE64 or QUOTEPRINT*/
+       sprintf (tmp,"%ld-%ld-%ld=:%ld",(long) gethostid (),random (),time (0),
+ 	       (long) getpid ());
+       (*param) = mail_newbody_parameter ();
+       (*param)->attribute = cpystr ("BOUNDARY");
+       (*param)->value = cpystr (tmp);
+     }
+     part = body->nested.part;	/* encode body parts */
+     do rfc822_encode_body_8bit (env,&part->body);
+     while (part = part->next);	/* until done */
+     break;
+   case TYPEMESSAGE:		/* encapsulated message */
+     switch (body->encoding) {
+     case ENC7BIT:
+     case ENC8BIT:
+       break;
+     case ENCBINARY:
+       mm_log ("Binary included message in 8-bit message body",WARN);
+       break;
+     default:
+       fatal ("Invalid rfc822_encode_body_7bit message encoding");
+     }
+     break;			/* can't change encoding */
+   default:			/* other type, encode binary into BASE64 */
+     if (body->encoding == ENCBINARY) {
+ 				/* remember old binary contents */
+       f = (void *) body->contents.text.data;
+       body->contents.text.data =
+ 	rfc822_binary ((void *) body->contents.text.data,
+ 		       body->contents.text.size,&body->contents.text.size);
+       body->encoding = ENCBASE64;
+       fs_give (&f);		/* flush old binary contents */
+     }
+     break;
+   }
+ }
+ 
+ /* Output RFC 822 body
+  * Accepts: body
+  *	    I/O routine
+  *	    stream for I/O routine
+  * Returns: T if successful, NIL if failure
+  */
+ 
+ long rfc822_output_body (BODY *body,soutr_t f,void *s)
+ {
+   PART *part;
+   PARAMETER *param;
+   char *cookie = NIL;
+   char tmp[MAILTMPLEN];
+   char *t;
+   switch (body->type) {
+   case TYPEMULTIPART:		/* multipart gets special handling */
+     part = body->nested.part;	/* first body part */
+ 				/* find cookie */
+     for (param = body->parameter; param && !cookie; param = param->next)
+       if (!strcmp (param->attribute,"BOUNDARY")) cookie = param->value;
+     if (!cookie) cookie = "-";	/* yucky default */
+     do {			/* for each part */
+ 				/* build cookie */
+       sprintf (t = tmp,"--%s\015\012",cookie);
+ 				/* append mini-header */
+       rfc822_write_body_header (&t,&part->body);
+       strcat (t,"\015\012");	/* write terminating blank line */
+ 				/* output cookie, mini-header, and contents */
+       if (!((*f) (s,tmp) && rfc822_output_body (&part->body,f,s))) return NIL;
+     } while (part = part->next);/* until done */
+ 				/* output trailing cookie */
+     sprintf (t = tmp,"--%s--",cookie);
+     break;
+   default:			/* all else is text now */
+     t = (char *) body->contents.text.data;
+     break;
+   }
+ 				/* output final stuff */
+   if (t && *t && !((*f) (s,t) && (*f) (s,"\015\012"))) return NIL;
+   return LONGT;
+ }
+ 
+ /* Convert BASE64 contents to binary
+  * Accepts: source
+  *	    length of source
+  *	    pointer to return destination length
+  * Returns: destination as binary or NIL if error
+  */
+ 
+ void *rfc822_base64 (unsigned char *src,unsigned long srcl,unsigned long *len)
+ {
+   char c;
+   void *ret = fs_get ((size_t) (*len = 4 + ((srcl * 3) / 4)));
+   char *d = (char *) ret;
+   int e = 0;
+   memset (ret,0,(size_t) *len);	/* initialize block */
+   *len = 0;			/* in case we return an error */
+   while (srcl--) {		/* until run out of characters */
+     c = *src++;			/* simple-minded decode */
+     if (isupper (c)) c -= 'A';
+     else if (islower (c)) c -= 'a' - 26;
+     else if (isdigit (c)) c -= '0' - 52;
+     else if (c == '+') c = 62;
+     else if (c == '/') c = 63;
+     else if (c == '=') {	/* padding */
+       switch (e++) {		/* check quantum position */
+       case 3:
+ 	e = 0;			/* restart quantum */
+ 	break;
+       case 2:
+ 	if (*src == '=') break;
+       default:			/* impossible quantum position */
+ 	fs_give (&ret);
+ 	return NIL;
+       }
+       continue;
+     }
+     else continue;		/* junk character */
+     switch (e++) {		/* install based on quantum position */
+     case 0:
+       *d = c << 2;		/* byte 1: high 6 bits */
+       break;
+     case 1:
+       *d++ |= c >> 4;		/* byte 1: low 2 bits */
+       *d = c << 4;		/* byte 2: high 4 bits */
+       break;
+     case 2:
+       *d++ |= c >> 2;		/* byte 2: low 4 bits */
+       *d = c << 6;		/* byte 3: high 2 bits */
+       break;
+     case 3:
+       *d++ |= c;		/* byte 3: low 6 bits */
+       e = 0;			/* reinitialize mechanism */
+       break;
+     }
+   }
+   *len = d - (char *) ret;	/* calculate data length */
+   return ret;			/* return the string */
+ }
+ 
+ /* Convert binary contents to BASE64
+  * Accepts: source
+  *	    length of source
+  *	    pointer to return destination length
+  * Returns: destination as BASE64
+  */
+ 
+ unsigned char *rfc822_binary (void *src,unsigned long srcl,unsigned long *len)
+ {
+   unsigned char *ret,*d;
+   unsigned char *s = (unsigned char *) src;
+   char *v = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+   unsigned long i = ((srcl + 2) / 3) * 4;
+   *len = i += 2 * ((i / 60) + 1);
+   d = ret = (unsigned char *) fs_get ((size_t) ++i);
+   for (i = 0; srcl; s += 3) {	/* process tuplets */
+     *d++ = v[s[0] >> 2];	/* byte 1: high 6 bits (1) */
+ 				/* byte 2: low 2 bits (1), high 4 bits (2) */
+     *d++ = v[((s[0] << 4) + (--srcl ? (s[1] >> 4) : 0)) & 0x3f];
+ 				/* byte 3: low 4 bits (2), high 2 bits (3) */
+     *d++ = srcl ? v[((s[1] << 2) + (--srcl ? (s[2] >> 6) : 0)) & 0x3f] : '=';
+ 				/* byte 4: low 6 bits (3) */
+     *d++ = srcl ? v[s[2] & 0x3f] : '=';
+     if (srcl) srcl--;		/* count third character if processed */
+     if ((++i) == 15) {		/* output 60 characters? */
+       i = 0;			/* restart line break count, insert CRLF */
+       *d++ = '\015'; *d++ = '\012';
+     }
+   }
+   *d++ = '\015'; *d++ = '\012';	/* insert final CRLF */
+   *d = '\0';			/* tie off string */
+   if (((unsigned long) (d - ret)) != *len) fatal ("rfc822_binary logic flaw");
+   return ret;			/* return the resulting string */
+ }
+ 
+ /* Convert QUOTED-PRINTABLE contents to 8BIT
+  * Accepts: source
+  *	    length of source
+  * 	    pointer to return destination length
+  * Returns: destination as 8-bit text or NIL if error
+  */
+ 
+ unsigned char *rfc822_qprint (unsigned char *src,unsigned long srcl,
+ 			      unsigned long *len)
+ {
+   unsigned char *ret = (unsigned char *) fs_get ((size_t) srcl + 1);
+   unsigned char *d = ret;
+   unsigned char *t = d;
+   unsigned char *s = src;
+   unsigned char c,e;
+   *len = 0;			/* in case we return an error */
+ 				/* until run out of characters */
+   while (((unsigned long) (s - src)) < srcl) {
+     switch (c = *s++) {		/* what type of character is it? */
+     case '=':			/* quoting character */
+       if (((unsigned long) (s - src)) < srcl) switch (c = *s++) {
+       case '\0':		/* end of data */
+ 	s--;			/* back up pointer */
+ 	break;
+       case '\015':		/* non-significant line break */
+ 	t = d;			/* accept any leading spaces */
+ 	if ((((unsigned long) (s - src)) < srcl) && (*s == '\012')) s++;
+ 	break;
+       default:			/* two hex digits then */
+ 	if (!(isxdigit (c) && (((unsigned long) (s - src)) < srcl) &&
+ 	      (e = *s++) && isxdigit (e))) {
+ 	  fs_give ((void **) &ret);
+ 	  return NIL;
+ 	}
+ 	if (isdigit (c)) c -= '0';
+ 	else c -= (isupper (c) ? 'A' - 10 : 'a' - 10);
+ 	if (isdigit (e)) e -= '0';
+ 	else e -= (isupper (e) ? 'A' - 10 : 'a' - 10);
+ 	*d++ = e + (c << 4);	/* merge the two hex digits */
+ 	t = d;			/* note point of non-space */
+ 	break;
+       }
+       break;
+     case ' ':			/* space, possibly bogus */
+       *d++ = c;			/* stash the space but don't update s */
+       break;
+     case '\015':		/* end of line */
+       d = t;			/* slide back to last non-space, drop in */
+     default:
+       *d++ = c;			/* stash the character */
+       t = d;			/* note point of non-space */
+     }      
+   }
+   *d = '\0';			/* tie off results */
+   *len = d - ret;		/* calculate length */
+   return ret;			/* return the string */
+ }
+ 
+ /* Convert 8BIT contents to QUOTED-PRINTABLE
+  * Accepts: source
+  *	    length of source
+  * 	    pointer to return destination length
+  * Returns: destination as quoted-printable text
+  */
+ 
+ #define MAXL (size_t) 75	/* 76th position only used by continuation = */
+ 
+ unsigned char *rfc822_8bit (unsigned char *src,unsigned long srcl,
+ 			    unsigned long *len)
+ {
+   unsigned long lp = 0;
+   unsigned char *ret = (unsigned char *)
+     fs_get ((size_t) (3*srcl + (6*srcl)/MAXL + 3));
+   unsigned char *d = ret;
+   char *hex = "0123456789ABCDEF";
+   unsigned char c;
+   while (srcl--) {		/* for each character */
+ 				/* true line break? */
+     if (((c = *src++) == '\015') && (*src == '\012') && srcl) {
+       *d++ = '\015'; *d++ = *src++; srcl--;
+       lp = 0;			/* reset line count */
+     }
+     else {			/* not a line break */
+ 				/* quoting required? */
+       if (iscntrl (c) || (c == 0x7f) || (c & 0x80) || (c == '=') ||
+ 	  ((c == ' ') && (*src == '\015'))) {
+ 	if ((lp += 3) > MAXL) {	/* yes, would line overflow? */
+ 	  *d++ = '='; *d++ = '\015'; *d++ = '\012';
+ 	  lp = 3;		/* set line count */
+ 	}
+ 	*d++ = '=';		/* quote character */
+ 	*d++ = hex[c >> 4];	/* high order 4 bits */
+ 	*d++ = hex[c & 0xf];	/* low order 4 bits */
+       }
+       else {			/* ordinary character */
+ 	if ((++lp) > MAXL) {	/* would line overflow? */
+ 	  *d++ = '='; *d++ = '\015'; *d++ = '\012';
+ 	  lp = 1;		/* set line count */
+ 	}
+ 	*d++ = c;		/* ordinary character */
+       }
+     }
+   }
+   *d = '\0';			/* tie off destination */
+   *len = d - ret;		/* calculate true size */
+ 				/* try to give some space back */
+   fs_resize ((void **) &ret,(size_t) *len + 1);
+   return ret;
+ }
Binary files c-client.pure/rfc822.o and c-client/rfc822.o differ
Binary files c-client.pure/siglocal.o and c-client/siglocal.o differ
Binary files c-client.pure/smanager.o and c-client/smanager.o differ
Binary files c-client.pure/smtp.o and c-client/smtp.o differ
Binary files c-client.pure/tenex.o and c-client/tenex.o differ
diff -c -N c-client.pure/unix.h c-client/unix.h
*** c-client.pure/unix.h	Sat Feb  5 18:29:59 2000
--- c-client/unix.h	Sat Feb  5 14:45:55 2000
***************
*** 1,5 ****
  /*
!  * Program:	UNIX mail routines
   *
   * Author:	Mark Crispin
   *		Networks and Distributed Computing
--- 1,5 ----
  /*
!  * Program:	UNIX mail routines, Amiga version
   *
   * Author:	Mark Crispin
   *		Networks and Distributed Computing
***************
*** 10,16 ****
   *		Internet: MRC@CAC.Washington.EDU
   *
   * Date:	20 December 1989
!  * Last Edited:	4 August 1999
   *
   * Copyright 1999 by the University of Washington
   *
--- 10,16 ----
   *		Internet: MRC@CAC.Washington.EDU
   *
   * Date:	20 December 1989
!  * Last Edited:	23 September 1999
   *
   * Copyright 1999 by the University of Washington
   *
***************
*** 55,60 ****
--- 55,61 ----
   */
  
  #define VALID(s,x,ti,zn) {						\
+   int remote = 0;							\
    ti = 0;								\
    if ((*s == 'F') && (s[1] == 'r') && (s[2] == 'o') && (s[3] == 'm') &&	\
        (s[4] == ' ')) {							\
***************
*** 67,73 ****
  	    (x[zn-4] == 'f') && (x[zn-5] == ' ') && (x[zn-6] == 'e') &&	\
  	    (x[zn-7] == 't') && (x[zn-8] == 'o') && (x[zn-9] == 'm') &&	\
  	    (x[zn-10] == 'e') && (x[zn-11] == 'r') && (x[zn-12] == ' '))\
! 	  x += zn - 12;							\
        }									\
        if (x - s >= 27) {						\
  	if (x[-5] == ' ') {						\
--- 68,78 ----
  	    (x[zn-4] == 'f') && (x[zn-5] == ' ') && (x[zn-6] == 'e') &&	\
  	    (x[zn-7] == 't') && (x[zn-8] == 'o') && (x[zn-9] == 'm') &&	\
  	    (x[zn-10] == 'e') && (x[zn-11] == 'r') && (x[zn-12] == ' '))\
! 	  {								\
! 	    while (x[zn-13] == ' ') zn--;				\
! 	    x += zn - 12;						\
! 	    remote = 1;							\
! 	  }								\
        }									\
        if (x - s >= 27) {						\
  	if (x[-5] == ' ') {						\
***************
*** 78,88 ****
--- 83,141 ----
  	}								\
  	else if (x[-4] == ' ') {					\
  	  if (x[-9] == ' ') zn = -4,ti = -9;				\
+ 	  else if ( (x[-13] == ' ') && (x[-16] == ' ')			\
+ 		&& (x[-20] ==' ') &&					\
+ 		( ((x[-22] == ' ') && (x[-23] == ',')) ||		\
+ 		  ((x[-23] == ' ') && (x[-24] == ',')) ) ) {		\
+ 	    char weekday[4]={0,}, month[4]={0,}, time[11]={0,};		\
+ 	    char tzone[4]={0,}; 					\
+ 	    char realtime[80];						\
+ 	    int day,year,start=-26;					\
+ 	    if (x[-23] == ' ') x--;					\
+ 	      sscanf(&x[start],"%3c, %d %s %d %s %s",			\
+ 		weekday,&day,month,&year,time,tzone);			\
+ 	      sprintf(realtime,"%s %s %2d %s %d %s",			\
+ 		weekday,month,day,time, 				\
+ 		( (year < 100) ? year+1900 : year),tzone);		\
+ 	      if (remote)						\
+ 		strcat(realtime," remote from ");			\
+ 	      else							\
+ 		strcat(realtime,"\n");					\
+ 	      strncpy(&x[start],realtime,strlen(realtime));		\
+ 	      zn = -2;							\
+ 	      ti = -7;							\
+ 	  }								\
  	}								\
  	else if (x[-6] == ' ') {					\
  	  if ((x[-11] == ' ') && ((x[-5] == '+') || (x[-5] == '-')))	\
  	    zn = -6,ti = -11;						\
  	}								\
+ 	else if (x[-9] == ' ') {					\
+ 	    if ( ( (x[-12] == ' ') && (x[-16] == ' ') &&		\
+ 		  ( ((x[-18] == ' ') && (x[-19] == ',') )  ||		\
+ 		    ((x[-19] == ' ') && (x[-20] == ',')) )		\
+ 		||							\
+ 		((x[-14] == ' ') && (x[-18] == ' ') &&			\
+ 		  ( ((x[-20] == ' ') && (x[-21] == ',') )  ||		\
+ 		    ((x[-21] == ' ') && (x[-22] == ',')) ) ) ) ) {	\
+ 	      char weekday[4]={0,}, month[4]={0,},time[11]={0,};	\
+ 	      int day,year,start=-24;					\
+ 	      char realtime[80];					\
+ 	      if (x[-12] == ' ') x++;					\
+ 	      if (x[-19] == ' ') x++;					\
+ 	      sscanf(&x[start],"%3c, %d %3c %d %s",weekday,		\
+ 		     &day,month,&year,time);				\
+ 	      sprintf(realtime,"%s %s %2d %s %d",weekday,month,day,time,\
+ 		 ( (year < 100) ? year+1900 : year));			\
+ 	      if (remote)						\
+ 		strcat(realtime," remote from ");			\
+ 	      else							\
+ 		strcat(realtime,"\n");					\
+ 	      strncpy(&x[start],realtime,strlen(realtime));		\
+ 	      ti=-5;							\
+ 	      zn=0;							\
+ 	    }								\
+ 	}								\
  	if (ti && !((x[ti - 3] == ':') &&				\
  		    (x[ti -= ((x[ti - 6] == ':') ? 9 : 6)] == ' ') &&	\
  		    (x[ti - 3] == ' ') && (x[ti - 7] == ' ') &&		\
***************
*** 106,111 ****
--- 159,168 ----
   *		From user Wed Dec  2 05:53:22 1992 PST
   *		From user Wed Dec  2 05:53 1992 -0700
   * Solaris	From user Wed Dec  2 05:53:22 1992 -0700
+  *
+  * Amiga	From user Wed, 6 Dec 92 05:53:22 who did this !!!
+  *		CHANGED in place to
+  *		From user Wed Dec  2 05:53:22 1992
   *
   * Plus all of the above with `` remote from xxx'' after it. Thank you very
   * much, smail and Solaris, for making my life considerably more complicated.
Binary files c-client.pure/unix.o and c-client/unix.o differ
Binary files c-client.pure/utf8.o and c-client/utf8.o differ
