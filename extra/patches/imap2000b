90a91,94
> 
>   /* MAHOGANY: changed the code to return newsdriver if the active file doesn't
>      exist (we do it because leafnode doesn't have one yet we still want to use
>      Mahogany with it */
93,94c97,98
<       !strchr (name,'/') &&
<       !stat ((char *) mail_parameters (NIL,GET_NEWSSPOOL,NIL),&sbuf) &&
---
>       !strchr (name,'/') ) {
>     if ( !stat ((char *) mail_parameters (NIL,GET_NEWSSPOOL,NIL),&sbuf) &&
97,108c101,117
<     fstat (fd,&sbuf);		/* get size of active file */
< 				/* slurp in active file */
<     read (fd,t = s = (char *) fs_get (sbuf.st_size+1),sbuf.st_size);
<     s[sbuf.st_size] = '\0';	/* tie off file */
<     close (fd);			/* flush file */
<     while (*t && (u = strchr (t,' '))) {
<       *u++ = '\0';		/* tie off at end of name */
<       if (!strcmp (name+6,t)) {
< 	fs_give ((void **) &s);	/* flush data */
< 	return &newsdriver;
<       }
<       t = 1 + strchr (u,'\n');	/* next line */
---
>         fstat (fd,&sbuf);		/* get size of active file */
>                                     /* slurp in active file */
>         read (fd,t = s = (char *) fs_get (sbuf.st_size+1),sbuf.st_size);
>         s[sbuf.st_size] = '\0';	/* tie off file */
>         close (fd);			/* flush file */
>         while (*t && (u = strchr (t,' '))) {
>           *u++ = '\0';		/* tie off at end of name */
>           if (!strcmp (name+6,t)) {
>             fs_give ((void **) &s);	/* flush data */
>             return &newsdriver;
>           }
>           t = 1 + strchr (u,'\n');	/* next line */
>         }
>         fs_give ((void **) &s);	/* flush data */
>     }
>     else {
>         return &newsdriver;     /* assume it's a newsgroup, no way to check */
110d118
<     fs_give ((void **) &s);	/* flush data */
599c599
<     elt->private.msg.header.text.size = pop3_cache (stream,elt);
---
>     elt->private.msg.header.text.size = pop3_cache_header (stream,elt);
645c645
<   if (LOCAL->msgno != elt->msgno) {
---
>   if (LOCAL->msgno != elt->msgno || elt->rfc822_size == 1) {
654a655,685
>     }
>     else elt->deleted = T;
>   }
>   return LOCAL->hdrsize;
> }
> 
> /* POP3 cache message header only
>  * Accepts: mail stream
>  *        message number
>  * Returns: header size
>  */
> 
> unsigned long pop3_cache_header (MAILSTREAM *stream,MESSAGECACHE *elt)
> {
> 				/* already cached? */
>   if (LOCAL->msgno != elt->msgno) {
>     char tmp[MAILTMPLEN];
> 				/* no, close current file */
>     if (LOCAL->txt) fclose (LOCAL->txt);
>     LOCAL->txt = NIL;
>     LOCAL->msgno = LOCAL->hdrsize = 0;
>     sprintf (tmp,"%lu 0",mail_uid (stream,elt->msgno));
>     if (pop3_send (stream,"TOP",tmp)) {
>       LOCAL->msgno = elt->msgno;/* set as current message number */
> 				/* load the cache */
>       LOCAL->txt = netmsg_slurp (LOCAL->netstream,&elt->rfc822_size,
> 				&LOCAL->hdrsize);
>       elt->rfc822_size = 1;
>       /* because we don't really know, but we want mail_fetch_structure
>        to think that it has enough info without calling dtb->text */
>       /*printf("rfc822_size = %d\n", elt->rfc822_size);*/
67a68
> unsigned long pop3_cache_header (MAILSTREAM *stream,MESSAGECACHE *elt);
24a25,31
> 
> /* sys/dir.h is deprecated under FreeBSD and shouldn't be used */
> #ifdef __FreeBSD__
> #include <dirent.h>
> #define	direct		dirent
> #define	DIRSIZ(dp)	_GENERIC_DIRSIZ(dp)
> #else /* !FreeBSD */
25a33
> #endif /* FreeBSD/!FreeBSD */
