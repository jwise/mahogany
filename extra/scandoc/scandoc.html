<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <title>ScanDoc -- Automatic Documentation Utility</title>
  </head>
  <body text="#000000" bgcolor="white" link="#0000EF" vlink="#51188E" alink="#FF0000">
    <h1>ScanDoc</h1>
    <ol>
      <li><a href="#intro">Introduction</a></li>
      <li><a href="#features">ScanDoc features</a></li>
      <li><a href="#getting">Getting Scandoc</a></li>
      <li><a href="#running">Running ScanDoc</a></li>
      <li><a href="#writing">Writing ScanDoc Comments</a></li>
      <li><a href="#tags">Document Tags</a>
	<ul>
	  <li><a href="#package">The @package tag</a></li>
	  <li><a href="#author">The @author tag</a></li>
	  <li><a href="#version">The @version tag</a></li>
	  <li><a href="#keyword">The @keyword tag</a></li>
	  <li><a href="#see">The @see tag</a></li>
	  <li><a href="#param">The @param tag</a></li>
	  <li><a href="#return">The @return tag</a></li>
	  <li><a href="#exception">The @exception tag</a></li>
	  <li><a href="#heading">The @heading tag</a></li>
	  <li><a href="#deffunc">The @deffunc tag</a></li>
	  <li><a href="#defvar">The @defvar tag</a></li>
	  <li><a href="#caution">The @caution, @warning, @tip, and @bug tags</a></li>
	  <li><a href="#ttodo">The @todo tag</a></li>
	</ul>
      </li>
      <li><a href="#template">The Template File</a></li>
      <li><a href="#todo">To-Do List</a></li>
      <li><a href="#credits">Credits</a></li>
    </ol>

    <hr>

    <a NAME="intro"></a>
    <h2>Introduction</h2>
    <blockquote>
      <p>
	ScanDoc is a Perl script which scans C++ source code for specially-formatted
	comments and produces attractive, organized, indexed documentation.
      </p>
      <p>
	ScanDoc is designed to generate the highest-quality documentation with
	as little effort as possible on the part of the programmer writing the
	code to be documented. To this end, ScanDoc not only uses the documentation
	supplied by the programmer, but supplements it by parsing the actual C++
	data structure declarations.
      </p>
      <p>
	Unlike other documentation scanners, Scandoc is <i>themable</i>, meaning
	that the appearance of the output documentation can be controlled via a
	"template" file. <a href="sample/index.html">Here is an example</a> of
	a template which produces HTML output incorporating frames and indices
	can be seen.
      <p>
	ScanDoc was written by <a href="http://www.sylvantech.com/~talin">Talin</a>
	and is Copyright &copy;1997-2000. Scandoc may be freely distributed under
	the Artistic License (see COPYING)&nbsp;<a NAME="features"></a>
      </p>
    </blockquote>

    <h2>ScanDoc features</h2>

    <ul>
      <li><b>Portability</b> -- because ScanDoc is written in Perl, it can be 
	executed on any platform that runs Perl.</li>
      <li><b>Ease of Use</b> -- Once ScanDoc is set up it is very easy to use. There
	are only a few command-line switches, all of which are optional.</li>
      <li><b>Convenient</b> -- ScanDoc's comments are a superset of <b>javadoc</b>
	and are very easy to write.</li>
      <li><b>Customizable</b> -- ScanDoc uses a user-modifiable template file as
	the source of all output text. You can give your documentation a unique
	style without modifying the ScanDoc script itself.&nbsp; Scandoc has been
	designed primarily to support HTML output, however templates can readily
	be modified to support other output file types such as postscript, TeX,
	.info, ASCII, etc.</li>
      <li><b>Comprehensive</b> -- ScanDoc understands a wide range of C++ syntax,
	including operator overloads, templates and template arguments, nested
	classes, and friend functions.</li>
      <li><b>Fast</b> -- a typical header file takes 1-2 seconds to process.</li>
      <li><b>Flexible</b> -- functions can be grouped in any way you like. You decide
	which functions go into which .HTML files.<a NAME="getting"></a></li>
    </ul>

    <h2>Getting Scandoc</h2>
    <blockquote>    
      <p>
	Scandoc is available via anonymous CVS:
      </p>
      <blockquote>
	<pre>cvs -d:pserver:anonymous@cvs.scandoc.sourceforge.net:/cvsroot/scandoc login
&lt;(hit return when asked for password.&gt;
cvs -z3 -d:pserver:anonymous@cvs.scandoc.sourceforge.net:/cvsroot/scandoc co scandoc</pre>
</blockquote>
      <p>
	There is also a .tar.gz archive 
	available on the <a href="http://scandoc.sourceforge.net/">ScanDoc Home Page</a>.
      </p>
    </blockquote>

    <a NAME="running"></a>
    <h2>Runing Scandoc</h2>
    <blockquote>
      <p>
	Scandoc takes several command line switches (all of which are optional)
	and a list of input source files (which can include wildcards). Here is
	the command line syntax:
      </p>
      <blockquote>
	<pre>perl ScanDoc.pl -i <i>document-template</i> -p <i>output-path</i> -t <i>tabsize</i> -d <i>sym</i>=<i>value input-files</i> ...</pre>
      </blockquote>
      <p>
	The <i>document-template</i> argument specifies which file to use for the
	template file. This template file is used to define the format of the output
	text. You can edit this file to customize the "look" of your documentation.
	The default is "template.html".
      </p>
      <p>
	The <i>output-path</i> argument specifies the directory where
	the resulting documentation should be written to. This should include a
	directory seperator character ("\" for PC, ":" for Mac using MPW, and "/"
	for unix) as the last character. The default is the current directory.
      </p>
      <p>
	The <i>tabsize</i> argument specifies how many spaces tabs should
	be expanded to. The default is 4.
      </p>
      <p>
	The <i>sym=value </i>argument can be used to define a symbol. This symbol
	will be defined within the scope of the expanded template, and can be used
	as part of the output text.
      </p>
      <p>
	It does not matter if there are whitespace characters between
	the switches and their arguments.
      </p>
      <p>
	Example:
      </p>
      <blockquote>
	<pre>perl ScanDoc.pl -itemplate.html -p./test/ -t4 *.h</pre>
      </blockquote>
    </blockquote>

    <a NAME="writing"></a>
    <h2>Writing ScanDoc Comments</h2>
    <blockquote>
      <p>
	In order to use ScanDoc, you must embed special comments within your C++
	source files. ScanDoc recognizes two forms of comments, those beginning
	with "<tt>/**</tt>" and those beginning with "<tt>//*</tt>". The first
	form are C-style multi-line comments. The second style are C++ single-line
	comments. There must be a space after the "<tt>/**</tt>" and "<tt>//*</tt>"
	tokens -- ScanDoc does not recognize comments of the form "<tt>/************</tt>"
	and such. (However, if ScanDoc detects a row of asterisks, equals signs,
	or dashes on the first or last line of a C-style comment, it will remove
	them from the documentation. So you can say "<tt>/** ===============</tt>"
	if you want a big, bold banner.)
      </p>
      <p>
	Whenever ScanDoc sees a special comment, it knows that the next C++
	declaration (class, function, or variable) should be documented. Any declaration
	which is not preceded by a special comment will be omitted from the output
	file. The purpose for this is to allow you to have private functions or
	classes which are not present in the ScanDoc documentation. You can use
	ordinary C and C++ style comments to document these declarations within
	the source code, since ScanDoc ignores such comments.
      </p>
      <p>
	The simplest way to use the special comments is to simply write
	a description of the item within the comments:
      <blockquote>
	<pre>/** Documentation for class Foo */
class Foo : private class Bar {
  int Baz( void );
};
</pre>
      </blockquote>
    </blockquote>

    <a NAME="tags"></a>
    <h2>Document Tags</h2>
    <blockquote>
      <p>
	Document tags are special code which can be inserted within a ScanDoc comment.
	They allow you to control many aspects of the generated documentation.
	All document tags begin with an '@' character.
      </p>
      <p>
	All tags must come at the beginning of a line of text (before any non-blank
	characters). All of the text on that line is considered part of the tag.
      </p>
      <p>
	Many of the tags described are <i>persistent</i>, in the sense that
	they remain in effect until the next tag of the same type. A persistent
	tag affects all documented items which come after it, in other words it's
	effect can last for longer than a single documentation comment block.
      </p>
      <p>
	Some of the tags described are <i>continuable</i>, which means that
	they can be continued on the next line. There is no need to repeat the
	tag. Continuable tags last until the end of the comment block, or until
	they are overridden by another tag.
      </p>
      <p>
	Text which occurs before the first tag is considered "description" text,
	in other words it's the actual explanation of the declaration which follows
	the comment. This is also true of any lines of text which do not begin
	with a tag, and are not a continuation of a previous continuable tag. A
	blank line within the description text is converted into an HTML paragraph
	tag. Note that you are allowed to insert HTML tags into the description
	text, however if you are outputting the text to a format other than HTML,
	the output template file may or may not be smart enough to translate the
	tag into an appropriate textual entity.
      </p>
      <p>
	Example description:
      </p>
      <blockquote>
	<pre>/** This function adds two vectors together.
    @param      inVector1  The first vector
    @param      inVector2  This is the second vector
    @return     The vector sum of the two vectors
    @see        #VectorSubtract
    @keywords   Vector addition subtraction math
*/
const Vector &amp;VectorAdd( const Vector &amp;inVector1, const Vector &amp;inVector2 );</pre>
      </blockquote>
    </blockquote>
    
    <a NAME="package"></a>
    <h3>The @package tag</h3>
    <blockquote>
      <p>
	Often times C++ functions and classes fall into natural groups. In Java,
	these are called "packages", however in C++ there is no such construct,
	so the @package tag can be used to group C++ declarations into a package.
	ScanDoc writes the output documentation for each package as a seperate
	.HTML file containing all of the documentation for that package named "<i>packagename</i>.HTML".
	(Of course, that's only the default behavior. You can change it by editing
	the document template file, as well as changing the names of the two index
	files that ScanDoc creates.)
      </p>
      <p>
	You can have classes from several different header files be grouped
	into the same package, or you can have several classes from a single source
	file go into several different packages. There is no one-to-one mapping.
      </p>
      <p>
	The syntax for @package is:
      </p>
      <blockquote>
	<pre>@package <i>package-name</i></pre>
      </blockquote>
      <p>
	The @package tag is persistent -- it remains in effect until the end of
	the file, unless superceded by another @package tag. If no package tag
	is specified, the default package named "General" is used.&nbsp;
      </p>
    </blockquote>
    
    <a NAME="author"></a>
    <h3>The @author tag</h3>
    <blockquote>
      <p>
	The @author is used to specify the author of the subsequent declarations.
	The entire line after @author is taken as the name of the author(s). Like
	the @package tag, it is persistent -- it remains in effect until the end
	of the file, unless superceded by another @author tag.
      </p>
    </blockquote>

    <a NAME="version"></a>
    <h3>The @version tag</h3>
    <blockquote>
      <p>
	The @version is used to specify the version of the subsequent declarations.
	The entire line after @version is taken as the version string. Like the
	@package tag, it is persistent -- it remains in effect until the end of
	the file, unless superceded by another @version tag.
      </p>
    </blockquote>

    <a NAME="keyword"></a>
    <h3>The @keyword tag</h3>
    <blockquote>
      <p>
	The @keyword tag is primarily designed for use with HTML search engines.
	The rest of the line after the @keyword tag is taken as a series of search
	keywords. The keywords will not actually appear in the documentation, instead
	they are placed into an HTML comment just before the documentation appears.
      </p>
    </blockquote>

    <a NAME="see"></a>
    <h3>The @see tag</h3>
    <blockquote>
      <p>
	Each documentation entry can have a "See also" section, which is a list
	of hypertext references to other relevant documentation. Each occurance
	of an @see tag defines a hyperlink. (You can also embed normal HTML hyperlinks
	within the class description and other places).
      </p>
      <p>
	Immediately following the @see tag is the name of the class, class member,
	or global being referenced. A single name with no special seperator characters
	is taken to be the name of a class. The package name can be specified by
	giving the name of the package, followed by '#', followed by the name of
	the class or function. If the package name is omitted, it assumes that
	the item being referred to is in the current package. Class members can
	be referenced by appending '::' and the member name to the class name.
	A '::' with no class name indicates a global function or member. Member
	functions and global functions should not have argument lists or parenthesis
	(Currently there is no way to indicate which one of a set of overloaded
	functions is being referred to)
      </p>
      <p>
	You can also include hyperlinks to other documentation that was not
	created by ScanDoc by using a normal HTML hyperlink, which ScanDoc will
	insert verbatim into the output file.
      </p>
      <p>
	Here are all of the supported forms:
      </p>
      <blockquote>
	<pre>@see&nbsp; classname
@see  package#classname
@see  classname::member
@see  package#classname::member
@see  ::function
@see  package#::function
@see  &lt;a href="ref"&gt;Description&lt;/a&gt;</pre>
      </blockquote>
    </blockquote>

    <a NAME="param"></a>
    <h3>The @param tag</h3>
    <blockquote>
      <p>
	The param tag is used for documenting function parameters. Following the
	@param keyword is the name of the parameter, and then the description.
	The @param tag is continuable, which means you can continue the description
	on the next line. Blank lines within the parameter descriptsion are converted
	into HTML paragraph tags.
      </p>
      <p>
	Example:
      </p>
      <blockquote>
	<pre>@param inRect   The input rectangle to process. This will be scaled and copied to outRect.
@param outRect  Where to place the scaled rectangle</pre>
      </blockquote>
    </blockquote>

    <a NAME="return"></a>
    <h3>The @return tag</h3>
    <blockquote>
      <p>
	The @return tag is used to describe the function return. If the function
	returns nothing, this tag can be omitted. The tag is continuable, which
	means you can continue the description on the next line without repeating
	the @return tag.&nbsp;<a NAME="exception"></a>
      </p>
    </blockquote>

    <h3>The @exception tag</h3>
    <blockquote>
      <p>
	The @exception tag is used to document any exceptions that may be thrown
	by this function. Note that unlike Java, it is difficult in C++ to determine
	what exceptions might potentially be thrown by subroutines of the functions
	being documented, so it is questionable whether programmers will be able
	to easily maintain a list of every exception that could be thrown from
	the function. Ultimately, the decision of how to handle this will depend
	on local coding standards and practices.
      </p>
      <p>
	The format of this section is exactly the same as @param.
      </p>
    </blockquote>

    <a NAME="heading"></a>
    <h3>The @heading tag</h3>
    <blockquote>
      <p>
	The @heading tag is used to insert a heading into your description text.
	The remainder of the line after @heading is taken as the heading text (the
	@heading tag is not continuable). When processed using the example template
	file, ScanDoc converts the heading text to a level two heading.
      </p>
    </blockquote>

    <a NAME="deffunc"></a>
    <h3>The @deffunc tag</h3>
    <blockquote>
      <p>
	Occasionally, a function will have a syntax so strange that ScanDoc cannot
	parse it. This is mainly due to the fact that ScanDoc does not have a complete
	C++ parser within it. Also, ScanDoc ignores all preprocessor directives,
	so it is difficult to add documentation entries for C macro functions.
	The @@deffunc tag overcomes this limitation by allowing the programmer
	to manually insert a "fake" function declaration.
      </p>
      <p>
	The @deffunc tag is short for "define function". The effect of this
	tag is exactly the same as if ScanDoc had actually parsed the function
	declaration. Note that this means that the @deffunc must be the last tag
	in the comment block, since any text or tags which come after it will be
	applied to the <i>next</i> declaration.
      </p>
      <p>
	The format of @deffunc is:
      </p>
      <blockquote>
	<pre>@deffunc <i>short-name declaration</i></pre>
      </blockquote>
      <p>
	The "short-name" is the version that will appear in the index, i.e. just
	a name with no argument list or return type. The declaration part is optional,
	and should be the complete prototype.
      </p>
      <p>
	Here is an example (Note that unlike normal declarations, you can use
	HTML formatting within the actual prototype declaration):
      </p>
      <blockquote>
    <pre>/** Assert that a condition is TRUE, or print a message and exit.
   @param expression The condition to test.
   @deffunc ASSERT ASSERT( &lt;<i>expression</i>&lt; );
*/
#define ASSERT( expr ) _assert( expr, __FILE__, __LINE__ )</pre>
      </blockquote>
    </blockquote>

    <a NAME="defvar"></a> 
    <h3>The @defvar tag</h3>
    <blockquote>
      <p>
	The @defvar tag is exactly like @deffunc except it defines a variable instead
	of a function.
      </p>
    </blockquote>

    <a NAME="warning"></a>
    <h3>The @caution, @warning, @tip and @bug tags</h3>
    <blockquote>
      <p>
	Each of these tags inserts a small icon into the text at the point where
	the tag occurs. For example, in the supplied example template, the "caution"
	tag inserts a paragraph break followed by a triangular yellow "caution"
	sign. These icons can be used to highlight a particular aspect of the text.&nbsp;
	It should be noted that none of these three tags is in fact recognized
	by ScanDoc itself -- the substitution of icons for tags is done in the
	template file, and as such the template file creator is free to define
	any new tags that they wish.
      </p>
    </blockquote>
    
    <a NAME="ttodo"></a>
    <h3>The @todo tag</h3>
    <blockquote>
      <p>
	The @todo tag records the name of the current source file and the text
	of the tag (which is continuable) into a special "todo" table. This table
	is then written out as a seperate file, allowing a conveniently summarized
	"To-Do" list for the project. Note that a special comment with only an
	"@todo" entry in it and no other description text or tags will be included
	in the generated To-Do list, but not in any other generated documentation;
	The reason for this is that you might not want to document everything that
	also has a To-Do entry associated with it, so the scanner does not consider
	a documentation entry valid unless it has at least <i>some</i> descriptive
	text or tags.
      </p>
    </blockquote>

    <a NAME="template"></a>
    <h2>The Template File</h2>
    <blockquote>
      <p>
	The template file tells ScanDoc how to format the output files. There is
	virtually no knowledge of HTML within ScanDoc itself, all of the rest is
	supplied by the template file. (Actually, there are some functions that
	make generating HTML easier, but templates don't have to use them.)
      </p>
      <p>
	ScanDoc comes with an example template file called "template.html".
	If all you want to do is change the name of the project or insert your
	company logo, you need read no further; Simply edit the "template.html"
	file and insert your project name or logo in the appropriate fields at
	the top of the file.
      </p>
      <p>
	If you want to do more detailed customization, however, you'll need
	to understand how a template file is actually intepreted, which requires
	some understanding of ScanDoc's overall order of operations. You'll also
	need a basic understanding of the Perl language.
      </p>
      <p>
	When ScanDoc scans source files, it builds a large data structure which
	stores all of the packages, classes, member functions, parameters, documentation
	and other entities that it finds. These are stored using nested Perl hash
	tables.
      </p>
      <p>
	After parsing is complete, the template file is parsed and executed.
	The template file consists mostly of output text, with occasional parameter
	substitutions and embedded program code. ScanDoc translates the template
	file into a long string which is a Perl program, and then executes that
	string. So, you can embed Perl code directly into the template, allowing
	you to open output files, iterate using "for" loops, create comma-seperated
	lists, etc. This embedded code has access to all of the data structures
	built during the parsing phase.
      </p>
      <p>
	Any text which is not embedded code will be written directly to the
	current output file. This text can have parameter substitutions in it.
	There are two primary types of substitions. The first type is the normal
	Perl interpolation sequence, i.e. $<i>variable</i>. This means that the
	value of the variable will be inserted into the output text at that point.
	The other type of substitution is the sequence $(object.fieldname). This
	retrieves the named field from the given object, and inserts the value
	of that field into the output text at that point. (Note: The way this is
	implemented is that ScanDoc translates the $(object.fieldname) pattern
	into the sequence:&nbsp; "print $object->fieldname()").
      </p>
      <p>
	Embedded code is indicated by using double angle brackets, i.e. &lt;&lt;code&gt;&gt;.
	Any code which is within the angle brackets will be executed at that point.
	For loops can be written as seperate pieces, i.e.
      </p>
      <blockquote>
      <pre>&lt;&lt;foreach $a (@list) {&gt;&gt;
    &lt;h2&gt;$(a.name)&lt;/h2&gt;
    $(a.description)&lt;p&gt;
&lt;&lt;}&gt;&gt;</pre>
      </blockquote>

    <p>
      Access to the parse tables and other data is done through global functions,
      which are as follows:
    </p>
    <center>
      <table BORDER=2 WIDTH="80%" >
	<caption>
          <center>&nbsp;ScanDoc Global Functions</center>
        </caption>
      <tr>
	<td>Function</td>
	<td>Meaning</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>file( "filename.txt" )</tt></td>
	
	<td>Open a new output file and make it the current output file</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>packages</tt></td>
	
	<td>Return a list of references to all packages, in order by name.</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>todolist_files()</tt></td>
	
	<td>Returns a list of all source files which had "to-do" entries.</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>todolist_entries( file )</tt></td>
	
	<td>Returns a list of all "to-do" entries for a given file.</td>
      </tr>
    </table></center>
    
    <p>
      Each package is a reference to a Perl object of type "PackageRecord".
      Access to the classes and globals within the package is done via the member
      functions of the package.
    </p>

    <center>
      <table BORDER=2 WIDTH="80%" >
	<caption>
      <center>"PackageRecord" Member functions</center>
    </caption>
      
      <tr>
	<th>Function</th>
	
	<th>Meaning</th>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>classes</tt></td>
	
	<td>Returns a list of references to all classes in the package, in order
	  by name.</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>globals</tt></td>
	
	<td>Returns a list of all global functions and variables in the package,
	  in order by name.</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>globalvars</tt></td>
	
	<td>Returns a list of references for all global variables in the package.</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>globalfuncs</tt></td>
	
	<td>Returns a list of references for all global functions in the package.</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>name</tt></td>
	
	<td>Returns a string containg the name of the package</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>url</tt></center>
	</td>
	
	<td>
	  <center>Returns the suggested HTML url of the package documentation.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>anchor</tt></center>
	</td>
	
	<td>
	  <center>Returns the suggested HTML anchor of the package documentation.</center>
	</td>
      </tr>
    </table></center>
    
    <p>Each class returned by the classes() member function is a reference
      to a Perl object of type ClassRecord. This class has the following member
      functions.
      <br>&nbsp;
    <center><table BORDER=2 WIDTH="80%" >
	<caption>
      <center>"ClassRecord" Member functions</center>
    </caption>
      
      <tr>
	<th>Function</th>
	
	<th>Meaning</th>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>keywords</tt></td>
	
	<td>Returns a string the list of keywords associated with this class.</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>author</tt></td>
	
	<td>Returns the name of the author of the class.</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>version</tt></td>
	
	<td>Returns a string containing the version information for the class.</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>name</tt></td>
	
	<td>Returns a string containing the "short" name of the class, i.e. without
	  "class" or "struct", and without any template params or scoping information.</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>longname</tt></td>
	
	<td>Similar to "name" but includes the "class" or "struct" tag.</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>fullname</tt></center>
	</td>
	
	<td>
	  <center>Includes the "class" or "struct" tag and the template arguments.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>scopename</tt></center>
	</td>
	
	<td>
	  <center>The complete class name including scoping information for embedded
	    classes.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>source file</tt></center>
	</td>
	
	<td>
	  <center>The name of the source file where the class was defined.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>description</tt></center>
	</td>
	
	<td>
	  <center>The description text of the class documentation.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>seealso</tt></center>
	</td>
	
	<td>
	  <center>The list of "see also" tags. This is a list of references to "DocReference"
	    objects.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>url</tt></center>
	</td>
	
	<td>
	  <center>Returns the suggested HTML URL of the class documentation.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>anchor</tt></center>
	</td>
	
	<td>
	  <center>Returns the suggested HTML anchor of the class documentation.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>members</tt></center>
	</td>
	
	<td>
	  <center>Returns a list of references to all class members.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>membervars</tt></center>
	</td>
	
	<td>
	  <center>Returns a list of references to all class member variables.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>memberfuncs</tt></center>
	</td>
	
	<td>
	  <center>Returns a list of references to all class member functrions.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>baseclasses</tt></center>
	</td>
	
	<td>
	  <center>Returns a list of references to all base classes.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>subclasses</tt></center>
	</td>
	
	<td>
	  <center>Returns a list of references to all subclasses.</center>
	</td>
      </tr>
    </table></center>
    
    <p>Each member function record returned by the members() function (as well
      as the membervars() and memberfuncs()) function is a reference to a Perl
      object of type MemberRecord. MemberRecord is also used for the references
      returned by globals(), globalvars(), and globalfuncs() which are returned
      at the package level.
      <br>&nbsp;
    <center><table BORDER=2 WIDTH="80%" >
	<caption>
      <center>"MemberRecord" Member functions</center>
    </caption>
      
      <tr>
	<th>Function</th>
	
	<th>Meaning</th>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>keywords</tt></td>
	
	<td>Returns a string the list of keywords associated with this member.</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>author</tt></td>
	
	<td>Returns the name of the author of the member.</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>version</tt></td>
	
	<td>Returns a string containing the version information for the member.</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>name</tt></td>
	
	<td>Returns a string containing the "short" name of the class, i.e. without
	  the type or argument list.</td>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>longname</tt></td>
	
	<td>Similar to "name" but includes '()' at the end if it's a function.</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>fullname</tt></center>
	</td>
	
	<td>
	  <center>Includes the type of the variable and the arguments if any.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>scopename</tt></center>
	</td>
	
	<td>
	  <center>The complete member name including scoping information.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>source file</tt></center>
	</td>
	
	<td>
	  <center>The name of the source file where the member was defined.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>description</tt></center>
	</td>
	
	<td>
	  <center>The description text of the member documentation.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>seealso</tt></center>
	</td>
	
	<td>
	  <center>The list of "see also" tags. This is a list of references to "DocReference"
	    objects.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>url</tt></center>
	</td>
	
	<td>
	  <center>Returns the suggested HTML URL of the member documentation.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>anchor</tt></center>
	</td>
	
	<td>
	  <center>Returns the suggested HTML anchor of the member documentation.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>type</tt></center>
	</td>
	
	<td>
	  <center>'func' if it's a function, else 'var' if it's a variable.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>params</tt></center>
	</td>
	
	<td>
	  <center>Returns a list of parameters (as defined by the @param tags) for
	    this item.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>exceptions</tt></center>
	</td>
	
	<td>
	  <center>Returns a list of exceptions (as defined by the @exception tags)
	    for this item.</center>
	</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>returnval</tt></center>
	</td>
	
	<td>
	  <center>Returns the text of the @return tag.</center>
	</td>
      </tr>
    </table></center>
    
    <p>Parameters and exceptions are Perl objects of type "ArgRecord", which
      has the following members:
      <br>&nbsp;
    <center><table BORDER=2 WIDTH="80%" >
	<caption>
      <center>"ArgRecord" Member functions</center>
    </caption>
      
      <tr>
	<th>Function</th>
	
	<th>Meaning</th>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>name</tt></td>
	
	<td>Returns a string containg the name of the argument</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>description</tt></center>
	</td>
	
	<td>
	  <center>Returns the description text for the argument.</center>
	</td>
      </tr>
    </table></center>
    
    <p>Finally, the list of references returned by the "seealso" function are
      references to Perl objects of type "DocReference":
      <br>&nbsp;
    <center><table BORDER=2 WIDTH="80%" >
	<caption>
      <center>"DocReference" Member functions</center>
    </caption>
      
      <tr>
	<th>Function</th>
	
	<th>Meaning</th>
      </tr>
      
      <tr ALIGN=CENTER>
	<td><tt>name</tt></td>
	
	<td>Returns a string containg the name of the reference</td>
      </tr>
      
      <tr>
	<td>
	  <center><tt>url</tt></center>
	</td>
	
	<td>
	  <center>If ScanDoc knows about this reference, it will return the URL string
	    that it suggested; If the item is not recognized, it will return 0.</center>
	</td>
      </tr>
    </table></center>
    
    <p><b>Base classes:</b> In some cases, a base class mentioned in another
      class's "baseclasses" list will be a class that ScanDoc does not know about.
      Because ScanDoc does not parse #include directives, it's possible for a
      class to inherit from a base class that is defined outside the set of files
      being parsed by ScanDoc. In this case, ScanDoc will create a "partial"
      class record, consisting of only the name, longname, fullname, and scopename
      fields. In particular, the "url()" member function will return 0, since
      ScanDoc does not know from where this class originates. In such a case,
      the output template should detect that there is no URL and not attempt
      to create a hyperlink for the class reference.
    <p><b>Description Filtering:</b> The description text returned by the "description()"
      function returns the bare text as found within the source code. The only
      filtering that ScanDoc does on this text is to expand all tabs to spaces.
      The template code is responsible for any other filtering, such as converting
      blank lines to paragraphs, converting @heading tags to the appropriate
      style, and inserting the caution, warning and bug icons. Note that the
      template is free to define new icons or tags which can be filtered at this
      time.
      </p>
    </blockquote>

    <a NAME="todo"></a>
    <h2>To Do list</h2>
    <blockquote>
      <p>
	This is a list of enhancements that are needed for ScanDoc.
      </p>
      <p><b>Templates for formats other than HTML:</b> Currently, HTML is the
	only output format supported because it's the only one that I am familiar
	with. However, it seems that a lot of documentation these days is in TeX
	format, which is then used to generate .info, .dvi. etc. It would be nice
	to have template files for these formats. Note also that there is no reason
	why ScanDoc could not be modified to support multiple templates in a single
	execution, which would be relatively fast since parsing the input classes
	is what takes 95% of the execution time.
      <p><b>Other HTML templates:</b> It would be nice to have a selection of
	HTML templates for different styles. For example, the current template
	file generates documentation which takes advantage of the "frames" feature
	which is not supported by all browsers, although the documentation can
	still be viewed with a browser that does not support frames. However, it
	might be nice to provide templates which don't generate any frames information.
	Similarly, there is much that can be done in terms of improving the overall
	attractiveness and organization of the documents, especially by taking
	better advantage of tables.
      <p><b>Include files:</b> Currently, ScanDoc does not attempt to parse "#include"
	statements. (As much as I like Perl, it's not a great language for writing
	recursive descent parsers in my opinion.) Unfortunately, this means that
	ScanDoc has to "guess" which identifiers represent types as opposed to
	function and variable names. The current heuristic handles all of the cases
	I've found so far, but it would be nice to be able to know for sure. Of
	course, doing a complete job would also require that we recognize and expand
	C macros. Having a complete set of type information and better parsing
	would also allow individual function arguments and return values to be
	hyperlinks.
      <p><b>Hyperlinks on arguments and return values:</b> Even without a more
	complete parser, it would be possible to modify the current HTML template
	file to break up argument lists into a sequence of bare words and see if
	any of those bare words match up with any of the current classes that ScanDoc
	knows about. Hyperlinks could then be created to those classes. This wouldn't
	work every time (for example, implicit references to classes defined within
	the current class's scope would have problems), but it would cover most
	of the common cases.
      <p><b>Improved description filtering:</b> Currently, the "processDescription"
	function in the HTML template does not handle the case of '&lt;' and '>'
	symbols embedded in the description text. This means that attempts to mention
	template arguments within documentation generally don't look right. Greater-than
	and Less-than signs should usually be transformed into &amp;lt; and &amp;gt;
	sequences, unless they are part of a valid HTML tag that has been deliberately
	inserted into the documentation text. I would need to come up with a look-ahead
	regex that would match all of the HTML tags that might reasonably occur
	inside a documentation entry.
      <p><b>Persistent Scan Info:</b> Several people have suggested that they
	would like to keep their documentation files always up to date, in other
	words running ScanDoc whenever they do a make. Unfortunately, because ScanDoc
	scans every file in the project, this is far too slow for realistically-sized
	projects. One idea would be to create a persistent database of documentation,
	which could be updated incrementally, allowing ScanDoc to only scan those
	files that have actually changed. This would also allow the code analyzer
	to be written in a different language than the templates. For example,
	we could use a real parser generator, and make a C analyser that would
	do a much more complete job of parsing, as well as being much faster. This
	would also have the benefit of making the parser somewhat readable, which
	it certainly isn't now.
      <p>Because ScanDoc can pretty much ignore anything that's inside a code
	block, a C parser could potentially parse much faster than an actual compiler.
	This means that scanning just a few files and updating a database would
	add an unnoticeable amount of delay to the build process. The only question
	is how to maintain the database in a way that's portable.
      <p>This idea of a persistent database of documentation could be taken even
	further. For example, rather than generating static pages, the documentation
	pages could be served up directly from the database, using something like
	PHP to create HTML pages of documentation on the fly as needed. This would
	also allow more intelligent queries, for example "give me documentation
	for all classes that call member function 'foo' in class 'bar'." Of course,
	we would have to parse things a lot more deeply than we do now for this
	to work. And one problem with dynamic pages is that they are hard to distribute
	in an archive.
    </blockquote>

    <h2>History and credits</h2>
    <blockquote>
      <p>
	The current version of ScanDoc is actually the sixth generation. The first
	one was written in C, sometime in the early 1993-1994 range, and was inspired
	by (and functionally similarly to) the "autodoc" utility on the Commodore
	Amiga. Later versions were inspired by Sun's JavaDoc utility. I've also
	read about Don Knuth's "Literate Programming" efforts, but I wanted something
	that was much lighter weight and easier to integrate into existing environments.
      </p>
      <p>
	Robert McNally of Dangerous Games came up suggested to me the idea of
	having embedded icons in the documentation to signify important paragraphs.
      </p>
    </blockquote>
    <hr>
    &copy; 1997-2000 Talin.
    <br>Last Updated: 26 June 1998
  </body>
</html>
